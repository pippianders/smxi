#!/bin/bash
########################################################################
####  Script Name: sm-lib-apt-tools
####  version: 1.17.4
####  Date: August 18 2008

####  Copyright (C) Harald Hope 2005-2008
####  This program is free software; you can redistribute it and/or modify it under 
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.

####  This program is distributed in the hope that it will be useful, but WITHOUT 
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

####  Get the full text of the GPL here:
####  http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

####  Script Author: Harald Hope 
####  This is a library file for smxi and cannot be run independently

####  Script URL: http://techpatterns.com/downloads/distro/sm-lib-apt-tools
####  Script Home page: http://techpatterns.com/forums/about736.html
########################################################################

# one global here just for convenience
CHECK_HOLD_PACKAGES='amule:amule-common elinks:elinks-data gimp-help-common:gimp-helpbrowser gnucash:gnucash-common k3b:k3b-data libgnokii3:gnokii-common pidgin:pidgin-data rosegarden:rosegarden-data thunar:thunar-data xchat:xchat-common xfdesktop4:xfdesktop4-data xsane:xsane-common'
#egrep -o -m1 "^(deb|deb-src)\s*http://sidux.com/debian/" /etc/apt/sources.list
###---------------------------------------------------------------------
### core apt utilities, test / install / remove / error handler
###---------------------------------------------------------------------

# args: $1 - package to be tested, this simply will echo a value for the test
# $2 - optional - options: ii; hi; wild; wild-full; ii-wild; rc; rc-wild; rc-all
# default hi-ii; no wild search
# this replaces all the locally run if present type tests
package_tester()
{
	eval $LOGUS
	local item=$1 doWild='+' installType='(hi|ii)' wildFull='' packageStatus=''
	
	case "$2" in
		wild)
			doWild='*'
			;;
		wild-full)
			wildFull='.*'
			doWild='*'
			;;
		ii)
			installType='(ii)'
			;;
		ii-wild)
			installType='(ii)'
			doWild='*'
			;;
		hi)
			installType='(hi)'
			;;
		rc)
			installType='(rc)'
			;;
		rc-all)
			installType='(rc)'
			doWild='*'
			item=''
			;;
		rc-wild)
			installType='(rc)'
			doWild='*'
			;;
		"")
			: # note, this allows error handling AND null $2, which is an optional arg
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$2"
			;;
	esac

	# note that we need [ \t]+ so that only cases of whitespace after are counted
	packageStatus=$( dpkg -l | awk '/^'$installType'[ \t]*'$wildFull$item'[ \t]'$doWild'/{print $2}' )
	echo $packageStatus
	log_function_data "Package $installType status: $packageStatus"
	eval $LOGUE
}

 
# Returns null if package is not available in user system apt.
# args: $1 - package to test; $2 [optional] - candidate/installed
check_package_status()
{
	eval $LOGUS
	local packageVersion='' statusType='Candidate:'
	
	if [ "$2" == 'installed' ]
	then
		statusType='Installed:'
	fi
	
	LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( apt-cache policy $1 2>/dev/null | grep -i "$statusType" | cut -d ':' -f 2-4 | cut -d ' ' -f2 | grep -iv '\(none\)' )
	
	echo $packageVersion
	log_function_data "Package Version: $packageVersion"
	eval $LOGUE
}

# args: $1 package to install; $2 install/install-optional/force-always/force-present
# $3 - optional installer args, like: --reinstall, etc...
# force-always will force the install no matter what, with install -f
# force-present will just do it if package is present, with install -f
# install-always/install-user installs always. Also use this for multiple packages 
# where one might be installed and the other not.
# install-user is user initiated action, only if package is not already installed
# install-missing installs only if present in user system
# install-user-ok does not force install, but lets user accept or reject.
package_installer()
{
	eval $LOGUS
	#local prefId=$3
	# we can't ever send a null value to sm_pref_tester or it hangs the script
	#[ -z "$prefId" ] && prefId='no-set'
	#local smPref=$( sm_pref_tester $prefId )
	local packageExists='' package='' packageTemp='' dumpSpace=''
	local installType=$2 doYes=' -y' forceIt='' extraInstallArgs=$3
	local installAlways='' installAbsent='' installPresent=''
	local installError=0 forceError=0 installIt='' install='install'
	local altText1='Installing' altText2=' to update your system'
	local testOption='ii' packagePlural1='' packagePlural2='is'
	
	# set the plural text
	if [ "$( wc -w <<< $1 )" -gt 1 ]
	then
		packagePlural1='s'
		packagePlural2='are'
	fi

	case $installType in
		force-always)
			forceIt='true'
			altText1='Forcing install of'
			installAlways='true'
			;;
		force-present)
			forceIt='true'
			altText1='Forcing install of'
			testOption='' # do wildcard search, not just ii
			installPresent='true'
			;;
		install-always)
			installAlways='true'
			;;
		install-missing)
			altText1="Installing missing package$packagePlural1"
			ltText2=''
			installAbsent='true'
			;;
		install-user)
			altText2=' by user request'
			testOption='' # do wildcard search, not just ii
			installAbsent='true'
			;;
		install-user-ok)
			altText2=' by user request'
			installAlways='true'
			doYes=''
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$installType"
			;;
	esac
	
	if [ "$APT_TYPE" == 'aptitude' ]
	then
		if [ "$SYSTEM_BASE" == 'stable' ]
		then
			# I can't find the etch aptitude command for this, so removing it for now
			extraInstallArgs=$( sed -e 's/--allow-unauthenticated//' <<< $extraInstallArgs )
		else
			extraInstallArgs=$( sed -e 's/--allow-unauthenticated/--allow-untrusted/' <<< $extraInstallArgs )
		fi
		if [ -n "$( grep '\--reinstall' <<< $extraInstallArgs )" ]
		then
			extraInstallArgs=$( sed 's/--reinstall//' <<< $extraInstallArgs )
			install='reinstall'
		fi
		doYes='' # because of how aptitude handles this stuff, no auto yes yet
	fi
	#  no point running these tests if they are not needed
	if [ "$installAlways" != 'true' ]
	then
		for package in $1
		do
			packageTemp=$( package_tester $package $testOption )
			# here we handle cases where one of several is null, so we want to install all
			if [ -z "$packageTemp" ]
			then
				installIt='true'
			fi
			# don't add a space or the -n test will be true
			packageExists="$packageExists$packageTemp"
		done
		# just want to make sure here that's it's going to be truly null
		packageExists=$( echo $packageExists | sed 's/\s//g' )
	fi
	# nullify the entire set if one member is null
	if [ "$installIt" == 'true' ]
	then
		packageExists=''
	fi
	
	#  -o -n "$packageExists"
	# cases: 1-always do it; 2-do if absent and to install misssing;
	# 3-do if present required update
	if [ "$installAlways" == 'true' ] || [ "$installAbsent" == 'true' -a -z "$packageExists" ] || [ "$installPresent" == 'true' -a -n "$packageExists" ]
	then
		echo # just for cosmetics here, for multiple packages separates
		echo "${SPACER}${S}$altText1 ${C}$1${S}$altText2...${N}"
		
		if [ "$forceIt" == 'true' ]
		then
			$APT_TYPE install -f $doYes
		fi
		$APT_TYPE $install $doYes $extraInstallArgs $1 || installError=$?
		if [ "$forceIt" == 'true' ]
		then
			$APT_TYPE install -f $doYes || forceError=$?
		fi
	# if user install and already installed...
	elif [ "$installAbsent" == 'true' -a -n "$packageExists"  ]
	then
		echo "${SPACER}${M}The package$packagePlural1: ${C}$1"
		echo "${SPACER}${M}$packagePlural2 already installed on your system. Continuing...${N}"
		echo
	fi
	# only do error handling if either install only, or force/install cases went bad
	if [ "$forceError" -gt 0 ] || [ "$forceIt" != 'true' -a "$installError" -gt 1 ]
	then
		echo "${SPACER}${E}There was a problem with install of: ${C}$1${N}"
		echo
		log_function_data "Error: $installError with install of $1"
		eval $LOGUE
		return 1
	else
		eval $LOGUE
		return 0
	fi
}

# args: $1 - package; $2 - extra args: purge etc
package_remover()
{
	eval $LOGUS
	local packageExists='' item='' removeError=0 extraArgs=$2
	local removeErrorPackage='' packageIsWild='' removePurge='remove'
	local isPurge=$( grep 'purge' <<< $extraArgs )
	
	if [ -n "$isPurge" ]
	then
		extraArgs=$( sed 's/purge//g' <<< $extraArgs  )
		removePurge='purge'
		# etch apt-get doesn't support apt-get purge, just apt-get remove --purge
		if [ "$APT_TYPE" == 'apt-get' -a "$SYSTEM_BASE" == 'stable' ]
		then
			removePurge='remove --purge'
		fi
	fi
	if [ "$APT_TYPE" == 'aptitude' ]
	then
		extraArgs=$( sed 's/-y//' <<< $extraArgs ) # turn off auto yes until tested more
	fi
	
	for item in $1
	do
		packageExists=$( package_tester $item )
		# this is for a single case: eg: some-module*, only wild card ending
		# we're only using this case when packages are already tested for by caller function
		packageIsWild=$( egrep ".*\*" <<< $item )
		if [ -n "$packageExists" -o -n "$packageIsWild" ]
		then
			removeError=0 # reset to no error
			echo 
			echo "${SPACER}${S}Removing package ${C}$item${S}...${N}"
			$APT_TYPE $removePurge $extraArgs $item || removeError=$?
			if [ "$removeError" -gt 0 ]
			then
				echo "${SPACER}${E}Error ${C}$removeError${E} removing package: ${C}$item${N}"
				removeErrorPackage="$removeErrorPackage $item"
				echo
				log_function_data
			fi
		else
			echo "${SPACER}${M}Cannot remove package ${C}$item${M} because it is not installed.${N}"
			echo
		fi
	done
	eval $LOGUE
	if [ -n "$removeErrorPackage" ]
	then
		return 1
	else
		return 0
	fi
}

# returns error message if required for apt functions
# arg: $1 du type; $2 return code
apt_error_handling()
{
	eval $LOGUS
	local options='' opt='' repeat=''
	local fixText='' pText='' response='' aptUpdate='' distUpgrade=''
	
	case $1 in
		du-1|du-2|du-temp)
			fixText="$DU_UPGRADE/install -f"
			pText="$DU_UPGRADE"
			distUpgrade='true'
			;;
		du-f)
			fixText="$DU_UPGRADE/install -f"
			pText='install -f'
			distUpgrade='true'
			;;
		up-du-1|up-du-key1|up-du-key2|up-err-1|up-mirror-1|up-kernel-1|up-package-1|up-app|up-kern-tools|distro-conversion)
			pText="$APT_TYPE update"
			aptUpdate='true'
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$installType"
			;;
	esac
	
	# mirror update happens pre keys so just ignore errors
	# don't do for step 1 of keyrings too
	if [ "$2" -gt 0 -a "$1" != 'up-du-key1' -a "$1" != 'up-mirror-1' ] 
	then
		echo $ELINE
		echo "${E}An error occured in ${C}$pText${E}. The Error number is: ${C}$2"
		echo $ELINE
		if  [ "$distUpgrade" == 'true' ]
		then
			echo "${S}Please run ${C}$fixText${S} again to try to resolve the problem."
			print_hec
		elif [ "$aptUpdate" == 'true' ]
		then
			echo "${S}You have 4 options to resolve this issues. If you select 1 or 2, the information will"
			echo "be logged to ${C}$LOG_FILE${S}"
			echo "${C}1 - $APT_TYPE update-no-pdiffs${S} ${M}Recommended${S} Runs update again without pdiffs."
			echo "    This will fix most update errors except for apt repository offline stuff."
			echo "${C}2 - $APT_TYPE update${S} Runs update again using your current choices."
			echo "${C}3 - change-debian-mirror${S} If the mirror that is failing is a debian mirror (will not say"
			echo "    ${C}sidux${S} in mirror), change to another debian mirror."
			echo "${C}4 - change-sidux-mirror${S} If the mirror that is failing is a ${C}sidux${S} mirror,"
			echo "    change to another sidux mirror."
			echo
			echo "${C}5 - continue${S} Continue without fixing the error, trust that it will be ok."
			echo "${C}6 - quit${S} Exit the script now, try to figure it out yourself."
			echo $LINE
			echo $SLE
			echo $LINE
			
			options='update-no-pdiffs update change-debian-mirror change-sidux-mirror continue quit'
			select opt in $options
			do
				eval $LOGUE
				case $opt in
					update-no-pdiffs)
						echo $LINE
						echo "${S}Running ${C}$APT_TYPE update no pdiffs${S} to solve broken bzip pdiff errors.${N}"
						NO_PDIFFS=$NO_PDIFF_ARGS
						apt_update_handler 'up-error-1'
						;;
					update)
						apt_update_handler 'up-error-1'
						;;
					change-debian-mirror)
						change_debian_mirrors
						;;
					change-sidux-mirror)
						change_kernel_mirrors
						;;
					continue)
						echo $LINE
						echo "${S}Continuing without resolving the ${C}update${S} error.${N}"
						;;
					quit)
						print_quit
						;;
					*)
						print_error opt
						repeat='true'
						;;
				esac 
				break
			done
			
			if [ "$repeat" == 'true' ]
			then
				apt_error_handling $1 $2
			fi
		fi
	else
		eval $LOGUE
	fi
}

###---------------------------------------------------------------------
### package hold / dependency test stuff
###---------------------------------------------------------------------
# this puts things on hold before du and takes them off after it
# args: $1 hold/install/hold-utility - utility is for other uses of this function
set_hold_install()
{
	eval $LOGPS
	local packageName='' userPackages='' statusD='' packageInstalled='' hoIn='ii'
	local dhiTemp=''
	
	# get the data, insert to global for rest of script run through
	if [ "$1" == 'hold' ]
	then
		# get user set hold/install packages first, slice change separator to space
		userPackages="$( sm_pref_tester hold-install equal | tr '^' ' ' )"
		log_function_data "User held packages: $userPackages"
		wget -T$TIME_OUT -t2 -Ncq $TECH_PATTERNS_DISTRO$UPGRADE_DATA$HOLD_INSTALL
		DPKG_HOLD_INSTALL="$( cat $HOLD_INSTALL ) $userPackages"
		log_function_data "Backend hold packages: $( cat $HOLD_INSTALL )"
		if [ -f "$HOLD_INSTALL" ]
		then
			rm -f $HOLD_INSTALL
		fi
		# in theory, only sid fails like this, we'll see how reality compares to theory now
		if [ "$SYSTEM_BASE" == 'sid' ]
		then
			# now let's fire the auto hold/install function to protect against those
			# pesky gimp/pidgin breaks. That function updates the global DPKG_HOLD_INSTALL
			broken_dependency_handler
			# and handle package groups as well
			advanced_broken_dependency_handler 'amarok'
			advanced_broken_dependency_handler 'gimp'
			advanced_broken_dependency_handler 'hplip'
			advanced_broken_dependency_handler 'ooo'
			advanced_broken_dependency_handler 'wesnoth'
		fi
	fi
	log_function_data "Post test hold packages: $DPKG_HOLD_INSTALL"
	if [ -n "$DPKG_HOLD_INSTALL" ]
	then
		echo $LINE
		statusD=$1
		if [ "$statusD" == 'hold-utility' ]
		then
			statusD='hold'
		fi
		# set search for either ii or hi
		if [ "$statusD" == 'install' ]
		then
			hoIn='hi'
		fi
		if [ "$statusD" == 'hold' ]
		then
			echo "${S}${SPACER}Testing hold/install list package status...${N}"
		fi
		for packageName in $DPKG_HOLD_INSTALL
		do
			# only holding installed stuff, have to now handle cases where it's been held
			# I am making this very specific to support users who want to manually set
			# hold install, otherwise using ii|hi would remove holds from user set hold.
			packageInstalled=$( package_tester $packageName $hoIn )
			#packageInstalled=$( package_tester $packageName )
			if [ -n "$packageInstalled" ]
			then
				# append to list holder temp file
				if [ "$1" == 'hold' ]
				then
					dhiTemp="$dhiTemp $packageName"
				fi
				echo "${S}${SPACER}Changing ${C}$packageName${S} dpkg status to: ${C}$statusD${N}"
				echo $packageName $statusD | dpkg --set-selections
				log_function_data "Package $packageName set to: $statusD"
			fi 
		done
		# this step is key, it will avoid trying to put on install packages that are
		# on hold in user system. Only use the packages that are a: not on hold already
		# and b: are installed on user system
		if [ "$1" == 'hold' ]
		then
			DPKG_HOLD_INSTALL="$dhiTemp"
		fi
	fi
	eval $LOGPE
}

## DEBUGGER
#script_debugger 'set_hold_install hold'

# the logic is pretty simple, for faulty packages, with mismatched main and main-data numbers,
# this will get added to the hold stuff.
broken_dependency_handler()
{
	eval $LOGUS
	local versionNumbers='' packageGroup='' subPackage='' 
	local package1='' package2='' tempHolder1='' tempHolder2=''
	local packageInstalled1='' packageInstalled2='' useFull=''
	
	echo $LINE
	echo -n "${S}${SPACER}Checking package groups for version mismatches."
	for packageGroup in $CHECK_HOLD_PACKAGES
	do
		echo -n '.'
		# note, we're ignoring debian subversion data for  now, like 2.6.2-2
		package1=$( echo $packageGroup | cut -d ':' -f1 )
		package2=$( echo $packageGroup | cut -d ':' -f2 )
		# I'm not using (ii|hi) test anymore, to avoid breaking user set holds
		packageInstalled1=$( package_tester $package1 ii )
		packageInstalled2=$( package_tester $package2 ii )
		
		# check if it's installed, no point putting non installed stuff on hold/install
		if [ -n "$packageInstalled1" -a  -n "$packageInstalled2" ]
		then
			# determine whether to do full or partial version number tests
			# using cut -f 2-4 to handle cases of numbering like 1:2.5.6-3
			case $package1 in 
				amule|gnucash|libgnokii3|rosegarden|thunar|xfdesktop4|xsane)
					# this is to deal with package subversion mismatch breaks: 1.0.4-6 1.0.4-5
					tempHolder1=$( check_package_status "$package1" )
					tempHolder2=$( check_package_status "$package2" )
					;;
				# special case to avoid 0.11.3-7+b1 / 0.11.3-7 type cases
				elinks|k3b)
					# this is to deal with package subversion mismatch breaks: 1.0.4-6 1.0.4-5
					tempHolder1=$( check_package_status "$package1"| cut -d '+' -f 1 | cut -d '~' -f 1 )
					tempHolder2=$( check_package_status "$package2"| cut -d '+' -f 1 | cut -d '~' -f 1 )
					;;
				*)
					# adding in filter for + numbers: 2.8.4+2.8.4-1, returns: 2.8.4
					tempHolder1=$( check_package_status "$package1" | cut -d '-' -f 1 | cut -d '+' -f 1 | cut -d '~' -f 1 )
					tempHolder2=$( check_package_status "$package2" | cut -d '-' -f 1 | cut -d '+' -f 1 | cut -d '~' -f 1 )
					;;
			esac

			# the package gets held automatically if it and its -data version numbers do not match
			if [ "$tempHolder1" != "$tempHolder2" ]
			then
				echo # needed to handle the -n of the dots....
 				echo "${M}${SPACER}Adding ${C}$package1${M} and ${C}$package2${M} to hold/install. Mismatched versions: ${C}$tempHolder1 $tempHolder2${N}"
				DPKG_HOLD_INSTALL="$DPKG_HOLD_INSTALL $package1 $package2"
				echo -n "${S}${SPACER}Continuing.."
			fi
		fi
	done
	echo 
	echo "${S}${SPACER}Check of package group version mismatch completed.${N}"
	eval $LOGUE
}
#broken_dependency_handler; exit

# NOTE: this only handles cases where version numbers are always the same
# args: $1 - which package group to test
advanced_broken_dependency_handler()
{
	eval $LOGUS
	local tempOne='' tempTwo='' package='' packages='' packageInstalled1=''
	local holdList='' packageVersionMismatch=''
	
	case $1 in
		amarok)
			packages="
amarok
amarok-common
amarok-engine-xine
amarok-engine-yauap
amarok-engines
"
			packageGroup='Amarok'
			;;
		gimp)
			packages="
gimp
gimp-data
gimp-libcurl
libgimp2.0
gimp-python	
"
			packageGroup='Gimp'
			;;
			
		hplip)
			packages="
hpijs
hpijs-ppds
hplip
hplip-data
"
			packageGroup='hplip'
			;;
		ooo)
			packages="
openoffice.org-base
openoffice.org-base-core
openoffice.org-common
openoffice.org-java-common
openoffice.org-core
openoffice.org-calc
openoffice.org-impress
openoffice.org-kde
openoffice.org-writer
python-uno
"
			packageGroup='OpenOffice.org'
			;;
		wesnoth)
			packages="
wesnoth
wesnoth-data
wesnoth-all
"
			packageGroup='Wesnoth'
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	echo $LINE
	echo "${SPACER}${S}Running ${C}$packageGroup${S} package version mismatch tests now...${N}"
	for package in $packages
	do
		# test for all cases hi/ii
		packageInstalled1=$( package_tester $package ii )
		if [ -n "$packageInstalled1" ]
		then
			# append to list to add to holds
			holdList="$holdList $package"
			# use the previous value, the first item in loop will be null
			tempTwo=$tempOne
			case $1 in
				# full version strings for picky package groups
				ooo)
					tempOne=$( check_package_status "$package" )
					;;
				# shorter version number strings for less picky package groups
				# I'm adding in the + test to handle those beta versions and some other odd
				# syntaxes: 2.8.4+2.8.4-1; 
				amarok|gimp|hplip|wesnoth)
					tempOne=$( check_package_status "$package" | cut -d '-' -f 1 | cut -d '+' -f 1 | cut -d '~' -f 1 )
					;;
			esac

			# ignore first iteration of loop
			if [ -n "$tempOne" -a -n "$tempTwo" ] && [ "$tempOne" != "$tempTwo" ]
			then
				packageVersionMismatch='true'
				echo "${SPACER}${M}The package ${C}$package${M} has a mismatched version number from ${C}$previousPackage${M}"
				echo "${SPACER}${M}Version numbers: ${C}$tempOne $tempTwo${N}"
			fi
			previousPackage=$package
		fi
	done
	
	if [ "$packageVersionMismatch" == 'true' ]
	then
		echo
		echo "${SPACER}${M}Package version mismatches were detected in ${C}$packageGroup"
		echo "${SPACER}${S}Adding ${C}$packageGroup${S} package group to hold/install list...${N}"
		DPKG_HOLD_INSTALL="$DPKG_HOLD_INSTALL $holdList"
	elif [ -n "$holdList" ]
	then
		echo "${SPACER}${M}No version mismatches detected in ${C}$packageGroup${M}. Continuing...${N}"
	elif [ -z "$holdList" ]
	then
		echo "${SPACER}${M}You do not appear to have ${C}$packageGroup${M} installed, or it is on hold. Continuing...${N}"
	fi
	eval $LOGUE
}

###---------------------------------------------------------------------
### apt update tools - update / keyrings / gpg / debian mirrors / non-free
###---------------------------------------------------------------------

# this can be run by either post kernel install or pre dist-upgrade
# but it should only run once in the install
# args: $1 - where from;
apt_update_handler()
{
	eval $LOGUS
	local exitStatus='' aehv='up-du-1' forceUpdate=''
	
	# the forceUpdate flag is for cases where the update must always be
	# performed to fix or resync system
	case $1 in
		kernel-tools)
			aehv='up-kern-tools'
			;;
		package-install)
			aehv='up-package-1'
			;;
		kernel)
			aehv='up-kernel-1'
			;;
		post-mirror)
			aehv='up-mirror-1'
			forceUpdate='true'
			;;
		pre-du)
			aehv='up-du-1'
			;;
		up-error-1)
			aehv='up-err-1'
			forceUpdate='true'
			;;
		distro-conversion)
			aehv='distro-conversion'
			forceUpdate='true'
			;;
		temp-repo)
			forceUpdate='true'
			;;
		update-apps)
			aehv='up-app'
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	
	if [ "$UPDATED" != 'true' -o "$forceUpdate" == 'true' ]
	then
		# give users the option to add non free sources to debian and sidux
		update_to_nonfree_sources
		
		# then start the update for real
		echo $LINE
		echo "${S}Starting ${C}$APT_TYPE update${S} now to bring your system into sync with apt...${N}"
		
		$APT_TYPE update $NO_PDIFFS 2>>$LOG_FILE 2>&1
		# get the success/fail exit code of update
		exitStatus=${PIPESTATUS[0]}
		apt_error_handling $aehv $exitStatus
		
		# this has to run after update of course
		install_keyrings
		# add any gpg stuff that might be needed
		update_gpg  # fixed it, now using debian-archive-keyring
		# set this to determine if update should be run again
		UPDATED='true' 
	fi
	eval $LOGUE
}

install_keyrings()
{
	eval $LOGUS
	local prefId='keyrings-sidux-1'
	local smPref=$( sm_pref_tester $prefId )
	
	# this handles case where sources have now been updated to sidux only
	if [ "$smPref" -eq 0 -a "$SIDUX_SOURCES" == 'true' ]
	then
		echo $LINE
		# this handles first load cases, and also errors on first du
		#update_gpg ## add gpg first to stop some errors. 
		package_installer 'sidux-keyrings' 'install-always' '--allow-unauthenticated'
		package_installer 'sidux-archive-keyring' 'install-always' '--allow-unauthenticated'
		# and no need to run this more than once, so we won't
		set_sticky_prefs $prefId
	fi
	eval $LOGUE
}

update_gpg()
{
	eval $LOGUS
	local prefId='keyrings-update-4'
	local smPref=$( sm_pref_tester $prefId )
	
	if [ "$smPref" -eq 0 ]
	then
		echo $LINE 
		echo "${S}Installing Debian archive keys for gpg...${N}"
		# debian keyrings &> /dev/null
		# this server is just useless, keeps jamming up
		# gpg --keyserver wwwkeys.eu.pgp.net --recv-keys 6070D3A1 &> /dev/null && apt-key add /root/.gnupg/pubring.gpg 1> /dev/null
		# sidux keyrings - old sidux: 71409CDF
		#gpg --keyserver wwwkeys.eu.pgp.net --recv-keys F80994F6 &> /dev/null && apt-key add /root/.gnupg/pubring.gpg 1> /dev/null
		package_installer 'debian-archive-keyring' 'install-always' '--allow-unauthenticated'

		echo "${S}Keys updated${N}"
		# or
		# gpg --keyserver wwwkeys.eu.pgp.net --recv-keys 3C9C56BDF781E713 
		# gpg --keyserver wwwkeys.eu.pgp.net --recv-keys F781E713 # last 8 only
		# apt-key add /root/.gnupg/pubring.gpg
		
		set_sticky_prefs $prefId
	fi
	eval $LOGUE
}
#update_gpg

## Debian mirror switching routines, -m option
change_debian_mirrors()
{
	eval $LOGPS
	local countryId='' CountryName='' mirror='' opt='' options='' found='' skip='' prefMess=''
	local debianMirrors='
	at:Austria
	au:Australia
	bg:Bulgaria 
	br:Brazil 
	ch:Switzerland 
	cl:Chile 
	cz:Czech-Republic 
	de:Germany 
	ee:Estonia 
	es:Spain 
	fi:Finland 
	fr:France 
	hk:Hong-Kong 
	hr:Croatia 
	hu:Hungary 
	ie:Ireland 
	is:Iceland 
	it:Italy 
	jp:Japan 
	kr:Korea 
	nl:Netherlands 
	no:Norway 
	nz:New-Zealand 
	pl:Poland 
	pt:Portugal 
	ro:Romania 
	ru:Russia 
	se:Sweden 
	si:Slovenia 
	sk:Slovakia 
	tr:Turkey 
	tw:Taiwan 
	uk:Great-Britain 
	us:United-States 
	no-change
	'
	local updateSuccess='' exitStatus='' sourcesLocation=$EAS
	local currentMirror=$( grep -o -m 1 'ftp[.a-z]*\.debian\.org' $EAS )
	# test for new format
	if [ -f "$EASDL" ]
	then
		currentMirror=$( grep -o -m 1 'ftp[.a-z]*\.debian\.org' $EASDL )
		sourcesLocation=$EASDL
	fi
	
	if [ "$1" == 'prefs' ]
	then
		prefMess='echo -e "\nYou will only see this Mirror Selection option the first time you run\nthe script. To reset your source mirrors in the future, use the ${C}-m${S} option.\n"'
	fi
	
	echo $MBAR
	echo "${M} APT SOURCES DEBIAN MIRROR SELECTION"
	echo $MLINE
	
	if [ "$currentMirror" != '' ]
	then
		echo "${S}You can select a different mirror to use in ${C}apt sources${S}."
		echo "Your current Debian mirror is ${C}$currentMirror${S}."
		echo
		echo "When you select one of these your ${C}$sourcesLocation${S}"
		echo "file will simply now use the mirrors located in that country."
		echo "You can start this script like this: ${C}$SCRIPT_NAME -m${S}"
		echo "to reset your prefered mirror any time you like."
		eval $prefMess
		echo "Select the number for ${C}no-change${S} if you want to return to main script."
		
		echo $LINE
		echo -e $SLE
		echo $LINE
		
		options=$debianMirrors
	
		select opt in $options
		do
			for mirror in $debianMirrors
			do
				if [ "$opt" == "$mirror" ]
				then
					found='true'
					if [ "$mirror" == 'no-change' ]
					then
						skip='true'
					else
						countryId=$( echo $mirror | cut -d ':' -f 1 )
						CountryName=$( echo $mirror | cut -d ':' -f 2 )
					fi
					break
				else
					found='false'
				fi
			done
			break
		done
		
		if [ "$found" == 'true' ]
		then
			echo $LINE
			if [ "$skip" != 'true' ]
			then
				for i in $EAS $EASDL $EASSL
				do
					if [ -e "$i" ]
					then
						sed -i "s%ftp[.a-z]*\.debian\.org%ftp\.$countryId\.debian\.org%g" $i && updateSuccess='true'
					fi
				done
				if [ "$updateSuccess" == 'true' ]
				then
					echo "${S}Your ${C}apt sources${S} will now use mirrors from: ${C}$CountryName${N}"
					apt_update_handler 'post-mirror'
				else
					echo "${E}An unknown error has occured.${N}"
				fi
			else
				echo "${S}Continuing on to main script without making any changes to ${C}$EAS${E}.${N}"
			fi
			eval $LOGPE
		else
			print_error opt
			eval $LOGPE
			change_debian_mirrors
		fi
	else
		echo $LINE
		echo "${E}I'm sorry, but you are not using a format for your Debian mirrors"
		echo "in ${C}$EAS${E} that this script can recognize. You will"
		echo "have to update your ${C}$EAS${E} sources manually.${N}"
		log_function_data "Unrecognized format/syntax for Debian apt mirror sources"
		eval $LOGPE
	fi
}
## DEBUGGER
#script_debugger  'change_debian_mirrors prefs'

update_to_nonfree_sources()
{
	eval $LOGUS
	local prefId='update-nonfree-1'
	local smPref=$( sm_pref_tester $prefId )
	local response='' i='' counter=''
	local isFree=0
	
	# loop through possible files to update
	for i in $EAS $EASDL $EASSL
	do
		if [ -f "$i" ]
		then
			counter=$( egrep -c 'deb.*debian\.org.*(contrib|non-free)' $i )
			isFree=$(( $counter + $isFree ))
		fi
	done
	
	#echo counter: $counter
	
	if [ "$isFree" -eq 0 -a "$smPref" -eq 0 ] 
	then
		echo $LINE
		echo "${S}It does not appear that you have the non-free/contrib options set up in your ${C}apt sources${S}"
		echo "non-free / contrib let you install things like flash player, msttcorefonts, firmware, etc."
		echo
		echo "If you answer ${C}y${S} a copy of your ${C}apt sources${S} will be made"
		echo
		echo $LINE
		echo -e "${Q}Do you want to update your ${C}apt sources${Q} to add nonfree / contrib now?$YNE"
		echo $LINE
		read response

		case $response in 
			y)	
				for i in $EAS $EASDL $EASSL
				do
					if [ -f "$i" ]
					then
						# this is overkill, dumping the backup for now
						# cp $i $i-bu-$(date +%y-%m-%d)
						echo "${S}Updating your ${C}$i${S} now...${N}"
						# these are both updated to handle sidux mirrors as well
						sed -i -r 's%(#?deb.*(debian\.org|sidux\.com|sidux\.net|debian\.tu-bs\.de|mirrorservice\.org|heanet\.ie|spline\.de|sunsite\.utk\.edu|leg\.uct\.ac\.za|mirror\.aarnet\.edu\.au).*\s(main|fix\.main))(\s*)(non-free.*|contrib.*)*%\1 contrib non-free%' $i
						# the second test requires the results of the first to work
						# note that spaces are required for this to work more reliably for most patterns
						sed -i -r 's%(#?deb.*(sidux\.com|sidux\.net|debian\.tu-bs\.de|mirrorservice\.org|heanet\.ie|spline\.de|sunsite\.utk\.edu|ftp-mirror\.internap\.com|ftp\.tw.debian\.org|leg\.uct\.ac\.za|mirror\.aarnet\.edu\.au).*\snon-free)%\1 firmware fix.contrib fix.non-free %' $i
					fi
				done
				echo "${C}apt sources${S} have been updated, please check them to make sure they are right.${N}"
				set_sticky_prefs $prefId
				print_hec
				eval $LOGUE
				;;
			n)	echo "${S}Ok, continuing without updating them, you'll have to do that manually"
				echo "if you change your mind later and decide you want to use non-free or contrib.${N}"
				echo
				set_sticky_prefs $prefId
				eval $LOGUE
				;;
			*)	print_error yn
				eval $LOGUE
				update_to_nonfree_sources
				;;
		esac
		echo $LINE
		echo 
	fi
}
## DEBUGGER
#script_debugger  update_to_nonfree_sources
#update_to_nonfree_sources

# will test for and create either new sub apt source list or add to sources.list as needed
# args: $1 - grepSearch; $2 - sourceFile; $3 - sourcesData; $4 - searchIdentifier
create_apt_source_item()
{
	eval $LOGUS
	local grepSearch=$1 sourceFile=$2 sourcesData=$3 sourcePresent=''
	local searchIdentifier=$4
	
	sourcePresent=$( egrep -ils "^[[:space:]]*deb[[:space:]].*$grepSearch" $EAS $EAS.d/*.list )
	if [ -z "$sourcePresent" ]
	then
		# handle cases where users prefer single sources.list
		if [ -z "$( ls $EAS.d/*.list 2>/dev/null )" -a -f $EAS ]
		then
			sourceFile=$EAS
		fi
		
		echo $LINE
		echo "${S}Adding ${C}$searchIdentifier${S} to sourcefile: ${C}$sourceFile${N}"
		if [ ! -f "$sourceFile" ]
		then
			echo "# $searchIdentifier sources added by $SCRIPT_NAME" > $sourceFile
			echo -e "$sourcesData" >> $sourceFile
			echo >> $sourceFile
		else
			echo >> $sourceFile
			echo "# $searchIdentifier sources added by $SCRIPT_NAME" >> $sourceFile
			echo -e "$sourcesData" >> $sourceFile
			echo >> $sourceFile
		fi
		echo "${S}Source file: ${C}$sourceFile${S} updated.${N}"
		eval $LOGUE
		return 0
	else
		eval $LOGUE
		return 1
	fi
}

# args $1 - repo/search string; $2 - add/remove
check_add_remove_sources()
{
	eval $LOGUS
	local grepSearch=$1
	local sourceFile="$EAS.d/$1.khsdgkd.list"
	local sourceData=''
	local sourcePresent=$( egrep -ils "^[[:space:]]*deb[[:space:]].*$grepSearch" $EAS $EAS.d/*.list )
	
	case $1 in
		sidux)
			sourceData='deb http://sidux.com/debian/ sid main'
			;;
		cathbard)
			sourceData=''
			;;
	esac
	
	case "$2" in
		add)
			if [ -z "$sourcePresent" ]
			then
				echo "${S}Updating apt to use temporary ${C}$1${S} sources....${N}"
				echo "$sourceData" > $sourceFile
				# then update apt
				apt_update_handler 'temp-repo'
				
			fi
			;;
		remove)
			# then remove, update apt to cleanup
			echo "${S}Removing temporary ${C}$1${S} sources...${N}"
			rm -f $sourceFile
			apt_update_handler 'temp-repo'
			;;
	esac
	
	eval $LOGUE
}

###---------------------------------------------------------------------
### kernel mirror selector
###---------------------------------------------------------------------

# while not needed now, this is a useful tool for when a mirror site fails, 
# screws up, or whatever else might happen, and has.
force_kernel_mirror_change()
{
	eval $LOGUS
	# core-eu-4:http://ftp.spline.de/pub/sidux/debian/ 
	local prefId='smxi-kernel-borked-1'
	local smPref=$( sm_pref_tester $prefId )
	#local isBorked=$( echo $( get_set_mirror 'get' 'mirrors' ) | egrep '(http://ftp.spline.de/pub/sidux/debian/)' )
	local borkedMirror='http://ftp.spline.de/pub/sidux/debian/'
	# this method is tighter, and will let me also just replace the stuff if required 
	# at some other point. This gets all relevant files to update for sed
	local isBorked=$( grep -ls "$borkedMirror" $EAS $EAS.d/*.list )
	local reply=''
	
	if [ -n "$isBorked" -a "$smPref" -eq 0 ]
	then
		echo $MLINE
		echo "${M}SMXI sidux-apt Kernel / Sources Mirror Update"
		echo $MLINE
		echo "${S}Your current sidux-apt/kernel mirror ${C}$borkedMirror${S}"
		echo "is not functioning. You will need to update your sidux mirrors to use another"
		echo "sidux (kernel) mirror. Please continue in order to change that bad mirror to a good one."
		if [ -n "$( grep 'ftp.spline.de' <<< $borkedMirror )" ]
		then
			echo "${M}NOTE: http://ftp.spline.de is a ${C}CORE${M} mirror, so make sure to pick another ${C}core${M} when you replace it."
		fi
		
		echo
		echo -e "${Q}Would you like to reset your mirror now?$YNE"
		echo $LINE
		read response

		case $response in
			y|Y|yes|YES|Yes)
				echo "${S}Ok, you can now select a new kernel mirror...${N}"
				#set_sticky_prefs $prefId
				CHANGE_KERNEL_MIRROR='true'
				;;
			*)
				echo "${S}Ok, but remember, to change your mirror, just start ${C}$SCRIPT_NAME${S} with ${C}-M${S} option.${N}"
				#set_sticky_prefs $prefId
				;;
		esac
	fi
	eval $LOGUE
}

# update kernel mirrors, -M option
change_kernel_mirrors()
{
	eval $LOGPS
	if [ -n "$SIDUX_SOURCES" ]
	then
		local countryId='' mirrorUrl='' mirror='' opt='' options='' found='' skip='' prefMess=''
		#local currentMirror=$( sm_pref_tester $prefId 'equal' )
		local updateSuccess='' exitStatus='' noChange=' continue' currentMirrorText=''
		local currentMirror="$( get_sidux_mirrors 'all' )"
		local plural1='' plural2='is'
		local noMirrorString='No mirrors were detected that fit the search pattern.'
		local siduxMirrors="$( list_sidux_mirrors ) $noChange"
		local cont=$( wc -w <<< $siduxMirrors )
		local mirrorCount=$(( $cont - 1 ))
	
		currentMirrorText="$currentMirror"

		# we'll set some singular/plural stuff, and some logic using count
		local countMirrors=$( wc -w <<< $currentMirror )
		
		if [ "$countMirrors" -gt 1 ]
		then
			plural1='s' 
			plural2='are'
		fi
		
		if [ "$1" == 'prefs' ]
		then
			prefMess='echo -e "\n${M}You will only see this Kernel Mirror Selection option the first time you run\nthe script. To reset your kernel mirrors in the future, use the ${C}-M${M} option.${S}"'
		fi
		
		echo $MBAR
		echo "${M} SMXI KERNEL MIRROR SELECTION"
		echo $MLINE
		
		echo "${S}Welcome to the sidux apt/kernel mirror selector. Please take a moment to read this"
		echo "before proceeding. Your current sidux-apt/kernel mirror$plural1 $plural2:"
		echo "${SPACER}${C}$currentMirrorText${S}"
		echo
		echo "There are two types of mirrors: ${C}core${S} (required), and ${C}alternate${S} (optional)."
		echo "The following are the ${C}core${S} sidux mirrors: ${C}sidux.com/net debian.tu-bs.de ftp.spline.de"
		echo "${S}You will always use one of these. Picking a core will modify the core mirror always."
		echo
		echo "Alternate mirrors are localized, and often provide much faster downloads, but do not sync"
		echo "as frequently as the core ones. If you pick an alternate, it will be prepended"
		echo "to your current core mirror, or, if already with alternate, will modify the alternate."
		echo "${M}Please install at least one alternate mirror, it will really help the sidux server load.${S}"
		echo
		echo "${S}When you select your mirror(s), sidux will use it/them as source for latest"
		echo "kernels and sidux hot-fixes. You can start this script like this: ${C}$SCRIPT_NAME -M${S}"
		echo "to reset your prefered mirror(s) any time you like."
		eval $prefMess
		echo $LINE
		echo "${C}1-$mirrorCount - Mirror List${S} Select which core/alternate mirror to add or update."
		if [ -n "$currentMirror" ]
		then
			echo
			echo "${C}$cont - continue${S} If you want to leave your sidux mirror$plural1 alone, or if you are done."
		fi
		
		echo $LINE
		echo -e $SLE
		echo $LINE
		
		options=$siduxMirrors
	
		select opt in $options
		do
			for mirror in $siduxMirrors
			do
				if [ "$opt" == "$mirror" ]
				then
					found='true'
					if [ "$mirror" == 'continue' ]
					then
						skip='true'
					else
						countryId=$( echo $mirror | cut -d ':' -f 1 )
						mirrorUrl=$( echo $mirror | cut -d ':' -f 2-3 ) # handles : in urls
					fi
					break
				else
					found='false'
				fi
			done
			break
		done
		
		if [ "$found" == 'true' ]
		then
			echo $LINE
			if [ "$skip" != 'true' ]
			then
				if [ "$currentMirror" != "$noMirrorString" ]
				then
					set_sidux_mirror "$mirrorUrl"
					change_kernel_mirrors
				else
					echo "${M}$noMirrorString${N}"
				fi
			else
					echo "${S}Continuing on to main script. Remember, you can change your ${C}sidux apt mirrors${S}"
					echo "anytime by starting the script like this: ${C}$SCRIPT_NAME -M${N}"
					apt_update_handler 'post-mirror'
			fi
			eval $LOGPE
		else
			print_error opt
			eval $LOGPE
			change_kernel_mirrors
		fi
	else
		echo $MLINE
		echo "${M}This feature is only available for systems using ${C}sidux${M} sources.${N}"
		print_hec
		eval $LOGPE
	fi
}
## DEBUGGER
#script_debugger 'change_kernel_mirrors prefs'

# args: $1 - all/get-them/non-core
get_sidux_mirrors()
{
	eval $LOGUS
	local siduxMirrors="$( list_sidux_mirrors )"
	local badSiduxMirrors="$( list_bad_sidux_mirrors )"
	local noMirrorString='No mirrors were detected that fit the search pattern.'
	local mirrorTemp='' mirror='' mirrorsFound='' mirrorFiles='' singleTest=''
	local currentMirrors=''
	
	# needed to avoid infinite loop from function calling itself
	if [ "$1" != 'get-them' ]
	then
		currentMirrors="$( get_sidux_mirrors 'get-them' )"
	fi

	local countMirrors=$( wc -w <<< $currentMirrors )
	
	for mirror in $siduxMirrors $badSiduxMirrors
	do
		mirrorTemp=$( echo $mirror | cut -d ':' -f 2-4 )
		# it's very important here to search only for start deb, no #
		# echo mirrorTemp: $mirrorTemp
		mirrorFiles="$( egrep -ls "^[[:space:]]*(deb|deb-src)[[:space:]]*$mirrorTemp" $EAS $EAS.d/*.list )"

		if [ -n "$mirrorFiles" ]
		then
			# case one we return a list of all found mirrors
			case $1 in
				all|get-them)
					mirrorsFound="$mirrorsFound $mirrorTemp"
					;;
				# here we return only current non sidux mirror (hopefully anyway)
				non-core)
					singleTest=$( egrep -v '(http://sidux\.(com|net)|debian\.tu-bs\.de|ftp\.spline\.de)/' <<< $mirrorTemp )
					# echo singleTest: $singleTest
					# if a core mirror is not found, or if there is only one sidux mirror
					if [ -n "$singleTest" ] || [ "$countMirrors" -eq 1 ]
					then
						mirrorsFound="$mirrorTemp"
						# echo mirrorsFound: $mirrorsFound
						break
					fi
					;;
			esac
			mirrorTemp=''
		fi
	done

	# return the output
	if [ -n "$mirrorsFound" ]
	then
		echo "$mirrorsFound"
	else
		echo $noMirrorString
	fi
	eval $LOGUE
}

# args: $1 - which mirror to update
set_sidux_mirror()
{
	eval $LOGUS
	local siduxSources='' siduxSource='' mirrorTemp='' nonCoreSiduxRepo='' isCoreSiduxRepo=''
	local entryExists='' siduxSpecs='' isSiduxMulti='' siduxTempHolder='' siduxTempRepo=''
	local updateIt=''
	local currentMirrors="$( get_sidux_mirrors 'get-them' )"
	local countMirrors=$( wc -w <<< $currentMirrors )
	
	# get filtered, non sidux mirror repo
	nonCoreSiduxRepo=$( get_sidux_mirrors 'non-core' )
	
	# we only want to overwrite sidux stuff it's not a dual apt sources...
	isSiduxMulti=$(  egrep -s "^[[:space:]]*(deb|deb-src)\s*.*(http://sidux\.(com|net)|debian\.tu-bs\.de|ftp\.spline\.de)" $EAS $EAS.d/*.list | cut -d ':' -f 2-6 )
	isCoreSiduxRepo="$( echo "$1" | egrep '(http://sidux\.(com|net)|debian\.tu-bs\.de|ftp\.spline\.de)' )"
	
	# handle multiple entries in sources
	# make sure the current mirror only is selected
	# this step is critical, it is required to correctly set entryExists
	# for case of multiple mirror entries AND correctly setting mirror
	if [ -n "$isCoreSiduxRepo" ]
	then
		# this handles a really weird case where sidux.list is commented out
		# because we're checking multiple files, we need to slice out the file : 
		# separator before awk
		entryExists=$( grep -s '^[^#]' $EAS $EAS.d/*.list | cut -d ':' -f 2-6 | awk '/^(deb)[ ]*(((http|ftp):\/\/)(sidux\.(com|net)|debian\.tu-bs\.de|ftp\.spline\.de))/{print $2}' )
	else
		entryExists=$( egrep -os -m1 "^[[:space:]]*(deb|deb-src)[[:space:]]*$nonCoreSiduxRepo" $EAS $EAS.d/*.list | grep -o "$nonCoreSiduxRepo" )
	fi
	log_function_data "mirror to install: $1"
	log_function_data "nonCoreSiduxRepo: $nonCoreSiduxRepo"
	log_function_data "entryExists: $entryExists"
	log_function_data "writing to: $sourceFile"
	log_function_data "countMirrors: $countMirrors"
	log_function_data "isSiduxMulti: $isSiduxMulti"
	log_function_data "isCoreSiduxRepo: $isCoreSiduxRepo"
	
	# note: we don't need any special regex because we already know
	# we're in the right place, with a matching syntax, so things should be good
	if [ -n "$entryExists" ] 
	then
		if [ "$countMirrors" -gt 1 -a -n "$isSiduxMulti" ] || [ "$countMirrors" -eq 1 -a -n "$isCoreSiduxRepo" ]
		then
			siduxSources=$( grep -ls "$entryExists" $EAS $EAS.d/*.list )
			echo "${SPACER}${S}Updating ${C}$siduxSources${S} now...${N}"
			sed -i -r "s%(#?[[:space:]]*(deb|deb-src)[[:space:]]*)$entryExists%\1$1%" $siduxSources
			echo
			echo "${SPACER}${S}Your system will now use sidux-apt/kernel mirror(s):"
			echo "${SPACER}${C}$( get_sidux_mirrors 'all' )${N}"
			updateIt='true'
		# only when not a core mirror and sources are not yet upgraded to multi
		elif [ "$countMirrors" -eq 1 -a -z "$isCoreSiduxRepo" ]
		then
			#note: we only want to prepend to sources NOT commented out
			siduxSources=$( grep -ls "^[[:space:]]*deb.*$entryExists" $EAS $EAS.d/*.list )
			# we need to loop it here because of possible multi source files
			for siduxSource in $siduxSources
			do
				siduxTempHolder=$( egrep -m1 "(deb|deb-src)\s*.*(http://sidux\.(com|net)|debian\.tu-bs\.de|ftp\.spline\.de)" $siduxSource )
				# for presentation, just use the repo name
				siduxTempRepo=$( cut -d ' ' -f 2 <<< $siduxTempHolder )
				# we need to replace whitespace for sed here
				siduxTempMainHolder=$( echo "$siduxTempHolder" | sed -r 's%(\s|\t)%\\s%g' )
				# we want the same stuff after the mirror as the primary has
				siduxSpecs=$( echo $siduxTempHolder | sed -r 's%.*((sid|unstable).*)%\1%' )
				
				log_function_data "siduxTempHolder: $siduxTempHolder"
				log_function_data "siduxTempMainHolder: $siduxTempMainHolder"
				log_function_data "siduxSpecs: $siduxSpecs"

				echo "${S}Prepending the mirror:${C} $1"
				echo "${S}to current sidux repo: ${C}$siduxTempRepo${N}"
				sed -i "s%$siduxTempMainHolder%deb $1 $siduxSpecs\n$siduxTempHolder%" $siduxSource
			done
			echo "${SPACER}${S}Your system will now use sidux-apt/kernel mirror(s):"
			echo "${SPACER}${C}$( get_sidux_mirrors 'all' )${N}"
			updateIt='true'
		# this case should never happen any more with above modifications
		elif [ "$countMirrors" -gt 1 -a -n "$isSiduxMulti" -a -n "$isCoreSiduxRepo" ]
		then
			echo "${E}You cannot overwrite your primary ${C}sidux.com${E} apt source:"
			echo "${C}$isCoreSiduxRepo"
			echo "${E}only your alternate mirror.${N}"
		# and not this one either, but good to test for bugs
		else
			echo "${E}Unhandled case in $FUNCNAME...${N}"
		fi
	# either multi update or single core update
	# only do this at the true end
	elif [ -z "$entryExists" ]
	then
		echo "${E}Unable to properly match your ${C}sidux.com${E} repo, sorry.${N}"
		print_hec
		log_function_data "Unable to match sidux repo"
		eval $LOGUE
		return 1
	fi
	
	if [ "$updateIt" == 'true' ]
	then
		print_hec
		eval $LOGUE
		return 0
	fi
}

# bad mirrors for updates:
list_bad_sidux_mirrors()
{
	eval $LOGUS
	# these are currently either dead or defective: 
	local badMirrors='
core-eu-4:http://ftp.spline.de/pub/sidux/debian/
usa-2:http://lug01.eecs.wsu.edu/sidux/
usa-1:ftp://ftp.sunsite.utk.edu/pub/linux/Sidux/
new-zealand-1:ftp://debian.co.nz/Sidux/debian/
'
	echo $badMirrors
	eval $LOGUE
}

# I want to keep this out of globals, so we'll just echo it to functions
list_sidux_mirrors()
{
	eval $LOGUS
	local siduxMirrors="
core-eu-1:http://debian.tu-bs.de/project/sidux/debian/
core-eu-2:ftp://debian.tu-bs.de/project/sidux/debian/
core-eu-3:ftp://ftp.spline.de/pub/sidux/debian/
core-eu-4:http://sidux.com/debian/
core-eu-5:http://sidux.net/debian/
alt-africa-1:http://ftp.leg.uct.ac.za/pub/linux/sidux/debian/
alt-asia-1:http://ftp.tw.debian.org/pub/Sidux/debian/
alt-asia-2:ftp://ftp.tw.debian.org/pub/Sidux/debian/
alt-australia-1:http://mirror.aarnet.edu.au/pub/sidux/debian/
alt-australia-2:ftp://mirror.aarnet.edu.au/pub/sidux/debian/
alt-eu-1:http://www.mirrorservice.org/sites/sidux.com/sidux/debian/
alt-eu-2:ftp://ftp.mirrorservice.org/sites/sidux.com/sidux/debian/
alt-eu-3:http://ftp.heanet.ie/pub/sidux/debian/
alt-eu-4:ftp://ftp.heanet.ie/pub/sidux/debian/
alt-usa-1:http://ftp-mirror.internap.com/pub/sidux/debian/
alt-usa-2:ftp://ftp-mirror.internap.com/pub/sidux/debian/
alt-usa-3:ftp://ftp.sunsite.utk.edu/pub/linux/Sidux/debian/
"
	
	echo "$siduxMirrors"
	eval $LOGUE
}

###---------------------------------------------------------------------
### Kernel handling stuff...
###---------------------------------------------------------------------

# check apt for latest kernel version
# args: $1 - debian/debian-486/sidux - optional, to get current sid kernel version if needed
get_current_apt_kernel()
{
	eval $LOGUS
	local tempKernels='' kernelThird=0
	local kernel1='' kernel2='' kernel1Greater='' kernelStringExtra='' 
	local defaultKernel=$1 distro='' currentKernel='' kernelPackageExists=''
	# needed for alt platforms, no easy way to handle say move from 486 to 686, so 
	# we'll just respect the user initial preference and make them change manually if desired
	local platform=$( egrep -o '\-(486|686|686-bigmem|xen-686)$' <<< $CURRENT_KERNEL | cut -d '-' -f 2-4 )
	
	if [ "$defaultKernel" != 'no-kernel' ]
	then
		if [ "$BITS" == '64' ]
		then
			platform='amd64'
		# for odd 32 bit kernel names, yet known
		elif [ "$BITS" == '32' -a -z "$platform" ]
		then
			platform='686'
		fi
		
		case $defaultKernel in
			debian)
				distro='Debian'
				;;
			debian-486)
				distro='Debian-486'
				platform='486'
				;;
			debian-686)
				distro='Debian-686'
				platform='686'
				;;
			sidux)
				kernelStringExtra='-sidux'
				distro='sidux'
				if [ "$BITS" == '32' ]
				then
					platform='686'
				fi
				;;
			mepis)
				kernelStringExtra='-mepis'
				distro='Mepis'
				platform='smp'
				;;
		esac
		log_function_data "Platform: $platform"
		
		# little trick here to present just debian kernels if not distro
		if [ "$SIDUX_SOURCES" != 'true' -a "$MEPIS_SOURCES" != 'true' -a "$defaultKernel" != 'debian-486'  -a "$defaultKernel" != 'debian-686' ]
		then
			kernelStringExtra=''
			distro='Debian'
			defaultKernel='debian'
		fi
		
		# first we run the update, if needed
		apt_update_handler 'kernel'
		# then we'll slice out the latest apt kernel
		echo
		echo "${S}Calculating latest ${C}$distro${S} kernel version...${N}"
		# need to make sure it's not a bigmem kernel from debian too, ends in  $platform
		# note: testing for kernel metapackages here, so only systems with metapackage kernels 
		# can be tested with this method. The last slice handles a case with metapackages
		
		LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= tempKernels=$( apt-cache show linux-image-2.6$kernelStringExtra-$platform | grep -i '^Depends: ' | cut -d ' ' -f 2 | grep "$platform$" | cut -d '-' -f 3-7 | grep -v "2.6-$platform" )
	
		for kernel1 in $tempKernels
		do
			dpkg --compare-versions "$kernel1" ge "$kernel2"
			kernel1Greater=$?
			#now, if 1 is greater than 2, use it, otherwise use 2
			if [ "$kernel1Greater" -eq 0 ]
			then
				kernel2=$kernel1
			fi
		done
		
		currentKernel=$kernel2
		
		# test that the kernel actually exists, metapackages can be wrong, out of date
		kernelPackageExists=$( check_package_status "linux-image-$currentKernel" )
		if [ -z "$kernelPackageExists" ]
		then
			log_function_data "Error: the kernel package: linux-image-$currentKernel has no installation candidate.\Setting kernel version to null for this kernel type."
			currentKernel=''
		fi

		case "$defaultKernel" in
			debian|debian-486|debian-686)
				CURRENT_DEBIAN_KERNEL=$currentKernel
				log_function_data "CURRENT_DEBIAN_KERNEL: $CURRENT_DEBIAN_KERNEL"
				;;
			sidux)
				CURRENT_SIDUX_KERNEL=$currentKernel
				log_function_data "CURRENT_SIDUX_KERNEL: $CURRENT_SIDUX_KERNEL"
				;;
		esac
		
		# only set this for cases where it's user defaults being set, not for alt kernels
		if [ "$defaultKernel" == "$DEFAULT_KERNEL" ]
		then
			CURRENT_APT_KERNEL=$currentKernel
			log_function_data "CURRENT_APT_KERNEL: $CURRENT_APT_KERNEL"
			kernelThird=$( echo $CURRENT_APT_KERNEL | cut -d '-' -f 1 | egrep -o '^2\.6\.[0-9]{1,2}' | cut -d '.' -f 3 )
			# now just slice out the major version, and add 1 so it's always 1 > than current
			KERNEL_FORCE_DU=$(( $kernelThird + 1 ))
			log_function_data "KERNEL_FORCE_DU: $KERNEL_FORCE_DU"
			# global will handle alert to metapackage users to reboot post du
			# global will handle alert to metapackage users to reboot post du
			CURRENT_APT_KERNEL_GRUB=$( grep -is -o -m 1 "$CURRENT_APT_KERNEL" $GRUB_PATH )
			log_function_data "CURRENT_APT_KERNEL_GRUB: $CURRENT_APT_KERNEL_GRUB"
		fi
	else
		CURRENT_APT_KERNEL='no-apt-kernel-available'
	fi
	eval $LOGUE
}

###---------------------------------------------------------------------
### Test required apps
###---------------------------------------------------------------------

# args: $1 can trigger 'post' test, for running this after initial tests
test_required_startup_apps()
{
	eval $LOGUS
	local p='' r='' missing='' installApps='' response='' updateError='' appPath='' appExists=''
	local requiredApps="awk bzip2 gawk logrotate make perl sed tar unzip wget"
	# dctr is for grep-aptavail
	local dpkgCheck='dctrl-tools initramfs-tools' 
	
	for r in $dpkgCheck
	do
		appExists=$( package_tester $r ) # see if it's in dpkg
		if [ -z "$appExists" ]
		then
			installApps="$installApps $r"
			missing='true'
		fi
	done
	
	for p in $requiredApps
	do
		appPath=$( which $p )
		if [ ! -e "$appPath" -o -z "$appPath" ]
		then
			installApps="$installApps $p"
			missing='true'
		fi
	done
	
	if [ "$missing" == 'true' ]
	then
		eval $LOGUE
		install_missing_apps "$installApps" 'required'
	else
		log_function_data "No missing required script apps"
		eval $LOGUE
	fi
}
## DEBUGGER
#script_debugger test_required_startup_apps

# check if app is present in system, then if missing, ask if they want it installed
# for required, will exit script, for feature will just return false, 1
# args: $1 - apps to install; $2 - required/feature
install_missing_apps()
{
	eval $LOGUS
	local opt='' option='' repeat='' returnValue='' noOpt='' 
	local message1='' message2='' plural1=''
	if [ "$( wc -w <<< $1 )" -gt 1 ]
	then
		plural1='s'
	fi
	
	case $2 in
		required)
			noOpt='no-quit-now'
			message1="${M}You must install the following application$plural1 to run ${C}$SCRIPT_NAME${M}:"
			message2="Quit ${C}$SCRIPT_NAME${S} now, do not install required script applications."
			;;
		feature)
			noOpt='no-skip-feature'
			message1="${M}You must install the following package$plural1 to use this feature of ${C}$SCRIPT_NAME${M}:"
			message2="Skip this feature of ${C}$SCRIPT_NAME${S}, do not install missing packages."
			;;
	esac
	
	echo $MLINE
	echo "$message1"
	echo $MLINE
	echo "$SPACER${C}$1"
	echo $LINE
	
	echo "${C}1 - yes-install${S} - Install the missing apps then continue with script."
	echo "${C}2 - $noOpt${S} - $message2"
	echo $LINE
	echo -e $SLE
	echo $LINE
	options="yes-install $noOpt"
	select opt in $options
	do
		log_function_data "opt selected: $opt"
		case $opt in
			yes-install)
				apt_update_handler 'update-apps'
				package_installer "$1" 'install-missing'
				returnValue=$?
				;;
			no-skip-feature)
				returnValue=1
				;;
			no-quit-now)
				returnValue=1
				print_quit
				;;
			*)
				print_error opt
				repeat='true'
				;;
		esac
		break
	done
	
	log_function_data "Return Value: $returnValue"
	eval $LOGUE
	
	if [ "$repeat" == 'true' ]
	then
		install_missing_apps "$1" "$2"
	else
		if [ "$returnValue" -gt 0 ]
		then
			echo $MLINE
			echo "${M}Cannot run the requested feature, skipping it and continuing with script.${N}"
			print_hec
		else
			echo $LINE
			echo "${S}Finished installing missing applications, continuing with script.${N}"
		fi
		return $returnValue
	fi
}

###**EOF**###