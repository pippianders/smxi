#!/bin/bash
########################################################################
####  Script Name: smxi-stub
####  stub installer for smxi scripts
####  Only supports true Debian based distros.
####  version: 2.9
####  Date: 20 August 2009
########################################################################
####  Copyright (C) Harald Hope, sidux team members 2007-2009
####
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
########################################################################

# Please do not change the logic here, it makes it too hard to read linearly:
# [ ! -f somefile ] && do something is far easier to read than [ -f somefile ] || do something
# tempfile primary cleanup is now handled by called scripts, so no need to complicate this
# simple stub with the cleanup stuff. Now it just cleans up after itself each time.

# To get the full power and user friendliness for this stub installer
# rename it to: smxi
# place it in /usr/sbin, that is, as /usr/sbin/smxi, make it executable: chmod +x /usr/sbin/smxi
# add the following symbolic links in /usr/sbin pointing to /usr/sbin/smxi:
# ln -s /usr/sbin/smxi /usr/sbin/inxi
# ln -s /usr/sbin/smxi /usr/sbin/sgfxi
# ln -s /usr/sbin/smxi /usr/sbin/svmi
# because of how default $PATH works, /usr/sbin will always be checked first for the
# scripts, and if they are missing, this stub will download and execute them, otherwise
# the request will simply be passed along to /usr/local/bin location of actual scripts

# this will handle stub for any other script also
CALLER="$( basename $0 )"
PREFIX='/usr/local/bin/'
DOWNLOAD_URL=''
DOWNLOAD_URL_INXI='http://inxi.googlecode.com/svn/trunk/'
DOWNLOAD_URL_SGFXI='http://smxi.org/sg/'
DOWNLOAD_URL_SMXI='http://smxi.org/sm/'
DOWNLOAD_URL_SVMI='http://smxi.org/sv/'
# Do  not create temp file here. It will create masses of temp files over time.
FILE_TEMP_NAME='' # will handle failed downloads
# this is the tester for ##**EOF**## endings present in scripts, change this
# if you want to extend this stub to other scripts, smxi/svmi/inxi/sgfxi all use this
SCRIPT_EOF='##\*\*EOF\*\*##'

# args: $1 - error number; $2 - extra data
error_handler()
{
	local message=''
	case $1 in
		1)	message='You must be root to run this script!'
			;;
		2)	message='Failed to download script properly. The file is empty!'
			;;
		3)	message="$PREFIX$SCRIPT not executable!"
			;;
		4)	message="Script download exited with errors.\nThe following download url failed with wget error: $2/n$DOWNLOAD_URL$SCRIPT"
			;;
		5)	message='Unknown script requested.'
			;;
		6)	message='Failed to download script. The downloaded file does not exist!'
			;;
		7)	message="$PREFIX$SCRIPT exec command failed with error number: $2\nDeleting problem file. Please try again."
			# this will handle, I think, partial, incomplete, downloads, that are not null
			if [ -f "$PREFIX$SCRIPT" ];then
				rm -f "$PREFIX$SCRIPT"
			fi
			;;
		8)	message='Failed to download script properly. The file is corrupted!'
			;;
		*)	message='Unknown error, exiting now.'
			;;
	esac
	echo -e "Error No: $1 - $message"
	# cleanup the temp file if error
	if [ -f "$FILE_TEMP_NAME" ];then
		rm -f "$FILE_TEMP_NAME"
	fi
	exit $1
}

# set the SCRIPT/DOWNLOAD_URL/SCRIPT_EOFvalues
case $CALLER in
	sgfxi)
		SCRIPT="$CALLER"
		DOWNLOAD_URL=$DOWNLOAD_URL_SGFXI
		;;
	smxi)
		SCRIPT="$CALLER"
		DOWNLOAD_URL=$DOWNLOAD_URL_SMXI
		;;
	svmi)
		SCRIPT="$CALLER"
		DOWNLOAD_URL=$DOWNLOAD_URL_SVMI
		;;
	inxi)
		SCRIPT="$CALLER"
		DOWNLOAD_URL=$DOWNLOAD_URL_INXI
		;;
	*)
		error_handler 5
		;;
esac

# this handles that annoying null file thing. Because -s is ambiguous, I added a -f check
# as well. Delete all existing null files. This test must be first. This won't handle incomplete
# downloads, but it will help a bit. This also avoids a file does not exist error
if [ -f "$PREFIX$SCRIPT" -a ! -s "$PREFIX$SCRIPT" ];then
	rm -f "$PREFIX$SCRIPT"
fi

# now that null files are removed, we can safely use the -x test. Note: be very careful
# relying on -x as a test, null files can have the exec bit set... that's bash for you...
# if $SCRIPT exists, it will handle the root tests. Root tests cannot
# be run first because they kill the -h help function
if [ -x "$PREFIX$SCRIPT" ];then
	# I'm just going to put a test for basically everything that can go wrong
	# If we're lucky, this will handle partial or incomplete downloads that are not null
	exec "$PREFIX$SCRIPT" "$@" || error_handler 7 "$?"
else
	# only in case of requirement to download script do root test, and just exit
	# if not root, anything else is counterintuitive I think for users.
	if [ "$( id -u )" -ne 0 ];then
		error_handler 1
	fi

	# if and only if file does not exist and user is root do we make the temp file
	FILE_TEMP_NAME="$( mktemp -p $PREFIX $CALLER.XXXXXXXXXX )"
	# now we'll use a simple -f test since the null case is already handled. We are not
	# downloading to overwrite existing file, but to temp file, which we then test for null
	# -O is risky here too because failed downloads create a null file automatically.
	if [ ! -f "$PREFIX$SCRIPT" ];then
		wget -q -O "$FILE_TEMP_NAME" "$DOWNLOAD_URL$SCRIPT" || error_handler 4 "$?"
	fi
	
	# the primary test is to test for file corruption, if the new file doesn't have
	# the EOF value, it is by definition corrupted. After that some simple tests.
	#  -s is prefered over -f because sometimes downloads fail and leave null size file
	# we're taking the temp file, testing it for null, then mv to correct file. Please do
	# not mess with these tests at all unless you can make them even more robust. No -f
	# is required because if wget exits with error then script exits. And if no error,
	# file will be null or existent and not null. I am adding another -f test here because
	# wget is so buggy I simply cannot predict its failure behaviors at all.
	if [ ! -e "$FILE_TEMP_NAME" ];then
		error_handler 6
	elif [ ! -s "$FILE_TEMP_NAME" ];then
 		error_handler 2
 	# then test for eof marker in files, this is basically foolproof
	elif [ -z "$( grep -si "$SCRIPT_EOF" $FILE_TEMP_NAME )" ];then
		error_handler 8
# 	# if exists and not null
	# I'm being extra careful here, there have been too many problems with this simple
	# stuff... wget needs to be fixed to handle failed downloads better... what is  missing
	# is a null file test, as opposed to exists AND null.
	elif [ -s "$FILE_TEMP_NAME" ];then
		# now that the file exists and is not null
		mv -f $FILE_TEMP_NAME $PREFIX$SCRIPT

		# make executable if not
		if [ ! -x "$PREFIX$SCRIPT" ];then
			chmod +x "$PREFIX$SCRIPT"
		fi

		# then run it with an error handler for unknown weirdness which I'm sure will appear.
		if [ -x "$PREFIX$SCRIPT" ];then
			# I'm just going to put a test for basically everything that can go wrong
			# If we're lucky, this will handle partial or incomplete downloads that are not null
			exec "$PREFIX$SCRIPT" "$@" || error_handler 7 "$?"
		else
			error_handler 3
		fi
	fi
fi

