#!/bin/bash
########################################################################
####  Script Name: smxi
####  version: 8.6.6
####  Date: December 10 2008
########################################################################
####  Copyright (C) Harald Hope 2005-2008
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here:
####  http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
########################################################################
####  Script Author: Harald Hope
####  Many fixes/code snippets by sidux team.
####  Some fixes on this script come from the sidux irc factoids originally
####
####  Script URL: http://smxi.org/sm/smxi
####  Script Home page: http://techpatterns.com/forums/about736.html
########################################################################
####  FEATURES:
####  This script installs all the stuff you need to upgrade, and has all the current fixes.
####  Updates any Debian Sid/sidux or Debian Testing to latest system,
####  including many fixes etc to help ease the bumps of upgrades.
####  Includes full support for 32/64 bit sidux, Debian Sid, Testing, and Stable
####  including kernel installs etc. Script Updates itself automatically when
####  you run it, and remembers some selections so you don't see them over and over.
########################################################################
####  Script requires the following library files to run completely, these are
####  downloaded automatically when required:
####  sm-lib-apt-tools - all apt functions, package tests, etc
####  sm-lib-clean-up - cleanup functions for installs
####  sm-lib-distro-conversion - various smxi distro options for conversion, run
####  sm-lib-graphics - graphics installer question and functions
####  sm-lib-kernel - kernel installer question and utilities
####  -- sm-lib-kernel-install - submodule of sm-lib-kernel
####     handles actual kernel selection and install
####  sm-lib-misc-tweaks - all the misc tweaks, plus fix fonts stuff
####  sm-lib-package-install - various package install options
####  sm-lib-package-removal - options to remove packages
####  sm-lib-warning - warning section
####  sm-lib-2006-fixes- legacy fixes for distro version < 5
####  sm-lib-2007-fixes- fixes for distro version < 10
####  sm-lib-2008-fixes- fixes for distro version < 14
########################################################################
#### DEFINE:
####
#### TRUE=0;FALSE>0 - with the exception where script uses arithmetic
####                  values to test, like 0 occurances of test grep string
####                  would trigger condition, could be true or false.
#### FUNCTION RETURN VALUES - TRUE=0;FALSE>0
####
#### $DISTRO_VERSION numbers / distro name:
#### 0 unsupported
#### 1-4 kanotix:
#### 1 2005-04; 2 cebit; 3 Easter; 4 2006-01-rc1-x (only conversions: d:1-d:4 format)
#### NOTE: all kanotix conversions are treated as 5
#### 5 sidux test pre release, kanotix/debian conversions ( debian - d:d )
#### 6 chaos, 7 tartaros, 8 gaia, 9 eros, 10 nyx 11 erberos 12 ourea 13
########################################################################

########################################################################
####  VARIABLES
########################################################################

# system paths etc
X_ORG_PATH='/etc/X11/xorg.conf'
X_ORG_BU_PATH=$X_ORG_PATH'-bu-'$(date +%y-%m-%d)
KDMRC_PATH='/etc/kde3/kdm'
EF='/etc/fstab'
EAS='/etc/apt/sources.list'
EASMD='/etc/apt/sources.list.d/mirror.debian.org.list'
EASMS='/etc/apt/sources.list.d/mirror.sidux.com.list'
EASDL='/etc/apt/sources.list.d/debian.list'
EASSL='/etc/apt/sources.list.d/sidux.list'
EDD='/etc/default/distro'
GRUB_PATH='/boot/grub/menu.lst'
GRUB_BU_PATH=$GRUB_PATH'-bu-'$(date +%y-%m-%d)
EAX='/etc/antix-version'
EDV='/etc/debian_version'
EKV='/etc/kanotix-version'
ESV='/etc/sidux-version'
EDI='/etc/issue'
SMDV='/etc/s-distro-version'
SMDL='/etc/s-distro-level'

# distro version info
DISTRO_VERSION=''
# this one is used for assigning fixes based on release versions, default is 0
DISTRO_LEVEL=0
# simple live test, this will be used to turn off some script features
IS_LIVE=''
if [ -s $EDD ];then
	source $EDD
	if [ "$FLL_DISTRO_MODE" == 'live' ];then
		IS_LIVE='true'
	fi
fi

# kernel info
CURRENT_KERNEL=$(uname -r)
CURRENT_APT_KERNEL=''
CURRENT_APT_KERNEL_GRUB=''
CURRENT_DEBIAN_KERNEL=''
CURRENT_MEPIS_KERNEL=''
CURRENT_SIDUX_KERNEL=''
# 2.6.24-2.6.24.2.makke.rt1.s4-sidux-686
# handle this syntax: 2.6.24-2.6.24.1.slh.3-sidux-amd64
# by slicing first part out using -, we should end up 2.6.24 in most cases
KERNEL_VERSION=$( uname -r | cut -d '-' -f 1 | egrep -o "2\.6\.[0-9]{2,3}" )
# for math kernel compares, eg, -gt 24
KERNEL_THIRD=$( cut -d '.' -f 3 <<< $KERNEL_VERSION )
KERNEL_FILE=''
KERNEL_FILE_RESET=''
# these 4 will be loaded in sm-lib-kernel
KERNEL_LIST_32=''
KERNEL_ADVANCED_LIST_32=''
KERNEL_LIST_64=''
KERNEL_ADVANCED_LIST_64=''
# check for 64 bit first
if [ -n "$( uname -m | grep -o 'x86_64' )" ];then
	BITS="64"
else
	BITS="32"
fi

# set some core count dependent data
CORE_COUNT=$( cat /proc/cpuinfo | grep -c '^processor' )
LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= CPU_NAME=$( grep -i -m1 'model name' /proc/cpuinfo | cut -d ':' -f 2-5 )

KERNEL_DIRECTORY='/usr/src/kernel-downloads'
KERNEL_INSTALL_DIRECTORY=''
KERNEL_LIST=''
KERNEL_ADVANCED_LIST=''
KERNEL_BASE_FILE=''
LATEST_UP_KERNEL=''
KERNEL_PREFIX='kernel-'
KZ='.zip'

# this handles two cases: 1 where user logged in directly as 'root', and
# 2, where user su to root.
LOGIN_PID=$( ps | grep ' login' )
if [ "$LOGIN_PID" == '' ];then
	LOGIN_PID=$( ps | grep ' su' )
fi
LOGIN_PID=$( echo $LOGIN_PID | grep -o "[0-9]*" )

# script paths
SCRIPT_HOME='/usr/local/bin'
SCRIPT_NAME=$( basename $0 )
SCRIPT_ROTATE="/etc/logrotate.d/$SCRIPT_NAME"
VERSION_INFO='sm-versions'
WARNING_STATUS='status'
WARNING_BODY='warning_message'
ALERT_BODY='alert_message'
CONFIGS_BODY='configs'
HOLD_INSTALL='holds'
STATUS='danger' # set to danger level by default
UPGRADE_DATA='upgrade-data/'
# $SCRIPT_DOWNLOAD $SCRIPT_DOWNLOAD_KERNELS
SCRIPT_DOWNLOAD='http://smxi.org/sm/'
SCRIPT_DOWNLOAD_SG='http://smxi.org/sg/'
SCRIPT_DOWNLOAD_SV='http://smxi.org/sv/'
SCRIPT_DOWNLOAD_IN='http://inxi.googlecode.com/svn/trunk/'
SCRIPT_DOWNLOAD_KERNELS='http://smxi.org/sm/kernels/'
SM_CONFIG_FILE='/etc/smxi.conf'
# user set global variable values, mostly for hard coding options
SM_VALUES='/usr/local/bin/smxi-values'
# dev urls:
SCRIPT_DOWNLOAD_DEV='http://techpatterns.com/downloads/dev/'
SCRIPT_DOWNLOAD_BRANCH_1='http://smxi.googlecode.com/svn/branches/one/'
SCRIPT_DOWNLOAD_BRANCH_2='http://smxi.googlecode.com/svn/branches/two/'

# xorg stuff
X_VERSIONS_PRE=''
X_VERSIONS_POST=''
CLEAN_X_ORG_LOG='/var/log/sm_clean_xorg_modules.log'
X_ORG_SAVE_LIST=''
X_ORG_LIST=''

# video driver installer info
GFX_INSTALLER=''
ATI=''
NVIDIA=''
INTEL=''

# script library files:
LIB_APT_TOOLS='sm-lib-apt-tools'
LIB_CLEAN_UP='sm-lib-clean-up'
LIB_DISTRO_CONVERSION='sm-lib-distro-conversion'
LIB_GRAPHICS='sm-lib-graphics'
LIB_KERNEL='sm-lib-kernel'
LIB_KERNEL_INSTALL='sm-lib-kernel-install'
# LIB_KERNELS='sm-lib-kernels'
LIB_MISC_TWEAKS='sm-lib-misc-tweaks'
LIB_PACKAGE_INSTALL='sm-lib-package-install'
LIB_PACKAGE_REMOVAL='sm-lib-package-removal'
LIB_WARNING='sm-lib-warning'
LIB_2006_FIXES='sm-lib-2006-fixes'
LIB_2007_FIXES='sm-lib-2007-fixes'
LIB_2008_FIXES_STATIC='sm-lib-2008-fixes'
LIB_2008_FIXES=''
# script modules
MOD_INXI='inxi'
MOD_GFX='sgfxi'
MOD_VM='svmi'
# optional user set scripts/download locations
USER_SCRIPT=''
USER_SCRIPT_URL=''

# script import test values
SET_APT_TOOLS=''
SET_CLEAN_UP=''
SET_GRAPHICS=''
SET_KERNEL=''
SET_KERNEL_INSTALL=''
SET_MISC_TWEAKS=''
SET_PACKAGE_INSTALL=''
SET_PACKAGE_REMOVAL=''
SET_SIDUX_CONV=''
SET_WARNING=''
SET_VM=''
SET_2006_FIXES=''
SET_2007_FIXES=''
SET_2008_FIXES=''

# defaults for prefs, options, etc
ADVANCED_KERNEL=''
B_DEBUG=''
B_TESTING_1=''
B_TESTING_2=''
CHANGE_KERNEL_MIRROR=''
CHANGE_MIRRORS=''
DEFAULT_KERNEL=''
DPKG_UPDATE=''
EXTRA_OPTIONS=''
FORCE_DOWNLOAD=''
FORCE_UPDATE=''
HEC_ALT=''
KERNEL_METAPACKAGE=''
SCRIPT_COLORS=1
NO_PDIFFS=''
NO_PDIFF_ARGS='-o Acquire::Pdiffs=false'
SERVER_CLIENT=''
START_OPTIONS=''
SKIP_CONNECTIONS=''
SKIP_CONNECTION_TEST=''
SKIP_DIST_UPGRADE=''
SKIP_ENTER=''
SKIP_GRAPHICS=''
SKIP_INFO=''
SKIP_KERNEL=''
SKIP_RESTART=''
SKIP_TWEAKS=''
SKIP_WARNING=''
Z_SET=''

# set function variables that will retain values: check hold is actually loaded top of
# sm-lib-apt-tools
APT_TYPE='apt-get'
CHECK_HOLD_PACKAGES=''
CHECK_VERSION_TEXT=''
CON_DEB=''
CONNECTION_RETRY=''
# setting to 'true' turns off script self-updater. You must have ALL script components
# in $SCRIPT_HOME (/usr/local/bin) here already to use this without having error occur.
DEBIAN_KERNEL_INSTALLED=''
DEBIAN_KERNEL_CANDIDATE=''
DEV_FLAG=''
DISTRO='debian'
DISTRO_F=''
HOLD_INSTALL_ITEMS='' # holds value for any hold/install required
DU_UPGRADE='dist-upgrade'
# we'll always use the system default in all cases
INIT_LEVEL=$( grep ':initdefault:' /etc/inittab | egrep -o '[0-5]' )
KERNEL_EQUAL_INSTALL=''
KERNEL_FORCE_DU=''
KERNEL_INSTALL_TO='' # will be used to install to gfx driver if desired
KERNEL_POST_DU_FLAG=''
KERNEL_POST_DU_INSTALL=''
LOG_FILE='/var/log/smxi.log'
LOG_INDENT=''
LOGGING_STARTED=''
LOGMS='log_function_data ms $FUNCNAME "$( echo $@ )"'
LOGME='log_function_data me $FUNCNAME'
LOGPS='log_function_data ps $FUNCNAME "$( echo $@ )"'
LOGPE='log_function_data pe $FUNCNAME'
LOGUS='log_function_data us $FUNCNAME "$( echo $@ )"'
LOGUE='log_function_data ue $FUNCNAME'
MEPIS_SOURCES=''
PRINT_VERSION=''
REMOTE_VERSION=''
REMOTE_DATE=''
SET_KERNEL_DATA=''
SIDUX_SOURCES=''
SKIP_CONNECTION_RETRY=''
SYSTEM_BASE=''
UPDATED=''
USE_DEBIAN_KERNEL=''
WITHOUT_RECOMMENDS=''

# miscellaneous settings
MAX_AGE=300 # due to 'fewer' script changes, no need to be as careful
TIME_OUT=25

# allow user set globals to override script globals
if [ -f $SM_VALUES ];then
	source $SM_VALUES
fi

########################################################################
####  FUNCTIONS
########################################################################

########################################################################
### core utilities, script updating tool (mini-apt), xorg utilities,
### package/file tests, sticky prefs, script values/triggers
###---------------------------------------------------------------------

###---------------------------------------------------------------------
### core utilities: debugger, error handler, logging when it comes
###---------------------------------------------------------------------

# set global color variables
# options: 0 - turns off all colors; 1 - defaults
set_script_colors()
{
	# set colors
	case $SCRIPT_COLORS in
		0)
			W='' # red: Warning message
			E='' # yellow: script Error
			S='' # green: Standard message
			Q='' # CYAN: Questions
			M='' # CYAN: Message
			C='' # MAGENTA: Command or Path
			N='' # default system console color: Normal :: make last in colors
			;;
		1)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[1;32m" # green: Standard message
			Q="[1;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		2)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[0;37m" # Standard message
			Q="[0;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			B="[1;34m" # BLUE: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		3)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[0;33m" # Standard message
			Q="[1;34m" # CYAN: Questions
			M="[0;36m" # CYAN: Message
			B="[0;36m" # BLUE: Message
			C="[0;32m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
	esac

	# script layout stuff
	BA='=================================================================='
	LI='------------------------------------------------------------------'
	BAR=${S}$BA${N}
	EBAR=${E}$BA${N}
	WBAR=${W}$BA${N}
	MBAR=${M}$BA${N}
	LINE=${S}$LI${N}
	ELINE=${E}$LI${N}
	MLINE=${M}$LI${N}
	WLINE=${W}$LI${N}
	SPACER='  '

	# repeated text
	YNE="\n${S}[ type lower case ${C}y${S} or ${C}n${S} and hit ${C}enter${S} ]${N}"
	SLE="${Q}Please type the appropriate number and hit ${C}enter${N}"
}

## Generic script debugging, $1 testing function; $2 test output; $3 test input, if needed
# output is usually an echo of the value produced by function
# input is usually setting a global first, although it could also be firing another function
script_debugger()
{
	if [ "$B_DEBUG" == 'true' ];then
		echo "${M}Running debugger for function: ${C}$1"
		echo "${M}Test debugger input: ${C}$3"
		echo "${M}Test debugger output: ${C}$2${N}"
		eval $3 # first set any values/globals etc that function will use
		eval $1 # run function, with options etc if needed
		eval $2 # show output, echoes, whatever
		echo "${M}debugging completed.${N}"
		exit 0
	fi
}

# args: $1 - error id string; $2 - error function name; $3 - error optional data
error_handler()
{
	local errorId=$1 # id string calling, I want this to be readable
	local errorFunction=$2
	local errorExtra=$3 # this is secondary info, like failed package name
	local errorCode=0 # exit/internal error number
	local errorLevel='' # fatal/serious/internal
	local errorMessage='' errorLogMessage='' errorPrintMessage=''
	local errorColor=${E}
	local errorLine=''

	# error handling on the error handler ;-)
	if [ -z "$1" -o -z "$2" ];then
		errorFunction=$FUNCNAME
		errorId='value-null'
		if [ -z "$1" ];then
			errorExtra="\$1 "
		fi
		if [ -z "$2" ];then
			errorExtra="$errorExtra\$2"
		fi
	fi
	case $errorId in
		# general system checks - 2-100: fatal - exit
		# note: I'm leaving 1 as a default script wide as I move to this error handler
		force-update-failed)
			errorCode=4
			errorMessage="The forced update of $SCRIPT_NAME failed. Returned error code: $errorExtra"
			;;
		not-root)
			errorCode=2
			errorMessage="You must be logged in as root to run this script.\n${LOG_INDENT}Please start $SCRIPT_NAME as root."
			;;
		smxi-version-too-old)
			errorCode=5
			errorMessage="The Script has not been updated in more than $MAX_AGE Days\n${LOG_INDENT}It is not safe to proceed.\n${LOG_INDENT}Check that the script is still being maintained please before you use it."
			;;
		unidentified-distro)
			errorCode=6
			errorMessage="Your distro could not be identified by $SCRIPT_NAME.\nIf it is a Debian derived distro which should be supported, please let the script author\nknow how to identify it so it can be supported in the future."
			;;
		unsupported-distro)
			errorCode=3
			errorMessage="The $errorExtra distro is not supported by $SCRIPT_NAME, sorry."
			;;
		# kernel section errors
		kernel-download-failed)
			errorCode=30
			errorMessage="Kernel zip file failed to download or is absent. The smxi.org kernel server\n${LOG_INDENT}may be temporarily down. Please try again at a later time."
			;;
		kernel-zip-corrupted)
			errorCode=33
			errorMessage="Kernel zip file cyclic redundancy test failed. The downloaded zip file was probably\n${LOG_INDENT}not fully downloaded, or got corrupted in some other way. Delete it and try again.\n${LOG_INDENT}This is the damaged file: $errorExtra"
			;;
		kernel-zip-install-failed)
			errorCode=31
			errorMessage="Kernel zip file installer exited with error code: $errorExtra\n${LOG_INDENT}Please try to find out why you encountered problems before you continue."
			;;
		kernel-zip-installer-missing)
			errorCode=32
			errorMessage="The zip kernel installer file could not be found.\n${LOG_INDENT}The kernel install cannot continue."
			;;
		user-killed-du)
			errorCode=33
			errorMessage="User initiated $DU_UPGRADE component termination via ctrl+c or kill."
			;;
		user-killed-conversion)
			errorCode=37
			errorMessage="User initiated conversion component termination via ctrl+c or kill."
			;;
		warning-status-file-missing)
			errorCode=34
			errorMessage="Missing Warning Section file: $errorExtra\n$SCRIPT_NAME cannot execute the requested action without this file."
			;;
		missing-lib-fatal)
			errorCode=35
			errorMessage="The operation you requested requires the library file: $errorExtra but it is missing.\nThe script cannot run the requested action without this library.\n please find out what is wrong."
			;;
		bad-user-script-url)
			errorCode=36
			errorMessage="The script url you provided: $errorExtra is not working.\nPlease check your typing, and make sure the url actually exists."
			;;
		unsupported-option)
			errorCode=38
			errorMessage="You entered an unsupported option\nor an option that needs an argument: $errorExtra\nPlease see $SCRIPT_NAME -h for a list of supported options."
			;;
		# failures in actions/functions not requiring script exit: 100-150: serious
		bad-file-format)
			errorCode=104
			errorMessage="Unrecognized format in: $errorExtra "
			;;
		missing-lib)
			errorCode=100
			errorMessage="The operation you requested requires the library file: $errorExtra but it is missing.\nSkipping the load attempt and continuing.\n"
			;;
		package-unavailable)
			errorCode=103
			errorMessage="The package: $errorExtra is not available.\nYou may need to add different sources for apt to install it, or it may be obsolete.\n"
			;;
		warning-data-wget-error)
			errorCode=101
			errorMessage="There was an error downloading the warning file: $errorExtra "
			;;
		warning-data-file-missing)
			errorCode=102
			errorMessage="Missing Warning Section file: $errorExtra "
			;;

		# internal script errors/failures in system: 151-254: normal
		null-kernel-file-data)
			errorCode=251
			errorMessage="The kernel installer received a null value for the kernel to install.\nThis probably means that the requested kernel is not in apt at the moment\nbecause of a metapackage kernel version mismatch. Try it again later.\nInstall request type: $errorExtra "
			;;
		value-bad)
			errorCode=253
			errorMessage="Received a false value: $errorExtra"
			;;
		value-null)
			errorCode=252
			errorMessage="Received a null value from arg: $errorExtra"
			;;
		*)
			errorCode=254
			errorMessage="Received a false \$errorId value: $errorId"
			errorFunction=$FUNCNAME
			;;
	esac

	if [ "$errorCode" -le 254 -a "$errorCode" -gt 150 ];then
		errorLevel='internal'
	elif [ "$errorCode" -le 150 -a "$errorCode" -gt 100 ];then
		errorLevel='serious'
	elif [ "$errorCode" -le 100 -a "$errorCode" -gt 1 ];then
		errorLevel='fatal'
		errorMessage="${errorMessage}\n${LOG_INDENT}$SCRIPT_NAME cannot continue. Exiting now."
		errorColor=${W}
		errorLine="\n${LOG_INDENT}$WLINE\n${LOG_INDENT}"
	fi
	errorLogMessage="$errorMessage\n${LOG_INDENT}Error No: $errorCode- Function: $errorFunction"
	errorPrintMessage="$errorLine${M}Error No: (${C}$errorCode${M}) ${errorColor}$errorMessage$errorLine${N}"
	# strip out the spacer stuff for output if required, not testing null gives sed error
	if [ "$LOG_INDENT" != '' -a "$LOG_INDENT" != ' '  ];then
		errorPrintMessage=$( echo "$errorPrintMessage" | sed "s/$LOG_INDENT//g" )
	fi

	echo -e "$errorPrintMessage"

	if [ -f $LOG_FILE -a "$LOGGING_STARTED" == 'true' ];then
		log_function_data "$LI\n${LOG_INDENT}$errorLogMessage\n${LOG_INDENT}$LI"
	fi

	if [ "$errorLevel" == 'fatal' -a "$LOGGING_STARTED" == 'true' ];then
		echo
		echo "${M}Error logs are located here: ${C}$LOG_FILE${N}"
	fi

	case $errorLevel in
		fatal)
			exit $errorCode
			;;
		serious|internal)
			: # so far do nothing
			;;
	esac
}
# error_handler "value-nul" "fred_is" '$1';exit

# args: $1 - type of function/feature; $2 $FUNCNAME
log_function_data()
{
	local utilClose=''
	# master are not set by another function. primary are set by a master
	# utilities are used by all functions. This should result in nested logs
	local funcInfo=''
	case $1 in
		ms)
			funcInfo="Function: $2 - MASTER: Start"
			LOG_INDENT=''
			;;
		me)
			funcInfo="Function: $2 - MASTER: End"
			LOG_INDENT=''
			;;
		ps)
			funcInfo="Function: $2 - Primary: Start"
			# set tabbing for nested
			LOG_INDENT=''
			;;
		pe)
			funcInfo="Function: $2 - Primary: End"
			LOG_INDENT=''
			;;
		us)
			funcInfo="Function: $2 - Utility: Start"
			# set tabbing for nested
			adjust_log_indent 'add'
			;;
		ue)
			funcInfo="Function: $2 - Utility: End"
			# slice out zero or one spacer element to reset tabbing for nesting
			utilClose='true'
			;;
	esac

	if [ -n "$funcInfo" ];then
		log_writer "$funcInfo"
	else
		log_writer "$1"
	fi

	if [ -n "$3" -a "$3" != "$SCRIPT_HOME/$SCRIPT_NAME" ];then
		log_writer "Args: $3"
	fi

	if [ "$utilClose" == 'true' ];then
		adjust_log_indent 'remove'
	fi
}
# sets the global LOG_INDENT for logging output
# args: $1 - add/remove
adjust_log_indent()
{
	case $1 in
		add)
			LOG_INDENT="${LOG_INDENT}${SPACER}"
			;;
		remove)
			# trim off one spacer block only to drop one indent level
			LOG_INDENT="$( echo "${LOG_INDENT}" | sed s/[\ ][\ ]// )"
			;;
	esac
}
# args: $1 - data to write to logfile. Note that the function is always logged
# via function_logging first, and other relevant globals are set there as well
log_writer()
{
	# this handles first line indents, all other indents must be set in message data
	# like so: message="some problem... \n${LOG_INDENT}more problem stuff..."
	if [ "$LOGGING_STARTED" == 'true' ];then
		# strip out escape color code, if any. Method by dzz of sidux, thanks ;-)
		echo -e "${LOG_INDENT}$1" | sed 's/\x1b\[[0-9]\{1,2\}\(;[0-9]\{1,2\}\)\{0,2\}m//g' >> $LOG_FILE
	fi
}

create_log()
{
	local scriptVersion=$( grep 'version:' $SCRIPT_NAME | grep -o "[0-9]*\.[0-9]*\.[0-9]*" )

	if [ ! -f $SCRIPT_ROTATE ];then
		echo "$LOG_FILE {
	rotate 2
	size 200k
	create
}
" > $SCRIPT_ROTATE
	fi
	touch $LOG_FILE # make one for logrotate if null
	if [ -n "$( which logrotate )" ];then
		logrotate $SCRIPT_ROTATE
	fi
	touch $LOG_FILE # and if rotated, make a new one
	echo "=========================================================" >> $LOG_FILE
	echo "START $SCRIPT_NAME LOGGING:" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE
	echo "Script started: $( date +%Y-%m-%d-%H:%M:%S )" >> $LOG_FILE
	echo "Installed Kernel: $CURRENT_KERNEL" >> $LOG_FILE
	echo "$SCRIPT_NAME script version: $scriptVersion" >> $LOG_FILE
	echo "$SCRIPT_NAME start args: $START_OPTIONS" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE

	LOGGING_STARTED='true'
}


###---------------------------------------------------------------------
### core utilities: script libs update: 'mini-apt', trigger function
###---------------------------------------------------------------------

# we're only going to bring in the module one time for anything where user
# might have repeated run throughs of certain modules,
# arguments: $1 which lib/module file; $2 and $3 are options for run module
run_script_import()
{
	eval $LOGUS
	local loadIt='' runIt='' options='' noTestDownloadOnly='' runCommand='test_version_info'
	local runScript=''

	case $1 in
		$LIB_APT_TOOLS)
			if [ "$SET_APT_TOOLS" != 'true' ];then
				loadIt='true'
				SET_APT_TOOLS='true'
			fi
			;;
		$LIB_CLEAN_UP)
			if [ "$SET_CLEAN_UP" != 'true' ];then
				loadIt='true'
				SET_CLEAN_UP='true'
			fi
			;;
		$LIB_DISTRO_CONVERSION)
			if [ "$SET_SIDUX_CONV" != 'true' ];then
				loadIt='true'
				SET_SIDUX_CONV='true'
			fi
			;;
		$LIB_GRAPHICS)
			if [ "$SET_GRAPHICS" != 'true' ];then
				loadIt='true'
				SET_GRAPHICS='true'
			fi
			;;
		$LIB_KERNEL)
			if [ "$SET_KERNEL" != 'true' ];then
				loadIt='true'
				SET_KERNEL='true'
			fi
			;;
		$LIB_KERNEL_INSTALL)
			if [ "$SET_KERNEL_INSTALL" != 'true' ];then
				loadIt='true'
				SET_KERNEL_INSTALL='true'
			fi
			;;
# 		$LIB_KERNELS)
# 			loadIt='true'
# 			noTestDownloadOnly='true'
# 			;;
		$LIB_MISC_TWEAKS)
			if [ "$SET_MISC_TWEAKS" != 'true' ];then
				loadIt='true'
				SET_MISC_TWEAKS='true'
			fi
			;;
		$LIB_PACKAGE_INSTALL)
			if [ "$SET_PACKAGE_INSTALL" != 'true' ];then
				loadIt='true'
				SET_PACKAGE_INSTALL='true'
			fi
			;;
		$LIB_PACKAGE_REMOVAL)
			if [ "$SET_PACKAGE_REMOVAL" != 'true' ];then
				loadIt='true'
				SET_PACKAGE_REMOVAL='true'
			fi
			;;
		$LIB_WARNING)
			if [ "$SET_WARNING" != 'true' ];then
				loadIt='true'
				SET_WARNING='true'
			fi
			;;
		$LIB_2006_FIXES)
			if [ "$SET_2006_FIXES" != 'true' ];then
				loadIt='true'
				SET_2006_FIXES='true'
			fi
			;;
		$LIB_2007_FIXES)
			if [ "$SET_2007_FIXES" != 'true' ];then
				loadIt='true'
				SET_2007_FIXES='true'
			fi
			;;
		$LIB_2008_FIXES)
			if [ "$SET_2008_FIXES" != 'true' ];then
				loadIt='true'
				SET_2008_FIXES='true'
			fi
			;;
		# the proper download urls for these are set in download_test_file case
		$MOD_GFX)
			runIt='true'
			runScript=$1
			;;
		$MOD_INXI)
			options="-F"
			runIt='true'
			runScript=$1
			;;
		$MOD_VM)
			# note: -j x will override the D color setting, so D needs to be last
			options="-j $SCRIPT_COLORS -D -P $APT_TYPE"
			runIt='true'
			runScript=$1
			;;
		*)
			if [ -n "$USER_SCRIPT_URL" -a -n "$USER_SCRIPT" ];then
				runIt='true'
				runCommand='update_scripts'
				runScript=$USER_SCRIPT
			else
				error_handler 'value-bad' $FUNCNAME "$1"
			fi
			;;
	esac

	# test version against current, download/run/include
	if [ "$loadIt" == 'true' ];then
		# this is needed for a special case where users might want to run feature in user mode
		if [ "$( whoami )" == 'root' ];then
			if [ "$2" != 'no-download' -a "$noTestDownloadOnly" != 'true' ];then
				test_version_info $1
			fi
			if [ "$noTestDownloadOnly" == 'true' ];then
				update_scripts $1
			fi
		fi
		if [ -f $1 ];then # if the file is already present, do this
			source ./$1 # load include file
		else
			error_handler 'missing-lib' $FUNCNAME $1
		fi
	elif [ "$runIt" == 'true' ];then
		$runCommand $1 'chm'
		DISPLAY= ./$runScript $options # run module
	fi
	eval $LOGUE
}

# arg: $1 is which file to test; $2 is if chmod or not
# 0 means get latest, 1 means don't
test_version_info()
{
	eval $LOGUS
	local LocalVersion='' remoteVersion='' remoteDate='' updateLocal=''

	# first to test that it exists, download if not
	if [ ! -f $SCRIPT_HOME/$1 ];then
		update_scripts $1 $2
	fi
	# test local against remote versions
	LocalVersion=$( grep -m 1 -o -G "version:\ [0-9]*.[0-9]*.[0-9]*" $SCRIPT_HOME/$1 | grep -o -G "[0-9].[0-9]*.[0-9]*" )
	# I'm being careful with globals, I want to make sure no unset global error occurs
	# reset the global value for remote version now
	remoteVersion=$( grep -e "$1=.*" $VERSION_INFO | cut -d '=' -f 2 | cut -d ':' -f 1 )
	remoteDate=$( grep -e "$1=.*" $VERSION_INFO | cut -d '=' -f 2 | cut -d ':' -f 2 )
	# now set the globals
	REMOTE_VERSION=$remoteVersion
	REMOTE_DATE=$remoteDate

	# keep in mind, return values for compare: 0 -> >; 1 -> ==; 2 -> <
	updateLocal=$( compare_numbers $remoteVersion $LocalVersion )

	eval $LOGUE
	# updates as needed, if updated, return 0, if not, return 1
	if [ "$updateLocal" -ne 1 ];then
		update_scripts $1 $2
		return 0
	else
		return 1
	fi
	eval $LOGUE
}

# arguments: $1 filename; $2 chm/other, for chmod +x $1
update_scripts()
{
	eval $LOGUS
	local success=""

	# for devs only, this switches off/on updates, so you can work
	# on a local test version without overwrites happening
	if [ "$DEV_FLAG" != 'true' ];then
		download_test_file "$1" "$2"
		success="$?"
	else
		success=0 # hard code success, do not actually update
	fi
	log_function_data "Return: $success"
	eval $LOGUE
	return $success
}

# args: $1 - file to download; $2 -chm; $3 - repeat try, auto
download_test_file()
{
	eval $LOGUS
	local fileName=$1 fileNameTemp=''
	local isGood='' wgetError=0 update=''
	local downloadLocation=$SCRIPT_DOWNLOAD downloadFile=$1 downloadUrl=''

	if [ -f "$fileNameTemp" ];then
		rm -f $fileNameTemp # remove the temp file, should never fire, but why not?
	fi
	if [ "$downloadFile" == "$LIB_WARNING" ];then
		update="?$DISTRO_F"
	fi
	if [ "$downloadFile" == "$USER_SCRIPT_URL" ];then
		downloadLocation=$USER_SCRIPT_URL
		downloadFile=''
		fileName=$USER_SCRIPT
	fi

	# this handles the new urls:
	case $1 in
		$MOD_GFX)
			downloadLocation=$SCRIPT_DOWNLOAD_SG
			;;
		$MOD_VM)
			downloadLocation=$SCRIPT_DOWNLOAD_SV
			;;
		$MOD_INXI)
			downloadLocation=$SCRIPT_DOWNLOAD_IN
			;;
	esac

	fileNameTemp="$( mktemp -p $SCRIPT_HOME/ $fileName.XXXXXXXXXX )"
	downloadUrl="$downloadLocation$downloadFile$update"
	log_function_data "download url: $downloadUrl"
	# always using -O here because -Nc is really buggy over time lines and fast file changes
	wget -T$TIME_OUT -t 2 -q -O$fileNameTemp $downloadUrl &>/dev/null || wgetError="$?"
	if [ "$wgetError" -gt 0 ];then
 		file_download_error "$fileName" 'server-problem' "$wgetTest"
	else
		# all smxi files have this string as last line, so if it's there, the file should usually
		# run fine, except for weird fringe cases where the ascii file is corrupted partially
		isGood=$( grep '##\*\*EOF\*\*##' $fileNameTemp )
		if [ -n "$isGood" -o "$1" == "$USER_SCRIPT_URL" ];then
			mv -f $fileNameTemp $fileName
			# I'm not sure why this changed, but I've been seeing some 700 and 704 here
			# so this is going to be done explicitly now instead.
			if [ "$2" == 'chm' ];then
				chmod 705 $fileName
			else
				chmod 604 $fileName
			fi
			eval $LOGUE
			return 0
		else
			# dump the bad file
			rm -f $fileNameTemp

			if [ "$3" != 'repeat' ];then
				# let's try this once again to make sure it wasn't just a temp problem
				echo "${E}The file ${C}$fileName${E} did not download correctly, retrying download now...${N}"
				download_test_file "$1" "$2" 'repeat'
			else
				file_download_error "$1" 'file-corrupt'
				eval $LOGUE
				return 1
			fi
		fi
	fi

	eval $LOGUE
}
# args: $1 - file name; $2 - error type
file_download_error()
{
	eval $LOGPS
	local response='' repeat='' downloadError1='' downloadError2=''

	if [ "$2" == 'file-corrupt' ];then
		downloadError1='is incomplete or corrupted.'
		downloadError2="It appears the file failed to fully download for some reason."
	elif [ "$2" == 'server-problem' ];then
		downloadError1='could not be accessed.'
		downloadError2="The download failed with wget error: ${C}$3${E} The site may be down."
	fi
	echo $ELINE
	echo "${E}Download Error: ${C}$SCRIPT_NAME${E} component ${C}$1${E} $downloadError1."
	echo "$downloadError2"
	echo
	if [ "$2" == 'server-problem' ];then
		echo "${S}(If you need to reinstall your wifi module, just answer ${C}n${S} here"
		echo "and you will continue on to the wifi module install section)"
	else
		echo "${C}$SCRIPT_NAME${S} has already retried this download one time, and it has failed."
		echo "You probably have either a router, an ISP, or some other strange connection issue."
	fi
	echo $LINE
	echo -e "${Q}Do you want to exit now ${C}y${Q} or continue without the new version of the file ${C}n${Q}?$YNE"
	read response

	case $response in
		y)	print_quit
			;;
		n)	echo "${S}Ok, continuing with the script without downloading: ${C}$1${N}"
			return 1
			;;
		*)	print_error yn
			file_download_error "$1" "$2"
			;;
	esac
	eval $LOGPE
}

# args: $1 url to test, returns 0/1 for success/fail
wget_test()
{
	wget -T5 -t 1 -q --spider $1 && return 0 || return 1
}

# compare 2 dot [5.34.6] or 1/0 dot [3.45,3] version numbers
# return codes: 0 - $1 > $2; 1 - $1 == $2; 2 - $1 < $2
# note: this also works for one dot, like 3.4, and for 0 dot, like 3
# note: this function will always be sent . type numbers, and it handles any
# localization re decimal indicators internally, otherwise it's too much of a pain.
compare_numbers()
{
	eval $LOGUS
	## DEBUGGER
	# echo $1 $2
	# first we need to determine what the base system is using for decimal indicator
	local returnValue=''
	local decimalType=$( echo 1 | awk '{total = $1 / 2; print total}' | egrep -o '(\.|,)' )

	# next we'll get the raw data and transate it if required
	local numOne=$( echo $1 | cut -d '.' -f 1-2 | tr '.' $decimalType )
	local subOne=$( echo $1 | cut -d '.' -f 3 )
	local numTwo=$( echo $2 | cut -d '.' -f 1-2 | tr '.' $decimalType )
	local subTwo=$( echo $2 | cut -d '.' -f 3 )

	local test1=$( echo $numOne $numTwo | awk '{if ( $1 > $2 ) print 0;else print 1}' )
	local test2=$( echo $numOne $numTwo | awk '{if ( $1 == $2 ) print 0;else print 1}' )
	local test3=$( echo $subOne $subTwo | awk '{if ( $1 > $2 ) print 0;else print 1}' )
	local test4=$( echo $subOne $subTwo | awk '{if ( $1 == $2 ) print 0;else print 1}' )
	# echo -e "test1 $test1\ntest2 $test2\ntest3 $test3\ntest4 $test4"

	# first case, x > y, and not equal
	if [ "$test1" -eq 0 ];then
		returnValue=0
	# second case, x = y
	elif [ "$test2" -eq 0 ];then # only when x = y, 3.2 = 3.2
		# sub number a > b
		if [ "$test3" -eq 0 ];then
			returnValue=0
		# sub number a = b
		elif [ "$test4" -eq 0 ];then
			returnValue=1
		# sub number a < b
		else
			returnValue=2
		fi
	# if the x is less than y
	else
		returnValue=2
	fi

	echo $returnValue
	log_function_data "returnValue: $returnValue"
	eval $LOGUE
}
## DEBUGGER
# compare_numbers   100.12.2 100.4.3  ;echo result: $?;exit

# generic test and launch function
# args: $1 - which function
launch_function_trigger()
{
	eval $LOGPS
	local prefId='' scriptOption='' scriptFunction='' setPrefs='true' funcArg='prefs'

	case $1 in
		debian-mirrors)
			prefId='debian-mirrors-1'
			scriptOption=$CHANGE_MIRRORS
			scriptFunction='change_debian_mirrors'
			;;
		kernel-mirrors)
			prefId='smxi-kernel-mirror-2'
			scriptFunction='change_kernel_mirrors'
			# test to make sure it's not a dead mirror
			force_kernel_mirror_change
			# must come after since it's reset above if needed
			scriptOption=$CHANGE_KERNEL_MIRROR
			;;
		kernel-metapackage)
			prefId='kernel-metapackage-1'
			scriptOption=$KERNEL_METAPACKAGE
			scriptFunction='metapackage_launcher'
			setPrefs='false'
			;;
		nvidia-sse)
			prefId='nvidia-sse-test-1'
			scriptFunction='nvidia_sse_alert'
			;;
		tester)
			prefId='smxi-kernel-mirror'
			scriptOption='true'
			scriptFunction='run_script_import $LIB_KERNEL;kernel_question'
			setPrefs='false'
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	smPref=$( sm_pref_tester $prefId )

	# run the function, which handles the sticky pref test itself
	if [ "$scriptOption" == 'true' -o "$smPref" -eq 0 ];then
		# this sets whether it's a pref launch or a user option launch
		if [ "$smPref" -eq 0 ];then
			scriptFunction="$scriptFunction $funcArg"
		fi
		eval $scriptFunction
	fi
	# the user MUST set kernel mirror always, that function will set the complex
	# stored mirror value
	if [ "$smPref" -eq 0 -a "$setPrefs" == 'true' ];then
		set_sticky_prefs $prefId
	fi
	eval $LOGPE
}

# args: $1 - prefs/standard -- will pass on to it's launched function
metapackage_launcher()
{
	eval $LOGPS
	local metaExists=$( package_tester '2.6-sidux-' 'wild-full' )

	# special case here, only run if metapackages are present, or if user initiates
	# note: user initiates either by starting from kernel advanced, or -N
	# the smPref is checked in launch_function_trigger and set in kernel_meta_package_handler
	# this extra handling is required to deal with future additions to sidux defaults
	if [ -n "$metaExists" -o "$KERNEL_METAPACKAGE" == 'true' ];then
		# run_script_import $LIB_KERNEL # need a few libs out of this one
		run_script_import $LIB_KERNEL_INSTALL
		print_lib_info $LIB_KERNEL_INSTALL
		kernel_meta_package_handler $1 # pass along prefs/standard
	fi
	eval $LOGPE
}

###---------------------------------------------------------------------
### Test for script files, cleanup stuff
###---------------------------------------------------------------------

set_distro_data()
{
	eval $LOGPS
	local siduxSources=$( grep -sil '^[[:space:]]*deb.*sidux' $EAS $EAS.d/*.list )
	local mepisSources=$( grep -sil '^[[:space:]]*deb.*mepis' $EAS $EAS.d/*.list )
	local aptType=$( sm_pref_tester 'apt-type' 'equal' )
	local defaultKernel=$( sm_pref_tester 'distro-kernel' 'equal' )
	# some people have mixed systems that cannot be dynamically tested for, this hard sets it
	local systemBase=$( sm_pref_tester 'system-base' 'equal' )
	local duUpgrade=$( sm_pref_tester 'du-upgrade' 'equal' )
	local nonDebianPattern='(sidux|opera|debian-multimedia|skype|swiftfox|virtualbox)'

	# these tests will be improved over time, but are ok for now
	local isEtch=$( grep -is '^4.' $EDV )
	local isLennyStable=$( grep -is '^5.' $EDV )
	local isLennyTesting=$( grep -is '^lenny/sid' $EDV )
	local isSqueezeSid=$( egrep -is '^(squeeze/sid|6\.)' $EDV )

	local isStable=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(stable|etch)' )
	local isTesting=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(squeeze|testing)' )
	local isUnstable=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(sid|unstable)' )

	# set antix ID file
	if [ -f /etc/antiX ];then
		EAX='/etc/antiX'
	elif [ -f /etc/antix-version ];then
		EAX='/etc/antix-version'
	fi

	# set system type. This test will never be perfect, but it's a good approximation
	# if [ -n "$isEtch" -o -n "$isLennyStable" ] || [ "$isStable" -gt 0 -a "$isUnstable" -eq 0  -a "$isTesting" -eq 0 ];then
	if [ -n "$isEtch" ] || [ "$isStable" -gt 0 -a "$isUnstable" -eq 0  -a "$isTesting" -eq 0 ];then
		if [ -n "$isEtch" ];then
			SYSTEM_BASE='etch'
		else
			SYSTEM_BASE='stable'
		fi
		DU_UPGRADE='upgrade'
		WARNING_BODY='warning_message_s'
		ALERT_BODY='alert_message_s'
		CONFIGS_BODY='configs_s'
		HOLD_INSTALL='holds_s'
		WARNING_STATUS='status_s'
		LIB_2008_FIXES="$LIB_2008_FIXES_STATIC-s"
	elif [ "$isUnstable" -eq 0 ] && [ -n "$isLennyTesting" -o -n "$isSqueezeSid" -o "$isTesting" -gt 0 ];then
		SYSTEM_BASE='testing'
		WARNING_BODY='warning_message_t'
		ALERT_BODY='alert_message_t'
		CONFIGS_BODY='configs_t'
		HOLD_INSTALL='holds_t'
		WARNING_STATUS='status_t'
		LIB_2008_FIXES="$LIB_2008_FIXES_STATIC-t"
	else
		SYSTEM_BASE='sid'
		LIB_2008_FIXES="$LIB_2008_FIXES_STATIC"
	fi

	# this test goes before the next two to set defaults
	if [ -f $EAX ];then
		DEFAULT_KERNEL='no-kernel'
		# this will help to debug debian kernel issues
		if [ "$B_TESTING_1" != 'true' ];then
			USE_DEBIAN_KERNEL='false'
		else
			USE_DEBIAN_KERNEL='true'
		fi
		DISTRO='antix'
	else
		if [ -f $ESV ];then
			DISTRO='sidux'
		fi
		DEFAULT_KERNEL='debian'
		USE_DEBIAN_KERNEL='true'
	fi

	# then tweak defaults if needed, this order is also important to get right defaults
	if [ -n "$mepisSources" ];then
		MEPIS_SOURCES='true'
		DEFAULT_KERNEL='no-kernel'
	fi
	if [ -n "$siduxSources" ];then # sidux will get priority always
		SIDUX_SOURCES='true'
		DEFAULT_KERNEL='sidux'
	fi
	DISTRO_F="$DISTRO-$SYSTEM_BASE-$BITS"

	## override defaults by user preference
	# user set default kernel
	case "$defaultKernel" in
		debian|sidux|mepis|no-kernel)
			DEFAULT_KERNEL=$defaultKernel
			;;
	esac
	# user set upgrade method
	case "$duUpgrade" in
		upgrade|safe-upgrade|dist-upgrade)
			DU_UPGRADE=$duUpgrade
			;;
	esac
	 # etch aptitude doesn't have safe-upgrade option
	if [ "$SYSTEM_BASE" == 'etch' -a "$DU_UPGRADE" == 'safe-upgrade' ];then
		DU_UPGRADE='upgrade'
	fi
	case "$aptType" in
		apt-get|aptitude)
			APT_TYPE=$aptType
			;;
	esac
	if [ "$APT_TYPE" == 'aptitude' ];then
		WITHOUT_RECOMMENDS='--without-recommends'
	fi
	# it's important to log these in case there's some issue or bug in the values
	if [ -f $SM_VALUES ];then
		log_function_data "Begin User Set $SM_VALUES:\n$( cat $SM_VALUES)\nEnd User Set Values"
	fi
	log_function_data "APT_TYPE: $APT_TYPE"
	log_function_data "SYSTEM_BASE: $SYSTEM_BASE"
	log_function_data "DU_UPGRADE: $DU_UPGRADE"
	log_function_data "DEFAULT_KERNEL: $DEFAULT_KERNEL"
	log_function_data "USE_DEBIAN_KERNEL: $USE_DEBIAN_KERNEL"
	log_function_data "DISTRO: $DISTRO"
	log_function_data "DISTRO_F: $DISTRO_F"
	log_function_data "SIDUX_SOURCES: $SIDUX_SOURCES"
	eval $LOGPE
}

# cleans up legacy and stub files if present
cleanup_extra_files()
{
	eval $LOGPS
	local script_names="sgfxi sm smxi du-fixes-h2.sh svmi" i="" all_files=""

	for i in $script_names
	do
		# Note: if  * is in "" the wildcard does not work
		# /dev/null handles case where no temp or original file exists
		all_files=$( ls "${i}."* 2> /dev/null )
		# make sure stuff exists, then rm files
		# factoid: if you put $all_files in "" it will not work with rm -f
		if [ -n "$all_files" ];then
			rm -f $all_files
		fi
	done
	# handle any legacy stuff too
	all_files=$( ls "du-fixes"* 2> /dev/null )
	if [ -n "$all_files" ];then
		rm -f $all_files
	fi
	if [ -d /var/log/smxi ];then
		rm -fR /var/log/smxi
	fi
	if [ -f /var/log/smxi0.log ];then
		rm -f /var/log/smxi0.log
	fi
	if [ -f sm ];then
		rm -f sm
	fi
	if [ -f smxi.zip ];then
		rm -f smxi*.zip # cleans up also extra stuff
	fi
	if [ -f /usr/sbin/smxi-stub.zip ];then
		rm -f /usr/sbin/smxi-stub.zip
	fi
	# just in case a legacy user comes, don't want to lose the configs
	if [ -f /etc/du-fixes.conf ];then
		mv -f /etc/du-fixes.conf /etc/smxi.conf
	fi
	if [ -f /etc/sm.conf ];then
		mv -f /etc/sm.conf /etc/smxi.conf
	fi
	# clean up a mistake I made with new apt installer logic
	if [ -n "$( grep 'no-set' $SM_CONFIG_FILE )" ];then
		sed -i 's/no-set//' $SM_CONFIG_FILE
	fi
	# this fixes the bad permissions and lets people run the stuff as user again, or view it
	chmod 604 sm-lib-* &>/dev/null
	chmod 705 sgfxi svmi smxi &>/dev/null

	eval $LOGPE
}

# creates / tests for required script data files and logs etc
create_script_files()
{
	eval $LOGPS
	local oldCleanXorgLog='/var/log/clean_xorg_modules.log'

	# make config file / log dir if required
	check_sm_pref_file
	# move old xorg clean up log if present
	if [ -f $oldCleanXorgLog ];then
		mv $oldCleanXorgLog $CLEAN_X_ORG_LOG
	fi
	# change to new format for sources
	if [ -f $EASMD ];then
		mv $EASMD $EASDL
	fi
	if [ -f $EASMS ];then
		mv $EASMS $EASSL
	fi
	eval $LOGPE
	# rename directories to new syntax
	update_kernel_directories
}

update_kernel_directories()
{
	eval $LOGUS
	local prefId='kernel-directory-update-1'
	local smPref=$( sm_pref_tester $prefId )

	local kernelDirs='' kernelDir='' normalizedDir=''

	if [ -d $KERNEL_DIRECTORY -a "$smPref" -eq 0 ];then
		kernelDirs=$( ls $KERNEL_DIRECTORY )
		echo $LINE
		echo "${S}Checking and updating kernel download directory names in ${C}$KERNEL_DIRECTORY${S}...${N}"
		if [ -n "$kernelDirs" ];then
			log_function_data "Updating: $kernelDirs"
			for kernelDir in $kernelDirs
			do
				echo "${SPACER}${S}Checking: ${C}$kernelDir${N}"
				normalizedDir=$( normalize_kernel_string $kernelDir )
				if [ "$normalizedDir" != "$kernelDir" ];then
					echo "${SPACER}${S}Moving: ${C}$kernelDir${S} to: ${C}$normalizedDir${N}"
					mv $KERNEL_DIRECTORY/$kernelDir $KERNEL_DIRECTORY/$normalizedDir
				else
					echo "${SPACER}${S}${C}$kernelDir${S} is ok...${N}"
				fi
			done
		fi
		set_sticky_prefs $prefId
	fi
	eval $LOGUE
}

###---------------------------------------------------------------------
### Handle kernel strings
###---------------------------------------------------------------------

# args: $1 string to be normalized. All internal script functions will use this syntax:
# 2.6.24.2.slh.2-sidux-686 / 2.6.24.2.slh.2-sidux-amd64
# because there is no way to know what will happen with  kernel naming (hopefully the long
# string will be dumped for a shorter more readable one ;-)
normalize_kernel_string()
{
	eval $LOGUS
	local kernelString=$1 processSlh='' oldSlh='' processedString='' kernelArch=''
	local slhSlicePoint=''
	local slhNew1=$( echo $kernelString | egrep '(2\.6\.[0-9]{2}-2\.6\.[0-9]{2}.*\.slh\.)' )
	local slhNew2=$( echo $kernelString | egrep '(2\.6\.[0-9]{2}-[0-9]{1,2}\.slh\.)' )
	local oldSlh=$( echo $kernelString | egrep '(-slh(64)?-)' )
	# first test for the new default .slh. syntax:
	if [ -n "$oldSlh" ];then
		oldSlh='true'
	elif [ -n "$slhNew1" ];then
		processSlh='true'
		slhSlicePoint=2
	elif [ -n "$slhNew2" ];then
		processSlh='true'
		slhSlicePoint=1
	fi

	if [ "$oldSlh" == 'true' -o "$processSlh" == 'true' ];then
		if [ "$processSlh" == 'true' ];then
			# 2.6.24-2.6.24.1.slh.3-sidux-amd64 2.6.24-2.6.24.1.slh.3-sidux-686
			# 2.6.25-2.slh.3-sidux-amd64 2.6.25-3.slh.3-sidux-686
			# slice out the part after 2.6.24-
			processedString=$( echo $kernelString | cut -d '-' -f $slhSlicePoint-6 )
		elif [ "$oldSlh" == 'true' ];then
			kernelArch=$( echo $kernelString | grep 'slh64'  )
			# set the kernel arch here
			if [ -n "$kernelArch" ];then
				kernelArch='amd64'
			else
				kernelArch='686'
			fi
			# this syntax is handled here
			# 2.6.23.15-slh-smp-3 2.6.23.15-slh64-smp-3
			processedString=$( echo $kernelString | sed -r 's/(-slh(64)?-(smp|up)-)/.slh./g' )
			processedString=$processedString'-sidux-'$kernelArch
		fi
	# do not process user custom or already processed strings at all
	else
		processedString=$kernelString
	fi

	echo $processedString
	log_function_data "processedString: $processedString"
	eval $LOGUE
}

# args: $1 - what to compare to kernel name; $2 - set-ke
test_kernel_strings()
{
	eval $LOGUS
	local normalizedCurrentKernel=$( normalize_kernel_string $CURRENT_KERNEL )
	local normalizedPackageId=$( normalize_kernel_string $1 )
	local value=''

	if [ "$normalizedCurrentKernel" == "$normalizedPackageId" ];then
		value='true'
	else
		value='false'
	fi
	# set the global, which will be used by various testing functions
	# or just echo the status true/false for functions that use that
	if [ "$2" == 'set-ke' ];then
		KERNEL_EQUAL_INSTALL=$value
	else
		echo $value
	fi
	log_function_data "value: $value"
	eval $LOGUE
}
#normalize_kernel_string $(uname -r);exit

###---------------------------------------------------------------------
### sticky script preferences:: preference file located: /etc/smxi.conf
###---------------------------------------------------------------------
sticky_prefs()
{
	eval $LOGUS
	local prefId='RememberResponses'
	local smPref=$( sm_pref_tester $prefId )

	if [ "$smPref" -eq 0 ];then
		echo $MLINE
		echo "${M}Creating your initial ${C}$SCRIPT_NAME${M} sticky preferences."
		echo "${C}$SCRIPT_NAME${S} remembers certain options that have been run"
		echo "so that they don't run more than once."
		echo "These settings are stored here: "${C}$SM_CONFIG_FILE
		echo
		echo "${S}To change the settings, either simply delete ${C}$SM_CONFIG_FILE${S}"
		echo "or delete the line of the item you want ${C}$SCRIPT_NAME${S} to run again.${N}"
		set_sticky_prefs $prefId
		print_hec
	fi
	eval $LOGUE
}

# args: $1, s/d, set the du data, or standard, set the sticky string in /etc/smxi.conf
set_sticky_prefs()
{
	eval $LOGUS
	check_sm_pref_file
	local currentDate=$( date +%Y-%m-%d-%H:%M )

	case $1 in
		s)	set_sm_pref_values "script-last-used" "$currentDate"
			;;
		d)	set_sm_pref_values "script-last-du-complete" "$currentDate"
			;;
		*)	echo $1 >> $SM_CONFIG_FILE
			sort_sticky_prefs
			;;
	esac
	eval $LOGUE
}

sort_sticky_prefs()
{
	local tempFile='/etc/ljsdflsjf5848sljf4'

	# sort the file, test/clean for unique entries, then mv to smxi.conf
	# note; you cannot write the file to itself in a one liner, it becomes null
	sort -f -b $SM_CONFIG_FILE | uniq > $tempFile
	mv -f $tempFile $SM_CONFIG_FILE
}

# args: $1 - pref name; $2 - pref value, eg: <name>=<value>
set_sm_pref_values()
{
	eval $LOGUS
	check_sm_pref_file
	local prefId="$1"
	local smPref=$( sm_pref_tester $prefId )

	if [ "$smPref" -eq 0 ];then
		echo "$1=$2" >> $SM_CONFIG_FILE
	else
		sed -i "s%$1=.*%$1=$2%" $SM_CONFIG_FILE
	fi
	sort_sticky_prefs
	eval $LOGUE
}

check_sm_pref_file()
{
	# make config fileif required
	if [ ! -f $SM_CONFIG_FILE ];then
		touch $SM_CONFIG_FILE
	fi
}
# args: $1 string to be tested for, returns 0 or > 0
# $2 - optional: custom test; default standard; equal slice out after =
sm_pref_tester()
{
	eval $LOGUS
	check_sm_pref_file
	local smPref='' testType='standard'

	if [ -n "$2" ];then
		testType=$2
	fi
	# since this is core, I am adding error detection to avoid hangs
	if [ -n "$1" ];then
		case $testType in
			equal) # return the string value, if present, after the =
				smPref=$( grep $1 $SM_CONFIG_FILE | cut -d '=' -f 2-8 )
				;;
			standard)
				smPref=$( grep -c $1 $SM_CONFIG_FILE )
				;;
			*)
				error_handler 'value-bad' $FUNCNAME "$testType"
				;;
		esac

		echo $smPref
		log_function_data "smPref: $smPref"
	else
		error_handler 'value-null' $FUNCNAME '$1'
	fi
	eval $LOGUE
}
#sm_pref_tester smxi-kernel-mirror equal;exit

###---------------------------------------------------------------------
### x  utilities
###---------------------------------------------------------------------

# select windows manager, currently only supports kdm, xdm, and gdm
start_windows_manager()
{
	eval $LOGPS
	local options='' opt=''

	echo $LINE
	echo "${C}1${S} - Starts your desktop, X (window manager)."
	echo "${C}2${S} - Exits the script without starting your window manager."
	echo $LINE
	echo "${Q}Would you like to start your window manager now?"
	echo -e $SLE
	echo $LINE

	options="start-desktop quit"
	select opt in $options
	do
		eval $LOGPE
		case $opt in
			start-desktop)
				print_completed 'noquit'
				start_stop_default_dm full start
				;;
			quit)
				print_completed
				;;
			*)
				print_error opt
				start_windows_manager
				;;
		esac
		break
	done

}

# arg: $1 - start/stop; $2 - stop/start
start_stop_default_dm()
{
	eval $LOGUS
	local displayManager=$( get_default_display_manager )
	local success=''
	local dmList='entrance gdm kdm slim wdm xdm' dm=''

	case $1 in
		full)
			if [ -z "$displayManager" ];then
				for dm in $dmList
				do
					if [ -x /etc/init.d/$dm ];then
						# nohup is required to make sure dm is fully stopped, and pids removed
						nohup /etc/init.d/$dm $2 && success='true'
						break
					fi
				done
			else
				# question: why is this in some cases not working? No init 5 is happening
				if [ -x /etc/init.d/$displayManager ];then
					# nohup is required to make sure dm is fully stopped, and pids removed
					nohup /etc/init.d/$displayManager $2 && success='true'
				fi
			fi
			# this handles cases where somehow X is still running
			# startx x starts can for example bypass kdm tests, etc
			if [ "$2" == 'stop' ];then
				if [ "$( x_is_running )" -eq 0 ];then
					echo "${M}Note: display manager shutdown failed... shutting down X directly instead...${N}"
					nohup killall Xorg
				fi
			fi
			;;
		nowmstart)
			success='true'
			;;
		killroot)
			if [ -n "$LOGIN_PID" ];then
				kill $LOGIN_PID && exit 0
			else
				echo "${E}No login Pid found to kill, exiting script.${N}"
				exit 0
			fi
			;;
	esac
	# only kill on dm start. Leaving init stuff for users who are using the init 3 -> 5
	# method, so they end up in their default runlevel as expected
	if [ "$success" == 'true' -a "$2" == 'start' ];then
		if [ -n "$LOGIN_PID" ];then
			init $INIT_LEVEL && kill $LOGIN_PID && exit 0
		else
			echo "${E}No login Pid found to kill. Exiting script without killing root session.${N}"
			init $INIT_LEVEL && exit 0
		fi
	fi
	eval $LOGUE
}

# get active pid for dm
do_display_manager_pid_test()
{
	eval $LOGUS
	local dmIdList='entrance/entranced.pid gdm.pid kdm.pid slim.lock wdm.pid xdm.pid' dmId='' found=''

	for dmId in $dmIdList
	do
		if [ -e /var/run/$dmId ];then
			found='true'
		fi
	done

	if [ "$( x_is_running )" -eq 0 ];then
		found='true'
	fi

	log_function_data "found: $found"
	eval $LOGUE
	if [ "$found" == 'true' ];then
		return 0
	else
		return 1
	fi
}

x_is_running()
{
	eval $LOGUS
	local returnVal=''
	# we'll do one final X is running test here, note, handling a bunch of
	# different possible X detections in etch, lenny, and sid, then filtering out the grep
	local xIsRunning=$( ps aux | grep '/usr.*/X' | egrep -ivc '(grep|/Xprt)' )

	if [ "$xIsRunning" -gt 0 ];then
		returnVal='0'
	else
		returnVal='1'
	fi
	echo $returnVal
	log_function_data "returnVal: $returnVal"
	eval $LOGUE
}
# keep the lists here synced, do dm pid, and below:
get_display_manager_runlevels()
{
	eval $LOGUS
	local displayManager=$( get_default_display_manager )
	local dmRunlevels=''

	if [ -n "$displayManager" ];then
		# we're only interested in the actual runlevels here
		dmRunlevels=$( ls /etc/rc*.d/S*$displayManager | sed -r 's%/etc/rc([1-5])\.d.*%\1%g' )
	fi
	echo $dmRunlevels
	log_function_data "dmRunlevels: $( echo $dmRunlevels)"
	eval $LOGUE
}

# just return the dm or null if missing
get_default_display_manager()
{
	eval $LOGUS
	local displayManager=$( cat /etc/X11/default-display-manager 2>/dev/null )

	displayManager=$( basename $displayManager 2>/dev/null )

	if [ "$displayManager" == 'entranced' ];then
		displayManager='entrance'
	fi

	echo $displayManager
	log_function_data "displayManager: $displayManager"
	eval $LOGUE
}

# must run after, not before first apt update/ dist-upgrade
# otherwise there is no policy set for xorg
test_xorg_version()
{
	eval $LOGUS
	local XorgIs='' xVersions='' xVersion1='' xVersion2=''

	if [ -f /var/lib/dpkg/status ];then
		# slice out the version numbers for these two, that way we can see if xorg
		# has been updated after the du runs
		xVersion1=$( check_package_status 'xserver-xorg' 'installed' )
		xVersion2=$( check_package_status 'xserver-xorg-core' 'installed' )
		xVersions="$xVersion1$xVersion2"

		case $1 in
			pre)
				X_VERSIONS_PRE=$xVersions
				;;
			post)
				X_VERSIONS_POST=$xVersions
				;;
			*)
				error_handler 'value-bad' $FUNCNAME "$1"
				;;
		esac
	fi
	log_function_data "xVersions: $xVersions"
	eval $LOGUE
}
## DEBUGGER
#script_debugger "test_xorg_version pre" 'echo "${S}Xorg Version: "${C}$X_ORG_VERSION_PRE${N}'

# for smxi launch in X
launch_from_X()
{
	if [ "$B_TESTING_1" == 'true' ];then
		if [ "$( tty | grep pts )" ];then
			TERM=linux
			exec openvt -s bash -c "smxi $@; bash"
		fi
	fi
}

########################################################################
### checks of various script / system requirements / connections / update script
###---------------------------------------------------------------------

# basic support tests
start_up_tests()
{
	# Make sure script is in path set in $SCRIPT_HOME
	check_script_path
	# check for correct user status. This script must run as root
	if [ "$(whoami)" != "root" ];then
		error_handler 'not-root' $FUNCNAME
	fi
	# no ubuntu support
	if [ "$( cat /etc/issue | grep -i -c 'buntu' )" -gt 0 -a ! -f "$EAX" ];then
		error_handler 'unsupported-distro' $FUNCNAME 'Ubuntu derived'
	fi
# 	if [ -e $EKV ];then
# 		error_handler 'unsupported-distro' $FUNCNAME 'Kanotix'
# 	fi
	if [ ! -e $ESV -a ! -e $EDV ];then
		error_handler 'unidentified-distro' $FUNCNAME ''
	fi

}

# this script must run out of x, and gives option to go into default runlevel on x start
check_display_and_x()
{
	eval $LOGPS
	# this fixes cases where the runlevel might give a 2 or 3 item result
	# first get count of items, then use that count to extract the last item
	local rlc=$( echo $( runlevel ) | wc -w ) response='' wmRunning='' facts=''
	local currentRunlevel=$( echo $(runlevel) | cut -d " " -f $rlc ) sleepTime=6
	local data1=${c2[4]}${c2[1]}${c2[8]}${c2[2]}${c2[0]}${c2[5]}
	local data2=${c2[7]}${c2[11]}${c2[3]}${c2[0]}${c2[10]}${c2[6]}${c2[9]}
	local defaultRunlevel=$( grep ':initdefault:' /etc/inittab | egrep -o '[0-5]' )
	local runlevelUse='' runlevelText='' runlevelText2='' runlevelText3=''
	local dmRunlevels=$( get_display_manager_runlevels )
	local dmRunlevelsCount=$( wc -w <<< "$dmRunlevels" )

	log_function_data "$dmRunlevels"
	if [ "$Z_SET" == "$data1$data2" ];then
		facts='true'
	fi

	# this checks for pid files for known display managers
	do_display_manager_pid_test && wmRunning='true'

	# forces update of script and restarts it
	check_force_update

	# this should handle most cases, now supports Debian default start of gdm/kdm in init 2
	if [ "$wmRunning" == 'true' -o -n "$DISPLAY" ] && [ "$facts" != 'true' ];then
		echo $WBAR
		echo "${W}Your ${C}X/Desktop (kde/gnome/xfce etc..)${W} must be shutdown to run this script."
		echo -e "${Q}Would you like to shutdown ${C}X/Desktop${Q} now?$YNE"
		echo $LINE
		read response
		eval $LOGPE
		case $response in
			y)
				echo "${S}Shutting down ${C}X/Desktop${S} now...${N}"
				start_stop_default_dm full stop
# 				if [ "$B_TESTING_1" == 'true' ]
# 				then
# 					# needs lots of debugging before can be tried with testers...
# 					launch_from_X
# 				fi
				unset wmRunning # reset to null from first test results
				do_display_manager_pid_test && wmRunning='true'

				if [ "$wmRunning" == 'true' ];then
					echo "${S}First shutdown attempt failed. Retrying display manager shutdown now...${N}"
					start_stop_default_dm full stop
				fi
				;;
			n)
				echo $LINE
				echo "${S}Exiting the script. Please run the script out of ${C}X/Desktop (kde/gnome/xfce etc..)${S}"
				echo
				echo "There are a few ways to start $SCRIPT_NAME out of X/Desktop:"
				echo "${C}1${S} - Logout of your desktop (or do this before you login), hit ${C}ctrl+alt+F1${S}."
				echo "    Then, in terminal/tty, login as root, and type: ${C}$SCRIPT_NAME${S}"
				echo "${C}2${S} - Hit ${C}ctrl+alt+F1${S}, and in tty/terminal login as root, and type: ${C}$SCRIPT_NAME${S}"
				echo "    ${S}This option makes you lose your current desktop session if you save your sessions."
				if [ "$dmRunlevelsCount" -eq 1 -a "$dmRunlevels" == '5' ];then
					echo "${C}3${S} - Boot your computer and just type ${C}3${S} when grub appears, and hit enter, then login as root."
				fi
				echo
				echo $WBAR
				exit 0
				;;
			*)
				print_error yn
				check_display_and_x
				;;
		esac
	fi
}
## DEBUGGER
#script_debugger check_display_and_x

# I was forced to do this more aggressively to fight off user error
check_script_path()
{
	eval $LOGUS
	local dufDir=$( dirname $0 )
	c2=( 'a' 'b' 'e' 'f' 'i' 'k' 'l' 'm' 'r' 't' 'u' 'y' )

	# protection against users who absolutely insist on not following the directions
	# on where to install smxi, move to /usr/local/bin no matter where they put it
	if [ "$dufDir" != $SCRIPT_HOME ];then
		# 2 cases: first, user is starting with ./ not in /usr/local/bin
		# 2: smxi is not in /usr/local/bin
		if [ "$dufDir" == '.' -a "$(pwd)" != $SCRIPT_HOME ] || [ "$dufDir" != '.' ];then
			echo $WLINE
			echo "${W}You must place ${C}$SCRIPT_NAME${W} in ${C}$SCRIPT_HOME${W}!!"
			echo $WLINE
			echo "${S}The script will move ${C}$SCRIPT_NAME${S} from where it was, ${C}$dufDir${S}"
			echo "to where it belongs: ${C}$SCRIPT_HOME/$SCRIPT_NAME${S}"
			echo "Please do not place this script in any other location!!!${N}"
			mv $dufDir/$SCRIPT_NAME $SCRIPT_HOME/$SCRIPT_NAME
			echo
			echo "${S}The script has now been moved to its correct location: ${C}$SCRIPT_HOME${N}"
			echo
			echo "${S}Because of how bash works, the script will exit your root session, then"
			echo "you need to log in again or bash will keep looking for ${C}$SCRIPT_NAME${S}"
			echo "in its previous incorrect location: ${C}$dufDir${N}"
			print_hec
			echo "${S}Exiting root session now... please log back in and run script again."
			echo "${M}Remember: you do not need to type in the full path, just the script name.${N}"
			kill $LOGIN_PID && exit 1
		fi
	fi
	# then go on to cd
	if [ "$( pwd )" != "$SCRIPT_HOME" ];then
		cd $SCRIPT_HOME
	fi
	eval $LOGUE
}

# test for sidux or conversion type system
# start_up_tests now checks for non-supported distros and levels
check_distro_version()
{
	eval $LOGPS
	local distroName=' current distro' i='' dis='' temp1=''
	# note: pre 2008-06 conversions are now version 8 by default
	# post 2008-06 conversions will carry id set dynamically by time check
	local supportedReleases=( 'sidux(64)? 2009-04^17' 'sidux(64)? 2009-03^16' 'sidux(64)? 2009-02^15' 'sidux(64)? 2009-01^14' 'sidux(64)? 2008-04^13' 'sidux(64)? 2008-03^12' 'sidux(64)? 2008-02^11' 'sidux(64)? 2008-01^10' 'sidux(64)? 2007-04^9' 'sidux(64)? 2007-03^8' 'sidux(64)? 2007-02^7' 'sidux(64)? 2007-01^6' 'sidux^8' )

	# handles conversion cases for all future use
	if [ -f $SMDL ];then
		DISTRO_LEVEL=$( cat $SMDL )
		# if [ -f $SMDV ]
# 		if [ -f /etc/issue ]
# 		then
# 			# DISTRO_VERSION=$( cat $SMDV )
# 			DISTRO_VERSION=$( cat /etc/issue )
		if [ -f $EDV ];then
			DISTRO_VERSION=$( cat $EDV )
		elif [ -f $SMDV ];then
			DISTRO_VERSION=$( cat $SMDV )
		else
			DISTRO_VERSION='Unknown, Error in distro ID'
		fi
	elif [ -f $ESV ];then
		DISTRO_VERSION=$(cat $ESV)
		## Array logic stuff since this is not really human readable:
		# ${#supportedReleases[@]} is the array count
		# ${supportedReleases[$i]%^*} is the first item split by ^
		# ${supportedReleases[$i]#*^} is the second item split by ^
		#
		# more on loops: http://tldp.org/LDP/abs/html/loops1.html
		# more on arrays: http://tldp.org/LDP/abs/html/arrays.html
		#
		# supported versions search for string in array, if matched, set distro level
		# NOTE: default for DISTRO_LEVEL is 0
		for (( i=0; i < ${#supportedReleases[@]}; i++ ))
		do
			dis=$( echo $DISTRO_VERSION | egrep -i "${supportedReleases[$i]%^*}" )
			if [ -n "$dis" ];then
				DISTRO_LEVEL=${supportedReleases[$i]#*^}
				break
			fi
		done
	# run debian conversion options only if no id files for s/k present
	# non supported tests have already been run in  start_up_tests
	elif [ ! -f $ESV -a -e $EDV ];then
		set_distro_data # need to set this here to avoid small detection errors
		run_script_import $LIB_DISTRO_CONVERSION
		check_debian
	fi
	log_function_data "DISTRO_LEVEL: $DISTRO_LEVEL"
	log_function_data "DISTRO_VERSION: $DISTRO_VERSION"
	eval $LOGPE
}
## DEBUGGER
#script_debugger check_distro_version 'echo dl: $DISTRO_LEVEL' 'DISTRO_VERSION="sidux 2007-04"'

# this will check the age of the script from it date and compare that to the current date
# if the age is greater than $MAX_AGE it will stop execution
check_age()
{
	eval $LOGPS
	local ScriptDate=$( grep -o -G -m 1 "Date: [A-Za-z\ 0-9]*" $SCRIPT_HOME/$SCRIPT_NAME | grep -m 1 -o -G "\ [A-Za-z\ 0-9]*" )
	local ScriptYear=$( date -d "$ScriptDate" +%Y )
	local ScriptDay=$( date -d "$ScriptDate" +%-j )
	local CurrentDay=$( date +%-j )
	local CurrentYear=$( date +%Y )
	local NextYear=$(( $ScriptYear + 1 ))
	local TooOld='' Diff=''

	if [ $ScriptYear -eq $CurrentYear ];then
		Diff=$(( $CurrentDay - $ScriptDay ))
		if [ $Diff -gt $MAX_AGE ];then
			TooOld='true'
		fi
	elif [ $CurrentYear -eq $NextYear ];then
		Diff=$(( $CurrentDay + 365 - $ScriptDay ))
		if [ $Diff -gt $MAX_AGE ];then
			TooOld='true'
		fi
	else
		TooOld='true'
	fi

	if [ "$TooOld" == "true" ];then
		error_handler smxi-version-too-old $FUNCNAME
	fi
	eval $LOGPE
}

# makes sure that there is a connection, especially for kernel install wifi restarts
check_connection()
{
	eval $LOGPS
	local repeat='' connection='' options='' opt=''
	local UserAgent='Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1'

	if [ "$SKIP_CONNECTION_RETRY" != 'true' ];then
		echo $BAR
		echo "${S}Testing internet connection....${N}"
		# ping is a problem when there is no connection, takes too long to time out
		#ping -c 1 -W 2 google.com &>/dev/null && connection=1 || connection=0
		wget -T 7 -t 1 -q --spider http://www.google.com/ && connection=1 || connection=0

		# some US ISPs block ping, so do backup tests if that's the case
		if [ "$connection" -eq 0 ];then
			echo "${E}test 1 failed, trying test 2....${N}"
			wget -T 12 -t 1 -q --spider http://www.google.com/ && connection=1 || connection=0
			if [ "$connection" -eq 0 ];then
				echo "${E}test 2 failed, trying test 3....${N}"
				wget -T $TIME_OUT -t 1 -q --spider http://www.ebay.com/ && connection=1 || connection=0
			fi
		fi
	else
		echo $WBAR
		echo "${W}Skipping internet connection check.${N}"
		connection=0
	fi

	if [ "$connection" -eq 0 ];then
		# restart connection just in case
		if [ "$CONNECTION_RETRY" == '' ];then
			restart_networking
			repeat='true'
		else
			repeat=''
			echo "${W}No connection to the internet seems to be available.${N}"
			echo $LINE
			echo "${C}1${S} - Continue without an internet connection."
			echo "    This will let you do some cleanup type functions, and some system tests."
			echo "    And in case you unplugged your network cable by accident, this is a good time"
			echo "    to check that too. And make sure your router or other networking gear is working."
			echo "${C}2${S} - Install Wireless modules. If you just did a kernel install and you"
			echo "    have lost your wireless internet connection, you probably need to reinstall"
			echo "    your wireless modules. Current choices are: ${C}ipw394 linux-wlan-ng"
			echo "    madwifi ndiswrapper rt2500 rt2570 rt61${S}"
			echo "    This option will give you a menu of which module to install now."
			echo "    If you are using some other module, and are not able to connect, sorry."
			echo
			echo "${C}3${S} - Quit the script now."
			echo $LINE
			echo $SLE
			echo $LINE

			options="continue-no-connection install-wireless-modules quit"
			select opt in $options
			do
				log_function_data "Internet connection missing"
				eval $LOGPE
				case $opt in
					continue-no-connection)
						echo $LINE
						echo "${E}Continuing without an internet connection."
						echo "The script will skip the steps that require a connection.${N}"
						SKIP_CONNECTIONS='true'
						TIME_OUT=1 # this avoids eternal time out waits which aren't required
						;;
					install-wireless-modules)
						echo $LINE
						echo "${S}Running the wifi module installer now.${N}"
						# we need no-download here to handle no connections
						run_script_import $LIB_KERNEL no-download
						install_wireless_modules
						;;
					quit)
						print_quit
						;;
					*)
						print_error opt
						repeat='true'
						;;
				esac
				break
			done
		fi
	else
		log_function_data "Internet connection present"
		echo "${S}Internet connection is present and working.${N}"
		eval $LOGPE
	fi

	if [ "$repeat" == 'true' ];then
		check_connection
	fi
}

restart_networking()
{
	eval $LOGUS
	local RestartNetworking='/etc/init.d/networking restart' response=''

	echo $WLINE
	echo "${W}Connection failed, sorry."
	echo $WLINE
	echo "${S}Would you like to try to restart your networking in case that is the"
	echo "problem? If you just installed a new kernel and you use wifi you probably need"
	echo "to reinstall your wifi modules, but this step won't hurt, though it takes"
	echo "a while to complete the full restart tests if no connection is working."

	echo -e "${Q}Would you like to run ${C}$RestartNetworking${Q}?$YNE"
	echo $LINE
	read response

	case $response in
		y)	echo "${C}$RestartNetworking${S} is being run to make sure your connection just didn't drop.${N}"
			/etc/init.d/networking restart
			echo "${S}Test completed, now the script will test your connection again and run.${N}"
			CONNECTION_RETRY='true'
			;;
		n)	echo "${S}Ok, continuing without running ${C}$RestartNetworking${S}."
			echo "This will take you to the wifi module install questions."
			CONNECTION_RETRY='true'
			SKIP_CONNECTION_RETRY='true'
			;;
		*)	restart_networking
			print_error yn
			;;
	esac
	log_function_data "CONNECTION_RETRY: $CONNECTION_RETRY"
	log_function_data "SKIP_CONNECTION_RETRY: $SKIP_CONNECTION_RETRY"
	eval $LOGUE
}
## DEBUGGER
#script_debugger check_connection

# will force update of script
check_force_update()
{
	if [ "$FORCE_UPDATE" == 'true' ];then
		echo $EBAR
		echo "${E}Updating script now...${N}"
		update_scripts $SCRIPT_NAME 'chm'
		if [ "$?" -eq 0 ];then
			echo "${E}Restarting script...${N}"
			$SCRIPT_HOME/$SCRIPT_NAME -r$START_OPTIONS
			exit 0
		else
			error_handler force-update-failed $FUNCNAME "$?"
		fi
	fi
}

# checks techpatterns for latest version, compares it to current version
# downloads, installs, and restarts if required
check_version()
{
	eval $LOGPS
	local response='' existsNewer=''
	local LocalVersion=$( grep -m 1 -o -G "version:\ [0-9].[0-9]*.[0-9]*" $SCRIPT_HOME/$SCRIPT_NAME | grep -o -G "[0-9].[0-9]*.[0-9]*" )

	# if the remote version is greater/less, then this returns 0, 1 for equal
	# 0 means get latest, 1 means don't
	test_version_info $SCRIPT_NAME chm
	existsNewer="$?"
	CHECK_VERSION_TEXT="$BAR
${S}Checking for the latest version of this script${N}
$LINE
${S}Script Last Modified: ${C}$REMOTE_DATE${N}
${S}Local Version: ${C}$LocalVersion
${S}Remote Version: ${C}$REMOTE_VERSION"

	if [ "$REMOTE_VERSION" == "$LocalVersion" -a "$FORCE_DOWNLOAD" != 'true' ];then
		CHECK_VERSION_TEXT="$CHECK_VERSION_TEXT
$LINE
${S}You are using the latest version of this script.${N}"
	elif [ "$existsNewer" -eq 0 -o "$FORCE_DOWNLOAD" == 'true' ];then
		echo "$CHECK_VERSION_TEXT"
		if [ "$FORCE_DOWNLOAD" == 'true' ];then
			echo "${E}Forcing reinstall of local version.${N}"
			update_scripts $SCRIPT_NAME 'chm'
		else
			echo "${S}The versions are different.${N}"
		fi
		echo "${S}The script will now install the remote version"
		echo "and restart this script using the new version${N}"

		# run the script again, using the newly downloaded script
		echo "${S}Restarting Now.........${N}"
		# restart with full args, append all start options except f and r to -r
		./$SCRIPT_NAME -r$START_OPTIONS
		exit 0
	fi
	eval $LOGPE
}
## DEBUGGER
#script_debugger check_version

check_dpkg_update()
{
	eval $LOGUS
	local dpkguf='/var/cache/apt/pkgcache.bin'

	if [ -f $dpkguf ];then
		DPKG_UPDATE=$( ls -l --time-style=+%Y-%m-%d-%H:%M $dpkguf | egrep -o "20[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}:[0-9]{2}" )
	else
		DPKG_UPDATE="${W}No update file found - Unmodified Install"
	fi
	log_function_data "DPKG_UPDATE: $DPKG_UPDATE"
	eval $LOGUE
}

# returns driver or null if no nonfree used
# args: $1 - kernel-install/xorg/kernel
nonfree_driver_reinstall()
{
	eval $LOGUS
	local isNvidia=$( egrep -sio 'Driver.*"nvidia"' $X_ORG_PATH | cut -d '"' -f 2 )
	local isFglrx=$( egrep -sio 'Driver.*"fglrx"' $X_ORG_PATH | cut -d '"' -f 2 )
	local driverIs='' xorgMessage='' kernelMessage='' reinstallMessage='' message=''

	if [ -n "$isNvidia" ];then
		driverIs='nVidia'
	fi
	if [ -n "$isFglrx" ];then
		driverIs='ATI/fglrx'
	fi

	log_function_data "Non-Free driver data: $driverIs"

	if [ -n "$driverIs" ];then
		reinstallMessage="${M}You will need to reinstall your ${C}$driverIs${M} driver in Graphics Install.\n$MLINE"
		kernelMessage="${M}Your kernel was upgraded to ${C}$KERNEL_INSTALL_TO${M}\n"
		xorgMessage="${C}Xorg${M} was upgraded in this $DU_UPGRADE.\n"
		case $1 in
			kernel-install)
				message="$driverIs"
				;;
			kernel)
				if [ -n "$KERNEL_INSTALL_TO" ];then
					message="$kernelMessage$reinstallMessage"
				fi
				;;
			xorg)
				test_xorg_version 'post' # make sure it's set properly no matter what
				if [ "$X_VERSIONS_PRE" != "$X_VERSIONS_POST" ];then
					message="$xorgMessage$reinstallMessage"
				fi
				;;
			kernel-xorg)
				if [ -n "$KERNEL_INSTALL_TO" ];then
					message="$kernelMessage"
				fi
				test_xorg_version 'post' # make sure it's set properly no matter what
				if [ "$X_VERSIONS_PRE" != "$X_VERSIONS_POST" ];then
					message="$message$xorgMessage"
				fi
				if [ -n "$message" ];then
					message="$message$reinstallMessage"
				fi
				;;
		esac
	fi
	log_function_data "message: $message"
	if [ -n "$message" ];then
		echo -e "$message"
	fi
	eval $LOGUE
}

########################################################################
### information / output type stuff, utilities
###---------------------------------------------------------------------

# args: $1 - y/n; yno; opt; user (from custom hec user settings)
# $2 - extra argument, optional
print_error()
{
	eval $LOGUS
	echo $EBAR
	case $1 in
		yn)
			echo "${E}You must enter ${C}y${E} to run this option, or ${C}n${E} to reject it."
			echo "Please make sure that you enter either ${C}y${E} or ${C}n${E}, lower case, thanks.${N}"
			;;
		yno)
			echo "${E}You must enter ${C}y${E} to run this option, ${C}n${E} to reject it,"
			echo "or ${C}$2${E} to execute the optional feature."
			echo "Please make sure that you enter ${C}y${E}, ${C}$2${E}, or ${C}n${E}, lower case, thanks.${N}"
			;;
		opt)
			echo "${E}======= Error: please enter one of the numbers in the list =======${N}"
			;;
		user)
			echo "${E}======= Error: please press the ${C}$2${E} to continue ===========${N}"
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	echo $EBAR
	eval $LOGUE
}

# args: $1 lib file
print_lib_info()
{
	eval $LOGUS
	local scriptText='' printIt=''
	local scriptVersion=$( egrep -o -m 1 "(version:).*" $SCRIPT_HOME/$1 | cut -d ' ' -f 2 )
	local scriptDate=$( egrep -o -m 1 '(Date:).*' $SCRIPT_HOME/$1 | cut -d ' ' -f 2-4 )

	case $1 in
		$LIB_CLEAN_UP)
			scriptText='CLEAN UP OPTIONS'
			printIt='true'
			;;
		$LIB_DISTRO_CONVERSION)
			scriptText="SMXI DISTRO OPTIONS"
			printIt='true'
			;;
		$LIB_GRAPHICS)
			scriptText='GRAPHICS QUESTION'
			printIt='true'
			;;
		$LIB_KERNEL)
			scriptText='KERNEL QUESTION'
			printIt='true'
			;;
		$LIB_KERNEL_INSTALL)
			scriptText='KERNEL INSTALL'
			printIt='true'
			;;
		$LIB_MISC_TWEAKS)
			scriptText='MISCELLANEOUS TWEAKS'
			printIt='true'
			;;
		$LIB_PACKAGE_INSTALL)
			scriptText='PACKAGE INSTALL'
			printIt='true'
			;;
		$LIB_PACKAGE_REMOVAL)
			scriptText='PACKAGE REMOVAL'
			printIt='true'
			;;
# 		$MOD_GFX)
# 			scriptText='TEST GFX INSTALLER'
# 			printIt='true'
# 			;;
# 		$LIB_WARNING)
# 			scriptText='WARNING SECTION'
# 			printIt='true'
# 			;;*)
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	# script information
	if [ "$printIt" == 'true' ];then
		echo $MBAR
		echo "${M}$scriptText ${S}:: Module Version: ${C}$scriptVersion${S} :: Last Updated: ${C}$scriptDate${N}"
	fi
	log_function_data "$scriptText :: Module Version: $scriptVersion :: Last Updated: $scriptDate"
	eval $LOGUE
}

print_version()
{
	eval $LOGUS
	local distroThanks='crust devil dutchy kelmo latino locsmif paleoflatus piper slh trash80 x-un-i webera zulu9'
	local extraMessage="...and welcome Debian users, hope you enjoy $SCRIPT_NAME..."
	local item=''
	# only for -v option printout
	local scriptVersion=$( egrep -o -m 1 "(version:).*" $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2 )
	local scriptDate=$( egrep -o -m 1 '(Date:).*' $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2-4 )
	local systemBase=$( perl -wp -e '$_ = ucfirst' <<< $SYSTEM_BASE )
	local distroId=$( print_distro_id )

	case $DISTRO in
		sidux)
			distroThanks='crust devil dutchy etorix kelmo latino locsmif piper slh webera x-un-i zulu9'
			extraMessage='...and of course, RazberrieTart, the official sidux fan girl!'
			;;
		antix)
			distroThanks='anticapitalista crust dutchy eriefisher kelmo latino masinick slh trash80 zulu9'
			extraMessage='...and a welcome to AntiX users. Hope the script works for you as expected...'
			;;
	esac

	if [ "$PRINT_VERSION" != 'true' ];then
		echo $LINE
		echo "${S}Special thanks to the people who have helped with this script, in one way or another:"
		sleep 0.1
		echo -n ${C}
		for item in $distroThanks
		do
			echo -n $item' '
			sleep 0.10
		done
		echo
		for item in $extraMessage
		do
			echo -n $item' '
			sleep 0.06
		done
		echo ${N}
	else
		echo $MLINE
		echo " ${M}$SCRIPT_NAME${S} :: version: ${C}$scriptVersion${S} :: last updated: ${C}$scriptDate"
	fi
	echo $LINE
	echo "${S}Your installed version of ${C}Debian $systemBase${S} is: ${C}$distroId${N}"
	log_function_data "Installed version of Debian $systemBase is: $distroId"
	eval $LOGUE
}
## DEBUGGER
#script_debugger print_version '' ''

# note, this runs after the set 64 bit stuff, and uses some variables set it that function
print_install_information()
{
	eval $LOGPS
	local AdvancedOptions=''
	local dpkgUpdate='' dpkgInstall=''
	local rootHomeData="$( df -h -T | egrep '(/|/boot|/var|/home)$'  | S=${S} C=${C} awk '{print $7, ENVIRON["S"]" - ", "Type:"ENVIRON["C"], $2, ENVIRON["S"]"Size:"ENVIRON["C"], $3, ENVIRON["S"]"Used:"ENVIRON["C"], $4, ENVIRON["S"]"("ENVIRON["C"], $6, ENVIRON["S"]")", "Free:"ENVIRON["C"], $5}' )"
	local latestKernel='NO KERNEL DATA'
	if [ -n "$CURRENT_APT_KERNEL" ];then
		latestKernel=$( normalize_kernel_string $CURRENT_APT_KERNEL )
	fi
	local currentKernel=$( normalize_kernel_string $CURRENT_KERNEL )
	local dpkgif='/var/lib/dpkg/status'
	local ScriptLastRun=$( sm_pref_tester script-last-used equal )
	if [ "$ScriptLastRun" == '' ];then
		ScriptLastRun='Last script use date not yet set'
	fi
	local ScriptLastDu=$( sm_pref_tester script-last-du-complete equal )
	if [ "$ScriptLastDu" == '' ];then
		ScriptLastDu='Last script d-u not yet set'
	fi

	if [ -f $dpkgif ];then
		dpkgInstall=$( ls -l --time-style=+%Y-%m-%d-%H:%M $dpkgif | egrep -o "20[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}:[0-9]{2}" )
	else
		dpkgInstall="${W}No packages have been upgraded - Unmodified Install"
	fi
	# this keeps the check_version output together with the system version output
	# note that for -v output, $CHECK_VERSION_TEXT is not set yet
	if [ -n "$CHECK_VERSION_TEXT" ];then
		echo "$CHECK_VERSION_TEXT"
	fi
	print_version

	echo "${S}Operating system: ${C}$BITS bit${S}"
	echo "${S}Your CPU is: ${C}$CPU_NAME"
	echo "${S}File System Information:"
	echo "${C}$rootHomeData"
	echo $LINE
	echo "${S}Your current kernel version is:       ${C}$currentKernel"
	if [ "$PRINT_VERSION" != 'true' ];then
		echo -e "${S}The latest kernel for your system is: ${C}$latestKernel${N}"
	fi
	echo $LINE
	echo "${S}Last $APT_TYPE package database update: ${C}$DPKG_UPDATE${S}"
	echo "${S}Last $APT_TYPE package install or upgrade: ${C}$dpkgInstall${S}"
	echo "${S}Last use of $SCRIPT_NAME: ${C}$ScriptLastRun${S}"
	echo "${S}Last $DU_UPGRADE using $SCRIPT_NAME: ${C}$ScriptLastDu${S}"
	echo $LINE
	echo "${S}If something scrolls by in the script before you can read it, you can move up or down"
	echo "in your terminal window by hitting ${C}Shift + Page Up${S} or ${C}Page Down${S}.${N}"
	log_function_data "Operating system: $BITS bit"
	log_function_data "CPU: $CPU_NAME"
	log_function_data "File System Info: $rootHomeData"
	log_function_data "Current kernel version: $currentKernel"
	log_function_data "Latest kernel: $latestKernel"
	log_function_data "Last package database update: $DPKG_UPDATE"
	log_function_data "Last package install or upgrade: $dpkgInstall"
	log_function_data "Last use of $SCRIPT_NAME: $ScriptLastRun"
	log_function_data "Last $DU_UPGRADE using $SCRIPT_NAME: $ScriptLastDu"
	if [ "$PRINT_VERSION" != 'true' ];then
		print_hec
	fi
	eval $LOGPE
}
## DEBUGGER
#script_debugger print_install_information

# this is the hit enter to continue blurb...
print_hec()
{
	local response='' key='enter' printHec='' readArgs=''

	if [ "$SKIP_ENTER" != 'true' ];then
		# this lets user set any string or spacebar to make hec add whatever they want
		# only execute this one time during smxi run to avoid repeated conf file queries
		if [ -z "$HEC_ALT" ];then
			# slice out the user set value
			HEC_ALT=$( sm_pref_tester 'alt-print-hec' 'equal' )
			# set so this doesn't run again
			if [ -z "$HEC_ALT" ];then
				HEC_ALT='false'
			fi
		fi
		# set the default key string value if needed
		if [ "$HEC_ALT" != 'false' ];then
			key=$HEC_ALT
			if [ "$HEC_ALT" == "any" ];then
				key="$HEC_ALT key"
			fi
			if [ "$HEC_ALT" != "enter" ];then
				readArgs='-n 1'
			fi
		fi
		printHec="${Q}Please hit ${C}$key${Q} to continue${N}"

		echo $LINE
		# halt the script so people can read the advice
		echo $printHec
		echo $LINE
		read $readArgs response
		echo # needed because of -n 1 in read
		if [ "$response" != "$HEC_ALT" -a "$HEC_ALT" != 'false' -a "$HEC_ALT" != "any" -a "$HEC_ALT" != "enter" ];then
			print_error user $HEC_ALT
			print_hec $1
		fi
	fi
}

print_distro_id()
{
	eval $LOGUS
	# Note: $EDV is the default if all else fails
	local knownDistroIds="$ESV $EAX $EDI $SMDV $EDV"
	local distroFile='' distroId=''

	for distroFile in $knownDistroIds
	do
		if [ -f $distroFile ];then
			# print first line, for cases where > 1 line exist in file
			distroId=$( sed -n '1p' $distroFile )
			break
		fi
	done
	# this should never happen but it's here just to future proof it a bit
	if [ -z "$distroId" ];then
		distroId='Unknown Distro'
	fi

	echo $distroId
	log_function_data "distroId: $distroId"
	eval $LOGUE
}

# trigger function for X loaded updates and viewing, or user viewing
# args: $1 - which view mode: c = configs; w = warnings; cw = both
print_update_warning_configs()
{
	local startArgs='print'
	local updateRootMessage="Remember, to update this live, use ${C}-W${S} option as root."

	# need to set the correct config files for user system here
	set_distro_data
	cd $SCRIPT_HOME

	echo $MLINE
	echo "${M}$SCRIPT_NAME Warning/Config Data"
	echo $MLINE
	if [ "$(whoami)" == "root" ];then
		echo "${S}Since you are logged in as root, the warning/config data will be updated live.${N}"
		startArgs='print-root'
		echo $LINE
		update_scripts $VERSION_INFO # get the version info data file
		updateRootMessage=''
	else
		echo "${S}Since you are not logged in as root, the last available warning data will be used.${N}"
		echo $LINE
	fi

	# this will allow user to use current version of warnings if not root
	run_script_import $LIB_WARNING
	if [ ! -f $LIB_WARNING ];then
		error_handler 'missing-lib-fatal' $FUNCNAME $LIB_WARNING
	else
		case $1 in
			c)
				echo "${S}Here is the $DU_UPGRADE config data:"
				echo $LINE
				get_configs $startArgs
				;;
			w)
				print_alert_warning_data $startArgs
				echo $LINE
				;;
			cw|wc)
				print_alert_warning_data $startArgs
				print_hec
				echo "${S}Here is the $DU_UPGRADE config data:"
				echo $LINE
				get_configs $startArgs
				;;
		esac

		echo "${S}End of warning/config data. $updateRootMessage"
		echo $LINE
	fi
}
# print_hec ;echo helloworld; echo yes indeed; exit
# last step in smxi
# args: $1: optional, noquit
print_completed()
{
	eval $LOGUS
	echo
	echo $MBAR
	echo "${M}==== Ok, you are done with the system upgrade. Hope it works. ===="
	echo $MBAR
	echo
	eval $LOGUE
	if [ "$1" != 'noquit' ];then
		exit 0
	fi
}
print_quit()
{
	eval $LOGUS
	echo $LINE
	echo "${S}OK, have a good day, thanks for using this script.${N}"
	echo $LINE
	eval $LOGUE
	exit 0
}

########################################################################
### apt / dpkg tools: update/install/mirror switchers: sm-lib-apt-tools
###---------------------------------------------------------------------

# HANDLED BY EXTERNAL LIBARARY FILE sm-lib-apt-tools

########################################################################
### Kernel Stuff: sm-lib-kernel sm-lib-kernel-install
###---------------------------------------------------------------------

# HANDLED BY EXTERNAL LIBRARY FILE sm-lib-kernel
# -- sm-lib-kernel-install - submodule of sm-lib-kernel
# -- handles actual kernel selection and install

########################################################################
### upgrade warning system: sm-lib-warning
###---------------------------------------------------------------------

# HANDLED BY EXTERNAL LIBARARY FILE sm-lib-warning

########################################################################
### Main Dist-Upgrade stuff, pre-du, du, and post-du
###---------------------------------------------------------------------

pre_du_tasks()
{
	eval $LOGMS
	# begin update tasks
	apt_update_handler 'pre-du'

	echo $LINE
	echo "${S}Running assorted tasks to prepare for the system $DU_UPGRADE...${N}"
	if [ "$SYSTEM_BASE" != 'stable' -a "$SYSTEM_BASE" != 'etch' ];then
		set_hold_install hold

		# RUN FIRST CRITICAL FIXES. Must run before other fixes to avoid errors in apt
		# generally, these are fixes for kernels, core libs etc, that a new kernel might
		# make needed, like libncurses, libc6, and so on.
		if [ "$DISTRO_LEVEL" -lt 14 ];then
			libc6_fix_1 'pre-du' # ongoing fix, update as needed
		fi
		# load the 2007 fixes
		if [ "$DISTRO_LEVEL" -lt 10 ];then
			run_script_import $LIB_2007_FIXES
			run_2007_fixes 'pre'
		fi
	fi
	# set xorg version pre upgrade, either unset or like 6. or 7. etc
	test_xorg_version pre
	# load the 2008 fixes
	if [ "$DISTRO_LEVEL" -lt 14 ];then
		run_script_import $LIB_2008_FIXES
		run_2008_fixes 'pre'
	fi

	echo $LINE
	echo "${S}Finished with the pre-upgrade tasks.${N}"

	eval $LOGME
}

# main dist-upgrade/ update etc function
install_dist_upgrade()
{
	eval $LOGMS
	local prefId='du-connection-drop-1'
	local smPref=$( sm_pref_tester $prefId )
	local continue='' repeat='' options='' opt='' ConnectionDropped=''
	local exitStatus=$2 # only for script re-runs, $2 not set first time
	local metaExists=$( package_tester 'linux-image-2.6-(sidux-|)' 'wild-full' )
	local currentAptKernelGrub=$( grep -i -o -m1 "$CURRENT_APT_KERNEL" $GRUB_PATH )
	local exitNo='' rebootNo='' rebootText='' rebootTopText=''
	local options="use-install-f $DU_UPGRADE-again check-services continue "

	# set the trap here
	trap 'du_trap_handler $FUNCNAME' INT TERM

	options="$options exit"
	exitNo=$( echo $options | wc -w )
	# this prints one time, until the first full du is done, will be updated to be more useful.
	# obsolete, but I'll keep it in case I need to flash some version specific du message.
	if [ "$smPref" -eq 0 ];then
		if [ "$DISTRO_LEVEL" -lt 2 ];then
			ConnectionDropped='echo -e "${W}After your $DU_UPGRADE you may lose your network connection.${S}\nIf this happens some parts of the script will not work. To fix this,\nsimply restart the script, and it will restart your connection for you\nif there is no connection present.\n$LINE"'
		fi
	fi

	# only do this part the first time the function runs
	if [ "$1" == "first" ];then
		# run an assortment of pre du stuff, update scripts, keyrings, fixes, etc
		pre_du_tasks
		echo $MBAR
		echo "${M}BEGINNING DIST-UPGRADE"
		echo $MLINE
		eval $ConnectionDropped
		# note: because the file may not be current or loaded, do not run this if if no warning
		if [ "$SKIP_WARNING" != 'true' ];then
			get_configs # print out any keep config stuff
		fi
		echo "${S}Make sure your $DU_UPGRADE goes all the way through"
		echo "If it exits with errors select one of the following options:"
		echo "${C}2${S} - for doing ${C}$DU_UPGRADE${S} again. Try the ${C}2${S} option first."
		echo "${C}1${S} - for ${C}$APT_TYPE install -f${S}. Only select ${C}1${S} if ${C}2${S} returns errors"
		echo "That will force apt to install the parts that returned errors."

		# small cosmetic, to avoid printing double line with print-hec
		if [ "$SKIP_ENTER" == 'true' ];then
			echo $LINE
		fi
		print_hec
		$APT_TYPE $WITHOUT_RECOMMENDS $DU_UPGRADE 2>>$LOG_FILE 2>&1
		exitStatus=${PIPESTATUS[0]}
		apt_error_handling du-1 $exitStatus
	fi

	if [ "$exitStatus" -eq 0 ];then
		echo $MLINE
		echo "${M}Your $DU_UPGRADE appears to have completed with no errors."
		echo "${S}You can continue on safely to do the rest of the script now."
		echo
		echo "It does not hurt to run ${C}$DU_UPGRADE-again${S} [option ${C}2${S}] once after a"
		echo "successful $DU_UPGRADE just to make sure things are fine though."
	else
		echo $EBAR
		echo "${E}Your $DU_UPGRADE is reporting errors!"
		echo $EBAR
		echo "${S}Please make sure to do the following to correct the errors reported:"
		echo "${C}$APT_TYPE install -f ${S}[option ${C}1${S}] - Use this first if you got errors!"

		echo
		echo "Run the ${C}$DU_UPGRADE-again${S} [option ${C}2${S}] to make sure the $DU_UPGRADE completes."
		echo "If errors do not get resolved, you'll need to get help from sidux irc or the forums."
		echo
		echo "${M}NOTE: Please run ${C}1${M} and ${C}2${M} as many times as necessary to get rid of the errors."
		echo "${S}Make sure to write down the package error in the $DU_UPGRADE messages."
		echo
		echo "Once you are sure the upgrade is done, you can continue, check services, or exit."
	fi

	# if current kernel was not in grub prior to du, and is in grub post du
	# metapackage users need this alert because otherwise they might not even
	# realize a new kernel installed. Regular kernel users of course don't need
	# to see this information since they know they installed one, and the post kernel
	# install step gives them all the information they need.
	if [ "$currentAptKernelGrub" != "$CURRENT_APT_KERNEL_GRUB" -a -n "$metaExists" -a -n "$currentAptKernelGrub" ];then
		options="$options reboot"
		rebootNo=$( echo $options | wc -w )
		rebootTopText='echo -e "${M}You are using ${C}kernel metapackages${M} and your ${C}$DU_UPGRADE${M} installed a new kernel.\nYour new ${C}$CURRENT_APT_KERNEL${M} kernel will not become active until you reboot.\n$MLINE"'
		rebootText='echo -e "${C}$rebootNo - reboot${M} Reboot into your new ${C}$CURRENT_APT_KERNEL${M} kernel."'
		KERNEL_INSTALL_TO=$CURRENT_APT_KERNEL
	fi
	log_function_data "currentAptKernelGrub: $currentAptKernelGrub"
	log_function_data "CURRENT_APT_KERNEL_GRUB: $CURRENT_APT_KERNEL_GRUB"
	log_function_data "metaExists: $metaExists"
	log_function_data "KERNEL_INSTALL_TO: $KERNEL_INSTALL_TO"

	echo $MLINE
	nonfree_driver_reinstall 'kernel-xorg'
	eval "$rebootTopText"
	echo "${C}1 - use-install-f${S} Use this to try to resolve error in $DU_UPGRADE."
	echo "${C}2 - $DU_UPGRADE-again${S} Run this after correcting an error with ${C}1${S}."
	echo
	echo "${C}3 - check-services${S} Runs ${C}rcconf${S} to let you turn back off any services that might "
	echo "    have been turned on during the ${C}$DU_UPGRADE${S} (more options in the future)."
	echo
	echo "${C}4 - continue${S} Continue on with script, do this when $DU_UPGRADE is successful."
	eval "$rebootText"

	echo "${C}$exitNo - quit${S} If you need to fix error, you can exit here. In general, please"
	echo "    do not exit unless you need to. The script often runs post $DU_UPGRADE fixes"
	echo "    when you use ${C}continue${S}, and if you exit here, they will not run."
	echo $LINE
	echo -e $SLE
	echo $LINE

	select opt in $options
	do
		eval $LOGME
		case $opt in
			use-install-f)
				$APT_TYPE install $WITHOUT_RECOMMENDS -f 2>>$LOG_FILE 2>&1
				exitStatus=${PIPESTATUS[0]}
				apt_error_handling du-f $exitStatus
				# we will repeat this over and over until it's definitely done
				repeat='true'
				;;
			$DU_UPGRADE-again)
				$APT_TYPE $WITHOUT_RECOMMENDS $DU_UPGRADE 2>>$LOG_FILE 2>&1
				exitStatus=${PIPESTATUS[0]}
				apt_error_handling du-2 $exitStatus
				repeat='true' # reset so no log if no error
				;;
			check-services)
				check_services
				repeat='true'
				;;
			continue)
				# set some prefs for successful du
				if [ "$smPref" -eq 0 ];then
					set_sticky_prefs $prefId
				fi
				set_sticky_prefs d
				echo "${S}Ok, you are ready to go on now.${N}"
				continue='true'
				;;
			reboot)
				set_hold_install install # in case of reboot, make sure to lift hold
				run_script_import $LIB_KERNEL_INSTALL
				reboot_now_question $CURRENT_APT_KERNEL
				;;
			exit)
				set_hold_install install # in case of exit, make sure to lift hold
				print_quit
				;;
			*)
				print_error opt
				repeat='true'
				;;
		esac
		break
	done
	trap - INT TERM
	# run du cleanup etc tasks once user decides to continue, note that
	# script uses the error numbers to determine which message to display on repeat

	if [ "$repeat" == 'true' ];then
		install_dist_upgrade repeat $exitStatus
	elif [ "$continue" == 'true' ];then
		post_du_tasks
	fi
}

check_services()
{
	eval $LOGUS
	local rcconfFeature=0

	if [ -z "$( package_tester 'rcconf' )" ];then
		install_missing_apps 'rcconf' 'feature'
		rcconfFeature=$?
	fi
	if [ "$rcconfFeature" -eq 0 ];then
		rcconf
	fi
	eval $LOGUE
}

# arg: $1 - trap function name
du_trap_handler()
{
	# first echo is to clear the top line
	echo ''
	echo $WLINE
	echo "${W}You exited with ctrl+c or kill, removing holds if needed.${N}"
	set_hold_install install
	error_handler 'user-killed-du' "$1"
}

## DEBUGGER
#script_debugger 'install_dist_upgrade repeat 1'

# cleanup and set various tweaks post du
# this will only run if user enters the 'continue' option to avoid looping errors
post_du_tasks()
{
	eval $LOGMS
	# set the trap here
	if [ "$SYSTEM_BASE" != 'stable' -a "$SYSTEM_BASE" != 'etch' ];then
		trap 'du_trap_handler $FUNCNAME' INT TERM

		# this is all just debian conversion stuff
		if [ "$CON_DEB" == 'true' ];then
			run_script_import $LIB_DISTRO_CONVERSION
			install_window_manager
			install_sidux_components # test to make sure all sidux stuff is installed
			sidux_graphics grub1
		fi

		# load the 2007 fixes
		if [ "$DISTRO_LEVEL" -lt 10 ];then
			run_2007_fixes 'post'
		fi
		# load the 2008 fixes
		if [ "$DISTRO_LEVEL" -lt 14 ];then
			run_2008_fixes 'post'
		fi
		trap - INT TERM
		## take the package(s) off hold if they were set
		set_hold_install install
	fi
	eval $LOGME
}

###---------------------------------------------------------------------
### permanent du fixes
###---------------------------------------------------------------------

# this is a permanent fix, since the libc6 stuff mismatches so often
# args: $1 - pre-du or kernel
libc6_fix_1()
{
	eval $LOGUS
	#local libc6Version=$( apt-cache policy libc6 | grep -m 2 ':' | egrep '2\.[0-4]' )
	# for general users I'll update this if needed now and then, but mostly this is
	# for kernel installs, to avoid the du failure after new kernel
	local prefId='libc6-fix-4'
	local smPref=$( sm_pref_tester $prefId )
	local kernelMessage=' with your new kernel'
	if [ "$1" == 'pre-du' ];then
		kernelMessage=" before you $DU_UPGRADE"
	fi

 	if [ "$smPref" -eq 0 -o "$1" == 'kernel' ];then
		echo $LINE
		echo "${S}Updating ${C}libc6${S} packages to make sure your system will work right$kernelMessage...${N}"
		#echo
		#echo "${M}If ${C}tzdata${M} won't let you pick your right time zone, don't worry,"
		#echo "just select any city if this happens, then the script will let you reconfigure"
		#echo "it after your ${C}$DU_UPGRADE${M} is done. This works fine.${N}"
		package_installer 'libc6 libc6-dev tzdata locales util-linux' 'force-always'
		# let's only set this if needed
 		if [ "$smPref" -eq 0 ];then
 			set_sticky_prefs $prefId
 		fi
 	fi
 	eval $LOGUE
 	# I'm putting this in here to make sure it has fired at least once pre kernel install
 	busybox_fix_1
}

busybox_fix_1()
{
	eval $LOGUS
	local prefId='busybox-fix-1'
	local smPref=$( sm_pref_tester $prefId )

	if [ "$smPref" -eq 0 ];then
		echo $LINE
		echo "${S}Running ${C}busybox${S} fix to fix a major bug...${N}"
		package_installer 'busybox' 'install-always'
		set_sticky_prefs $prefId
	fi
	eval $LOGUE
}

nvidia_sse_alert()
{
	eval $LOGUS
	local isSse=$( grep -io 'sse' /proc/cpuinfo )
	# for some reason using \s* fails randomly for space test
	# local isNvidia=$( egrep -io 'Driver.*"nvidia"' $X_ORG_PATH | cut -d '"' -f 2  )
	# I'm going to test for nvidia alone in the lspci output in case they are running nv
	 local isNvidia=$( lspci | grep 'VGA' | grep -i 'nvidia' )

	if [ -z "$isSse" -a -n "$isNvidia" ];then
		echo $MLINE
		echo "${M}ALERT: In the latest ${C}nVidia${M} ${C}169.xx${M} and greater drivers, "
		echo "${C}OpenGL${M} requires ${C}CPUs with SSE${M} to run."
		echo
		echo "${W}Your${C}$CPU_NAME${W} does ${C}NOT${W} support ${C}SSE."
		echo $MLINE
		echo "${S}What does this mean? It means with new drivers you will not have 3d support."
		echo "The 100 series drivers do work, but cannot be installed on 2.6.26 kernels."
		echo
		echo "${S}Only drivers of series ${C}169/96/71${S} or newer work on ${C}2.6.26${S} and later kernels."
		echo "For now, this leaves you with only these choices:"
		echo "${C}1 - ${S}Stay with the latest ${C}2.6.25${S} kernel and use the ${C}100.xx${S} drivers."
		echo "    You must install these drivers directly with sgfxi, like this: ${C}sgfxi -co 100.14.19"
		echo "${C}2 - ${S}Forget about 3d and just use the 2d part of the driver, or run the legacy ${C}7xxx${S} drivers."
		echo "${C}3 - ${S}Use the ${C}xorg nv${S} drivers instead, which aren't very good."
		echo "${C}4 - ${S}Get an old used ${C}ATI 7/8/9xxx${S} card that has fine working ${C}xorg drivers."
		echo
		echo "${S}Please check the ${C}sidux.com${S} forums, hardware section, for more information on this.${N}"
		log_function_data "Is sse cpu and nvidia system."
		print_hec
	fi
	eval $LOGUE
}
# nvidia_sse_alert
###---------------------------------------------------------------------
### various du fixes
### NOTE: these fixes are contined in sm-lib-20xx-fixes files
###---------------------------------------------------------------------

# HANDLED BY EXTERNAL LIBRARY FILES sm-lib-20xx-fixes

########################################################################
### run various post du user options
###---------------------------------------------------------------------

# options for post du stuff, selection list
post_du_options()
{
	eval $LOGMS
	local repeat='' options='' opt='' cont='' qui='' advanced1='' advanced2=''
	local  advanced1Option='' advanced2Option='' initX=''
	local options='package-install package-removal clean-up-stuff miscellaneous-tweaks virtual-machine-installer'

	local tempCount=$( echo $options | wc -w )

	if [ "$KERNEL_POST_DU_FLAG" == 'true' ];then # this is always on I believe, except for livecd
		tempCount=$(( $tempCount + 1 ))
		advanced1Option='kernel-options'
		advanced1='echo -e "${C}'$tempCount'${S} - ${C}kernel-options${S} Install kernels. Install latest, and older, kernels.\n\t${M}NEW: metapackage options; NEW: kernel-module-remover"'
		tempCount=''
	fi
	options="$options $advanced1Option"
	# catch the count up again for options
	tempCount=$( echo $options | wc -w )
	if [ -n "$USER_SCRIPT_URL" ];then
		tempCount=$(( $tempCount + 1 ))
		advanced2Option="run-$USER_SCRIPT"
		advanced2='echo -e "${C}'$tempCount'${S} - ${C}$advanced2Option${S} Download and start the script: ${C}$USER_SCRIPT${S}"'
		tempCount=''
	fi
	options="$options $advanced2Option continue-to-graphics start-desktop quit"

	tempCount=$( echo $options | wc -w )

	cont=$(( $tempCount - 2 ))
	initX=$(( $tempCount - 1 ))
	qui=$tempCount

	echo $MBAR
	echo "${M}POST $( tr [a-z] [A-Z] <<< $DU_UPGRADE ) FIXES"
	echo $MLINE
	echo "${S}This is a list of various things you can do at this point to"
	echo "handle some loose ends after doing a ${C}$DU_UPGRADE${S}."
	echo $MLINE
	nonfree_driver_reinstall 'kernel-xorg'
# 	echo "${C}1${S} - ${C}fixfonts${S} gives you some font fix options. Run this after ${C}$DU_UPGRADE${S} if the upgrade "
# 	echo "    was really big, or if you haven't run it recently. This can fix some kde display issues."
# 	echo "    Has option to fix broken ${C}fontconfig${S} font cache issue if you need that."

	echo "${C}1${S} - ${C}package-install${S} are options of packages to install."
	echo "    Has for main categories - 1: office suites, like openoffice.org, with language pack selections;"
	echo "    2: non-free: flash, msttcorefonts, opera, google earth; 3: Utilities, swiftfox, other good stuff;"
	echo "    4: Desktop/window managers. These sections will grow over time, basic now."

	echo "${C}2${S} - ${C}package-removal${S} is a way to totally remove packages/programs you don't want."
	echo "    Check it out to see if any of the packages listed are things you don't need."
	echo "    One option is to remove all the german language packages from your system."

	echo "${C}3${S} - ${C}clean-up-stuff${S} This feature has a variety of clean up options:"
	echo "    1: $APT_TYPE clean; 2: $APT_TYPE autoclean, clean up only non-current deb files;"
	echo "    3: kernel removal options, remove all non-current kernels; 4: kernel module remover;"
	echo "    5: backup file cleanup; 6: clean kanotix conversion packages; 7: clean unused xorg modules"

	echo "${C}4${S} - ${C}miscellaneous-tweaks${S} Current options are: mozilla-tweaks,"
	echo "    which gets rid of gtk filehandlers and other annoyances in Mozilla products;"
	echo "    sidux-artwork - add sidux graphics - kmenu, icon, grub; and misc system config tweaks."
	echo "    A legacy tweaks section has older, deprecated tweaks like alsaconf and some cleanup stuff."
	echo "    ${M}New!${S} ${C}openoffice.org hold/install/update${S} feature. Lets you hold or remove hold easily."

	echo "${C}5${S} - ${C}virtual-machine-installer${S} Installs vbox (OSE or non-ose), vbox modules, sets up users."
	echo "    Also has any-any script install, and basic vmware install."

	eval $advanced1
	eval $advanced2
	echo
	echo "${C}$cont${S} - Continue to graphics driver installation."
	echo "${C}$initX${S} - Restart desktop/X (skip graphics (re)install)."
	echo "${C}$qui${S} - Exits the script."
	echo $LINE
	echo -e $SLE
	echo $LINE

	select opt in $options
	do
		eval $LOGME
		case $opt in
			fixfonts)
				run_script_import $LIB_MISC_TWEAKS
				fxfonts
				repeat='true'
				;;
			package-install)
				run_script_import $LIB_PACKAGE_INSTALL
				select_install_type
				repeat='true'
				;;
			package-removal)
				run_script_import $LIB_PACKAGE_REMOVAL
				package_removal
				repeat='true'
				;;
			clean-up-stuff)
				run_script_import $LIB_CLEAN_UP
				clean_up
				repeat='true'
				;;
			miscellaneous-tweaks)
				run_script_import $LIB_MISC_TWEAKS
				misc_hacks
				repeat='true'
				;;
			virtual-machine-installer)
				run_script_import $MOD_VM
				repeat='true'
				;;
			kernel-options)
				run_script_import $LIB_KERNEL
				get_current_apt_kernel $DEFAULT_KERNEL
				kernel_question post-du
				repeat='true'
				;;
			run-$USER_SCRIPT)
				run_script_import $USER_SCRIPT_URL
				repeat='true'
				;;
			continue-to-graphics)
				echo "${S}Continuing to graphics driver install...${N}"
				;;
			start-desktop)
				print_completed 'noquit'
				start_stop_default_dm full start
				;;
			quit)
				print_completed
				;;
			*)
				print_error opt
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		post_du_options
	fi
}
## DEBUGGER
#script_debugger post_du_options '' 'EXTRA_OPTIONS="true"'

########################################################################
### graphics stuff: sm-lib-graphics
###---------------------------------------------------------------------

# HANDLED BY EXTERNAL LIBRARY FILE sm-lib-graphics

########################################################################
### options and main script startup stuff
###---------------------------------------------------------------------

# must be before getopts
# args: $1 - err/full; $2 - optional, full string of args used
print_usage()
{
	set_distro_data
	local ErrorMessage=''

	if [ "$1" == 'err' ];then
		ErrorMessage='echo -e "${E}An option you selected is not a supported option.\nPlease make sure the options you used are supported: ${C}$2\n$LINE"'
	fi
	echo $MBAR
	echo "${M}OPTION HELP MENU: $SCRIPT_NAME"
	echo $MBAR
	eval $ErrorMessage
	echo "${S}Options: together: ${C}-deghiklmrstuwx${S} or separated: ${C}-giktw -f -x${S}"
	echo "You can run this script with any combination of these options."
	echo "You can put them together, like this: ${C}-ik${S}, or separate, like this: ${C}-w -x${S}"
	echo "Each option, or group of options, must begin with a ${C}-${S}"
	echo "Example: ${C}$SCRIPT_NAME -ikw${S} skips the system info, kernel install, and warning."
	echo $LINE

	echo "${S}The following allow you skip parts of the du script:"
	echo "${C}-d${S} Skips $DU_UPGRADE if you also select the ${C}w${S} option."
	echo "${C}-e${S} Skips some of the 'Please hit ${C}e${S}nter to continue' questions."
	echo "${C}-g${S} Skips the ${C}g${S}raphics install question."
	echo "${C}-i${S} Skips the system ${C}i${S}nformation section."
	echo "${C}-k${S} Skips the ${C}k${S}ernel install question."
	echo "${C}-R${S} Skips check for latest, restart, and downloading latest script version."
	echo "   This skips the ${C}R${S}estart of the script, that is. Not recommended for most users except"
	echo "   when they are rebooting from a fresh kernel install and running the script again."
	echo "${C}-s${S} Skips some parts of script that require an internet connection."
	echo "   Avoid using this since it disables almost all script functionality."
	echo "${C}-S${S} Skips the internet connection test. Use this if script fails connection test"
	echo "   but you know your connection is fine."
	echo "${C}-t${S} Skips the Post dist-uprade/upgrade op${C}t${S}ions section."
	echo "${C}-w${S} Skips the du ${C}w${S}arnings section. Starts the pre-upgrade fixes and"
	echo "   $DU_UPGRADE sections automatically if used without ${C}-d${S}. Be careful!"
	echo
	echo "The following are advanced script options:"
	echo "${C}-j${S} Alternate text/output script colors. Requires this syntax: -j 0 (sets to monochrome )"
	echo "   -j 1 (script default); -j 2 (alternate color scheme); -j 3 (nice earthy scheme)"
	echo "${C}-m${S} Runs the option to change debian ${C}m${S}irrors in ${C}$EAS${S}"
	echo "${C}-M${S} Runs the option to change default sidux-apt/kernel ${C}M${S}irrors"
	echo "${C}-N${S} Runs the option to change ker${C}N${S}el metapackage status prior to $DU_UPGRADE."

	echo "${C}-p${S} Runs $APT_TYPE update without using ${C}p${S}diffs. Good for fast connections."
	echo "${C}-P${S} Run script with ${C}P${S}roxy settings for connection, requires this syntax:"
	echo "   ${C}-P http://[<username><:password>@]<server><:port>${S} Argument is required."
	echo "${C}-U${S} Forces an ${C}U${S}pdate of script before it runs again."
	echo "${C}-x${S} Runs e${C}x${S}tra script features that are not core to central functionality."
	echo "${C}-X${S} Download and run a custom user script. Syntax: ${C}-X userscript-name#userscript-url"
	echo "    ${S}Example: ${C}-X my-cleanup-script#somewebsite.com/my-cleanup-script${S}"
	echo "    The script will show as an additional option in the Post upgrade section."

	echo
	echo "${S}The following can be run in X/kde:"
	echo "${C}-h${S} Prints this ${C}h${S}elp menu."
	echo "${C}-v${S} Prints ${C}v${S}ersion and system information, including distro version,"
	echo "   current kernel, apt update and $DU_UPGRADE last used, and last use of smxi."
	echo "${C}-W${S} Requires argument: ${C}c${S} (print current configs) OR ${C}w${S} (print warnings) OR"
	echo "   ${C}wc${S} (prints first warnings, then configs). Like this: ${C}smxi -W wc${S}"
	echo "   Note: if you want to get the live, current configs/warnings, and not the ones left from"
	echo "   your last $SCRIPT_NAME use, you must be root in terminal/console."
	if [ "$1" == 'full' ];then
		echo ''
		echo "Developer and Testing Options (Advanced):"
		echo "${C}-@${S} -  Triggers debugging tool. See ${C}script_debugger()${S} in script for directions."
		echo "${C}-! 1${S} - Sets flag ${C}B_TESTING_1='true'${S} to trigger testing condition 1."
		echo "${C}-! 2${S} - Sets flag ${C}B_TESTING_2='true'${S} to trigger testing condition 2."
		echo "${C}-! 3${S} - Sets flags ${C}B_TESTING_1='true'${S} and ${C}B_TESTING_2='true'${S}."
		echo "${C}-! 10${S} - Triggers an update from the primary dev download server."
		echo "${C}-! 11${S} - Triggers an update from svn branch one - if present, of course."
		echo "${C}-! 12${S} - Triggers an update from svn branch two - if present, of course."
		echo "${C}-! <http://......>${S} - Triggers an update from whatever server you list."
	fi
	echo $LINE
	echo "${S}Remember: to scroll up or down in terminal window, use: ${C}shift+pageup/pagedown${N}"
	echo $LINE
	exit 0
}

# args: $1 - quoted "$@" of all script start args
get_options()
{
	local altScriptUrl=''

	# no point in running this if nothing to do
	if [ -n "$1" ];then
		while getopts :dehHgij:kKlmMNpP:sStvwW:frRuUxX:Z:@!: opt
		do
			case $opt in
				h)	print_usage
					;;
				H)	print_usage 'full'
					;;
				# skip feature options
				d)	SKIP_DIST_UPGRADE='true'
					START_OPTIONS="$START_OPTIONS -d"
					;;
				e)	SKIP_ENTER='true'
					START_OPTIONS="$START_OPTIONS -e"
					;;
				g)	SKIP_GRAPHICS='true'
					START_OPTIONS="$START_OPTIONS -g"
					;;
				i)	SKIP_INFO='true'
					START_OPTIONS="$START_OPTIONS -i"
					;;
				k)	SKIP_KERNEL='true'
					START_OPTIONS="$START_OPTIONS -k"
					;;
				r|R)	SKIP_RESTART='true'
					;;
				s)	SKIP_CONNECTIONS='true'
					START_OPTIONS="$START_OPTIONS -s"
					;;
				S)	SKIP_CONNECTION_TEST='true'
					START_OPTIONS="$START_OPTIONS -S"
					;;
				t)	SKIP_TWEAKS='true'
					START_OPTIONS="$START_OPTIONS -t"
					;;
				w)	SKIP_WARNING='true'
					START_OPTIONS="$START_OPTIONS -w"
					;;
				# advanced options
				j)	if [ -n "$( egrep '^[0-3]$' <<< $OPTARG )" ];then
						SCRIPT_COLORS=$OPTARG
						set_script_colors
						if [ "$SCRIPT_COLORS" != 1 ];then
							START_OPTIONS="$START_OPTIONS -j $SCRIPT_COLORS"
						fi
					else
						error_handler 'unsupported-option' 'option-handler' "-$opt $OPTARG"
					fi
					;;
				K)	ADVANCED_KERNEL='true'
					START_OPTIONS="$START_OPTIONS -K"
					;;
				f)	FORCE_DOWNLOAD='true'
					;;
				l)	echo $MLINE
					echo "${M}The ${C}-l${M} option has been deprecated because full logging is now always on.${N}"
					print_hec
					;;
				m)	CHANGE_MIRRORS='true'
					START_OPTIONS="$START_OPTIONS -m"
					;;
				M)	CHANGE_KERNEL_MIRROR='true'
					START_OPTIONS="$START_OPTIONS -M"
					;;
				N)	KERNEL_METAPACKAGE='true'
					START_OPTIONS="$START_OPTIONS -N"
					;;
				p)	NO_PDIFFS=$NO_PDIFF_ARGS
					START_OPTIONS="$START_OPTIONS -p"
					;;
				P)	export http_proxy="$OPTARG"
					START_OPTIONS="$START_OPTIONS -P $http_proxy"
					;;
				u|U)	FORCE_UPDATE='true'
					;;
				v)	PRINT_VERSION='true'
					set_distro_data # need some of the distro data here
					check_dpkg_update # need to set the update data
					print_install_information
					exit 0
					;;
				W)	if [ -z "$( egrep "^(c|w|cw|wc)$" <<< $OPTARG )" ];then
						echo "${E}The -W option supported the following options only:"
						echo "${S}c - print config y/n data"
						echo "w - print current alert/warning data"
						echo "wc - print first alert/warning data, then config data"
						echo "Like this: -W c${N}"
						exit 1
					else
						print_update_warning_configs $OPTARG
					fi
					exit 0
					;;
				x)	EXTRA_OPTIONS='true'
					START_OPTIONS="$START_OPTIONS -x"
					;;
				X)	if [ -z "$( egrep "^.*#.*$" <<< $OPTARG )" ];then
						echo "${E}The -X option requires the following syntax:"
						echo "${C}$SCRIPT_NAME -X script-name#script-url${S} (script name + # + script web address/url"
						echo "Example: ${C}$SCRIPT_NAME -X my-system-cleaner#http://somesite.com/my-system-cleaner.sh${N}"
						exit 1
					else
						USER_SCRIPT=$( cut -d '#' -f 1 <<< $OPTARG )
						USER_SCRIPT_URL=$( cut -d '#' -f 2 <<< $OPTARG )
						wget_test $USER_SCRIPT_URL
						if [ "$?" -gt 0 ];then
							error_handler 'bad-user-script-url' 'script_option_handler' "$USER_SCRIPT_URL"
							unset USER_SCRIPT
							unset USER_SCRIPT_URL
						else
							START_OPTIONS="$START_OPTIONS -X $USER_SCRIPT#$USER_SCRIPT_URL"
						fi
					fi
					;;
				Z)	Z_SET="$OPTARG"
					START_OPTIONS="$START_OPTIONS -Z $Z_SET"
					;;
				## debuggers and testing options
				@) B_DEBUG='true'
					START_OPTIONS="$START_OPTIONS -@"
					;;
				!)	# test for various supported methods
					case $OPTARG in
						1)	B_TESTING_1='true'
							;;
						2)	B_TESTING_2='true'
							;;
						3)	B_TESTING_1='true'
							B_TESTING_2='true'
							;;
						# note: these simply set the overall script download global
						# you must have a full set of smxi scripts in the branch/one|two / dev/ alt dev directories
						10)
							altScriptUrl=$SCRIPT_DOWNLOAD_DEV
							;;
						11)
							altScriptUrl=$SCRIPT_DOWNLOAD_BRANCH_1
							;;
						12)
							altScriptUrl=$SCRIPT_DOWNLOAD_BRANCH_2
							;;
						http*)
							altScriptUrl=$OPTARG
							;;
						*)	error_handler 'unsupported-option' 'option-handler' "-$opt $OPTARG\nDevelopers: see $SCRIPT_NAME -H for advanced testing options."
							;;
					esac
					if [ -n "$altScriptUrl" ];then
						# test for smxi itself, if that's not there, give up
						wget_test "${altScriptUrl}$SCRIPT_NAME"
						if [ "$?" -gt 0 ];then
							error_handler 'bad-user-script-url' 'script_option_handler' "$altScriptUrl"
						else
							SCRIPT_DOWNLOAD=$altScriptUrl
						fi
					fi
					START_OPTIONS="$START_OPTIONS -! $OPTARG"
					;;
				*)	error_handler 'unsupported-option' 'script_option_handler' "$OPTARG"
					;;
			esac
		done
	fi
}

########################################################################
####  EXECUTE
########################################################################

# this must be set before anything else runs in script, -j will reset to no colors
set_script_colors
# set all options, leave outside main trigger to keep things clean
get_options "$@"

# run all script checks etc
# triggers main script features depending on options given
run_script_components()
{
	start_up_tests
	create_log
	check_display_and_x
	create_script_files
	# clean up old and temp files if required
	cleanup_extra_files

	# this is mainly for wifi new kernel isntalls where the new kernel wifi module
	# requires fresh install. Triggers install_wireless_modules if user wants
	if [ "$SKIP_CONNECTIONS" != 'true' -a "$SKIP_RESTART" != 'true' -a "$SKIP_CONNECTION_TEST" != 'true' ];then
		check_connection
	fi

	# there's a minor problem here, if first run, there will be no kernel lib file, so if
	# user continues, there will be an error.
	update_scripts $VERSION_INFO # get the version info data file

	# check for latest version of script.
	if [ "$SKIP_RESTART" != "true" -a "$SKIP_CONNECTIONS" != 'true' ];then
		check_version
	fi
	# tests for supported version. Nothing older than sidux pre release 5 is supported
	check_distro_version
	# check date to make sure the script is not out of date after being updated
	# if the script is older than $MAX_AGE it will not run to protect against not having updated in too  long
	check_age

	# set user sticky prefs
	sticky_prefs
	# load the apt tools now, if no connection, use local version
	# this must precede all apt related functions and features
	if [ "$SKIP_CONNECTIONS" != 'true' ];then
		run_script_import $LIB_APT_TOOLS
	else
		run_script_import $LIB_APT_TOOLS 'no-download'
	fi
	check_dpkg_update
	test_required_startup_apps
	# must be set after check_distro_version to set SIDUX_SOURCES global
	set_distro_data
	# checks for first run or -m option to run change_debian_mirrors
	launch_function_trigger 'debian-mirrors'
	# launch_function_trigger tester

	## checks for first run or -M option to run change_kernel_mirrors
	## no reason to run this on livecd since users can't install kernels anyway
	if [  "$IS_LIVE" != 'true' -a "$SIDUX_SOURCES" == 'true' ];then
		launch_function_trigger 'kernel-mirrors'
 	fi

	if [ "$SKIP_CONNECTIONS" != 'true' ];then
		get_current_apt_kernel $DEFAULT_KERNEL
	fi

	# script_debugger "launch_function_trigger kernel-metapackage" 'print_hec;exit' ''
	launch_function_trigger 'kernel-metapackage'
	launch_function_trigger 'nvidia-sse'

	#script_debugger 'install_dist_upgrade repeat 1'
	# prints out various instructions and information about install, kernel version etc
	# first hold point in script, to let user read instructions
	if [ "$SKIP_INFO" != 'true' ];then
		print_install_information
	fi

	# this will set the last used date-time of the script
	set_sticky_prefs 's'

	# runs main kernel question installer sequence also, checks kernel version for du first
	if [ "$SKIP_CONNECTIONS" != 'true' -a "$IS_LIVE" != 'true' ];then
		if [ "$SKIP_KERNEL" != 'true' -a "$DEFAULT_KERNEL" != 'no-kernel' ];then
			run_script_import $LIB_KERNEL
 			check_kernel
 			if [ "$B_TESTING_1" == 'true' ];then
 				:
 			fi
		fi
		KERNEL_POST_DU_FLAG='true'
	fi
	test_xorg_version 'pre' # test for set xorg data
	# an alert system for live warnings
	# this also triggers the main du function whether or not it's true
	if [ "$SKIP_WARNING" != 'true' -a "$SKIP_CONNECTIONS" != 'true' ];then
		run_script_import $LIB_WARNING
		upgrade_warning
	else
		if [ "$SKIP_DIST_UPGRADE" != 'true' -a "$SKIP_CONNECTIONS" != 'true' ];then
			install_dist_upgrade 'first'
		fi
	fi
	test_xorg_version 'post' # this is used by graphics and tweaks

	# runs all post du options except graphic install
	if [ "$SKIP_TWEAKS" != 'true' ];then
		post_du_options
	fi

	# check if user wants to install graphics drivers and start window manager
	if [ "$SKIP_GRAPHICS" != 'true' -a "$SKIP_CONNECTIONS" != 'true' ];then
		run_script_import $LIB_GRAPHICS
		install_graphics
	else
		start_windows_manager
	fi
}

# this is the main script runner component, activates each subroutine if required
run_script_components

exit 0
###**EOF**###