#!/bin/bash
########################################################################
####  Script Name: sm-lib-kernel-install
####  version: 2.9.6
####  Date: August 3 2008

####  Copyright (C) Harald Hope 2005-2008
####  The following functions use core logic by Kel Modderman (kelmo) and the sidux project:
####  extra_module_installer update_kernel_links install_the_apt_kernel_module install_apt_kernel_modules
####  This program is free software; you can redistribute it and/or modify it under 
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.

####  This program is distributed in the hope that it will be useful, but WITHOUT 
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

####  Get the full text of the GPL here:
####  http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

####  Script Author: Harald Hope 
####  This is a library file for smxi and cannot be run independently

####  Script URL: http://techpatterns.com/downloads/distro/sm-lib-kernel-install
####  Script Home page: http://techpatterns.com/forums/about736.html
####  FEATURES:
####  Script will install any number of kernels contained in a list of kernels
####  passed to it as parameters. This script will not run by itself.
####  This script is meant to be run as a module of smxi only
########################################################################

###---------------------------------------------------------------------
### kernel install advanced/double check questions
###---------------------------------------------------------------------

# allows user to select which kernel for their system to install
# 32 or 64 bit is selected automatically, otherwise the user can do what they want
advanced_kernel_install()
{
	eval $LOGPS
	local kernel='' options='' opt='' userSelection=''
	local text_1='' text_2=''  rcMessage='' 
	local optionList='' listCount='' kernelCount=''
	local altKernOpt1='' altKernelOption1='' altKernelText1=''
	local altKernOpt2='' altKernelOption2='' altKernelText2=''
	local altKernOpt3='' altKernelOption3='' altKernelText3=''
	local altKernOpt4='' altKernelOption4='' altKernelText4=''
	local altKernOpt5='' altKernelOption5='' altKernelText5=''
	
	# set to use proper advanced kernel data 64 / 32 bit
	# no need to load this data more than once per run through.
	
	if [ "$SET_KERNEL_DATA" != 'true' ]
	then
		set_kernel_data
		SET_KERNEL_DATA='true'
	fi
	# add the list closer items
	kernelCount=$( wc -w <<< $KERNEL_LIST )
	optionList="$KERNEL_LIST "
	if [ "$USE_DEBIAN_KERNEL" == 'true' ]
	then
		altKernelOption1='install-debian-kernel'
		altKernelText1='Debian'
		if [ "$BITS" == '32' ]
		then
			if [ -z "$( grep '2.6.*-486$' <<< $CURRENT_KERNEL )" ]
			then
				altKernelOption4='install-debian-486-kernel' 
				altKernelText4='Debian-486'
			else
				altKernelOption5='install-debian-686-kernel' 
				altKernelText5='Debian-686'
			fi
		fi
	fi
	optionList="$optionList $altKernelOption1"
	altKernOpt1=$( wc -w <<< $optionList )
	optionList="$optionList $altKernelOption4"
	altKernOpt4=$( wc -w <<< $optionList )
	optionList="$optionList $altKernelOption5"
	altKernOpt5=$( wc -w <<< $optionList )
	if [ -n "$SIDUX_SOURCES" ]
	then
		altKernelOption2='install-sidux-kernel'
		altKernelText2='sidux'
	fi
	optionList="$optionList $altKernelOption2"
	altKernOpt2=$( wc -w <<< $optionList )
	# this is inactive currently, but can be switched on with more testing
	if [ -n "$MEPIS_SOURCES" ]
	then
		altKernelOption3='install-mepis-kernel'
		altKernelText3='Mepis'
	fi
	optionList="$optionList $altKernelOption3"
	altKernOpt3=$( wc -w <<< $optionList )
	optionList="$optionList kernel-metapackage-options back-to-main-menu"
	
	listCount=$( wc -w <<< $optionList )

	local kmOption=$(( $listCount - 1 )) 
	local bmmOption=$listCount 

	print_lib_info $LIB_KERNEL_INSTALL
	echo $MLINE
	echo "${M}NOTE: The listed kernels are zip files of ${C}$BITS bit${M} kernel debs plus installer script."
	echo "For current, standard, sidux apt kernel install, RETURN TO MAIN MENU!!"
	echo
	echo "${C}1-$kernelCount - Archived kernel zip files${S} Will install the kernel you select."
	echo "       (${C}slh${S} marked kernels are sidux kernels)"
	echo
	print_alt_kernel_option "$altKernelOption1" "$altKernOpt1" "$altKernelText1"
	print_alt_kernel_option "$altKernelOption4" "$altKernOpt4" "$altKernelText4"
	print_alt_kernel_option "$altKernelOption5" "$altKernOpt5" "$altKernelText5"
	print_alt_kernel_option "$altKernelOption2" "$altKernOpt2" "$altKernelText2"
	print_alt_kernel_option "$altKernelOption3" "$altKernOpt3" "$altKernelText3"
	echo "${C}$kmOption - kernel-metapackage-options${M} NEW!${S} Kernel metapackage options: remove, install"
	echo "     sidux kernel/module metapackages. Also, install current apt kernel + modules."
	echo
	echo "${C}$bmmOption - back-to-main-menu${S} Returns you to the main menu."
	echo
	echo "${Q}Please enter in the correct number for the kernel or option you want."
	echo $LINE
	
	# this was set to correct 64/32 list in set_64_32 function
	options=$optionList

	select opt in $options
	do
		for kernel in $optionList
		do
			if [ "$opt" == "$kernel" ]
			then
				case $kernel in
					back-to-main-menu)
						# this is required to reset the old kernel file
						# KERNEL_FILE_RESET is set in set_32_64_bit
						KERNEL_FILE=$KERNEL_FILE_RESET
						;;
					install-debian-kernel|install-debian-486-kernel|install-debian-686-kernel|install-mepis-kernel|install-sidux-kernel)
						:
						;;
					kernel-metapackage-options)
						:
						;;
					*)
						KERNEL_FILE=$kernel
						;;
				esac
				userSelection=$kernel
				break
			fi
		done
		
		break
	done
	eval $LOGPE
	case "$userSelection" in
		# handle null case first
		'')
			print_error opt
			advanced_kernel_install
			;;
		back-to-main-menu)
			kernel_question
			;;
		install-debian-kernel)
			get_current_apt_kernel debian
			double_check_kernel apt-debian
			;;
		install-debian-486-kernel)
			get_current_apt_kernel debian-486
			double_check_kernel apt-debian-486
			;;
		install-debian-686-kernel)
			get_current_apt_kernel debian-686
			double_check_kernel apt-debian-686
			;;
		install-mepis-kernel)
			get_current_apt_kernel mepis
			double_check_kernel apt-mepis
			;;
		install-sidux-kernel)
			get_current_apt_kernel sidux
			double_check_kernel apt-sidux
			;;
		kernel-metapackage-options)
			kernel_meta_package_handler standard
			;;
		# any archived kernels here
		*)
			double_check_kernel advanced
			;;
	esac
}
# args: $1 - altKernelOptionx; $2 - $altKernOptx; $3 - $altKernelTextx
print_alt_kernel_option()
{
	eval $LOGUS
	local debianExtraText=''
	if [ -n "$1" ]
	then
		if [ "$1" == 'install-debian-kernel' ]
		then
			debianExtraText=' (type matches your running kernel),'
		fi
		echo "${C}$2 - $1${S} Installs current ${C}$3${S} kernel$debianExtraText"
		echo "     as well as any required ${C}$3${S} kernel modules available in apt."
		echo "     Note: you will see which specific ${C}$3${S} kernel will be installed in the next step, "
		echo "     and can skip the install if you don't want it."
		if [ "$1" == 'install-debian-686-kernel' ]
		then
			echo "     ${M}Debian ${C}686${M} kernels only work on ${C}Pentium 3${M} or newer cpu types."
		fi
	fi
	eval $LOGUE
}

# args: $1 - advanced/apt/apt-debian
double_check_kernel()
{
	eval $LOGPS
	local repeat='' options='' opt='' kernelFile='' extraText=''
	
	case $1 in
		# handles default system cases
		apt)
			kernelFile="$CURRENT_APT_KERNEL" 
			extraText=$DEFAULT_KERNEL
			;;
		apt-debian)
			kernelFile="$CURRENT_DEBIAN_KERNEL" 
			extraText='Debian'
			;;
		apt-debian-486)
			kernelFile="$CURRENT_DEBIAN_KERNEL" 
			extraText='Debian-486'
			;;
		apt-debian-686)
			kernelFile="$CURRENT_DEBIAN_KERNEL" 
			extraText='Debian-686'
			;;
		apt-mepis)
			kernelFile="$CURRENT_MEPIS_KERNEL" 
			extraText='Mepis'
			;;
		apt-sidux)
			kernelFile="$CURRENT_SIDUX_KERNEL" 
			extraText='sidux'
			;;
		advanced)
			kernelFile=$KERNEL_FILE
			extraText='sidux archived'
			;;
	esac
	
	log_function_data "Kernel Install Selection: $extraText $kernelFile"
	
	if [ -n "$kernelFile" ]
	then
		echo $LINE
		echo "${S}You will be installing the current ${C}$extraText${S} kernel: ${C}$kernelFile${S}"
		echo "${Q}Is this correct?"
		echo $LINE
		echo "${C}1${S} - Yes, install this kernel now."
		echo "${C}2${S} - No, let me go back to the menu to make a new selection."
		echo "${C}3${S} - Continue with the $DU_UPGRADE without installing a new kernel."
		echo $LINE
		echo $SLE
		echo $LINE
		
		options="yes-install-kernel no-return-to-menu continue-no-kernel"
	
		select opt in $options
		do
			case $opt in
				yes-install-kernel)
					echo "${S}OK, now the script will install kernel ${C}$kernelFile${S} for you.${N}"
					eval $LOGPE
					case $1 in 
						apt)
							install_apt_kernel $DEFAULT_KERNEL
							;;
						apt-debian|apt-debian-486|apt-debian-686)
							install_apt_kernel debian
							;;
						apt-mepis)
							install_apt_kernel mepis
							;;
						apt-sidux)
							install_apt_kernel sidux
							;;
						advanced)
							update_kernel
							echo $LINE
							;;
					esac
					;;
				no-return-to-menu)
					echo "${S}Ok, let's try it again, please make your selection.${N}"
					eval $LOGPE
					kernel_return_location $1
					;;
				continue-no-kernel)
					echo "${S}OK, continuing with script without installing new kernel."
					eval $LOGPE
					;;
				*)
					print_error opt
					repeat='true'
					;;
			esac
			break
		done
		if [ "$repeat" == 'true' ]
		then
			eval $LOGPE
			double_check_kernel $1
		fi
	else
		eval $LOGPE
		error_handler 'null-kernel-file-data' "$FUNCNAME" "$1" 
		print_hec
		kernel_return_location $1
	fi
}
# args: $1 - the arg for kernel confirm question
kernel_return_location()
{
	case $1 in 
		advanced|apt-debian|apt-debian-686|apt-debian-486|apt-sidux)
			advanced_kernel_install
			;;
		*)
			kernel_question
			;;
	esac
}
# kernel_question
#check_kernel

###---------------------------------------------------------------------
### kernel meta package / apt install handling
###---------------------------------------------------------------------

# args: $1 prefs/standard
kernel_meta_package_handler()
{
	eval $LOGPS
	if [ -n "$SIDUX_SOURCES" ]
	then
		local metaExists=$( package_tester 'linux-image-2.6-sidux-' 'wild-full' )
		local repeat='' kernelArch='686' startType='standard' userSelection=''
		if [ -n "$1" ]
		then
			startType=$1
		fi
		if [ "$BITS" == '64' ]
		then
			kernelArch='amd64'
		fi
		# not using this one yet: install-kernel-metapackages-full 
		
		local linuxImage="linux-image-2.6-sidux-$kernelArch" 
		local linuxHeaders="linux-headers-2.6-sidux-$kernelArch"
		local continueOption='continue-manual' kiAction='show'
		local defaultAction='manual' kiState='on'
		
		if [ -n "$metaExists" ]
		then
			continueOption='continue-automatic' 
			kiAction='skip'
			defaultAction='automatic'
			kiState='off'
		fi
		
		local opt='' options="remove-kernel-metapackages install-kernel-metapackages-custom  install-current-apt-kernel $continueOption"
		
		echo $MLINE
		echo "${M}Kernel Meta-Package Options${N}"
		echo $MLINE
		if [ "$1" == 'prefs' ]
		then
			echo "${M}You will only see this message automatically one time prior to kernel install."
			echo "If you are seeing it, it means you have ${C}sidux kernel metapackages${M} installed."
			echo $MLINE
		fi
		
		echo "${M}sidux now uses ${C}apt${M} as the default method to install kernels. You have two main"
		echo "choices, with possible postive / negative outcomes. Pick the one you prefer for your style."
		echo $MLINE
		echo "${C}Kernel metapackages:  ${M}Advantage:${S} Latest kernels and modules installed via ${C}$DU_UPGRADE"
		echo "${M}Negatives:${S} ${C}1.${S} ${C}slh${S} releases a lot of kernels, sometimes 1 or more a day. Usually you do"
		echo "not need new subversions of kernels, like ${C}2.6.24.2.slh.11${S} to ${C}2.6.24.2.slh.12${S}"
		echo "${C}2.${S} Needing to reboot after the $DU_UPGRADE ${C}3.${S} Slow sidux servers slowing $DU_UPGRADE"
		echo "${C}4.${S} Possible unexpected kernel / hardware issues, kernel regressions, etc."
		echo $LINE
		echo "${C}Manual apt install of kernels: ${M}Advantage:${S} ${C}1.${S} Gives full control, lets you decide"
		echo "when you want to install your new kernel, or if you want to install it."
		echo "${C}2.${S} No change from prior system. ${M}Negatives:${S} You don't always have latest kernel."
		echo $LINE
		echo "${S}To change your selections here later, either start ${C}$SCRIPT_NAME${S} with ${C}-N${S} option, or"
		echo "access this option page using ${C}kernel-install -> advanced-kernel-options${S}"
		echo "using the ${C}post $DU_UPGRADE options${S} of ${C}$SCRIPT_NAME${S}"
		echo 
		echo "Choices ${C}1${S} or ${C}3${S} convert your system to use user run kernel install (${C}manual${S})."
		echo "Choice ${C}2${S} converts your system to use metapackages (${C}automatic${S})."
		echo "The ${C}automatic${S} option turns off the pre $DU_UPGRADE kernel install section."
		echo
		echo "${C}4${S} leaves your system alone, and merely turns ${C}$kiState${S} the pre $DU_UPGRADE kernel install"
		echo "question, and returns you to ${C}$SCRIPT_NAME${S} to do what you want."
		echo
		echo "${S}Confused? You can always try one way, then the other via this control panel, so don't worry!"
		echo "${M}You current kernel is: ${C}$CURRENT_KERNEL"
		echo $LINE
		echo "${C}1 - remove-kernel-metapackages${S} Restore manual control of kernel install."
		echo "${C}2 - install-kernel-metapackages-custom${S} For automatic, no user control, install of"
		echo "    new kernels and modules."
		echo "${C}3 - install-current-apt-kernel${S} Install the current ${C}$DEFAULT_KERNEL${S} apt kernel: ${C}$CURRENT_APT_KERNEL"
		echo "    ${S}Will also remove metapackages if they are installed automatically."
		echo "${C}4 - $continueOption${S} Sets default ${C}$SCRIPT_NAME${S} to: ${C}$defaultAction${S} ($kiAction kernel install question)"
		echo $LINE
		echo $SLE
		echo $LINE
		
		select opt in $options
		do
			case $opt in
				remove-kernel-metapackages)
					set_metapackage_prefs
					set_metapackage_selections 'manual'
					remove_kernel_metapackages
					repeat='true'
					;;
				install-kernel-metapackages-custom)
					set_metapackage_prefs
					set_metapackage_selections 'automatic'
					package_installer "$linuxHeaders $linuxImage" 'install-user'
					update_kernel_links $CURRENT_APT_KERNEL # must run prior to update_grub
					update_grub
					install_apt_kernel_modules 'meta-sidux'
					extra_module_installer $CURRENT_APT_KERNEL 'madwifi'
					post_install_messages
					reboot_now_question $CURRENT_APT_KERNEL
					;;
				install-current-apt-kernel)
					set_metapackage_prefs
					set_metapackage_selections 'manual'
					if [ -n "$metaExists" ]
					then
						remove_kernel_metapackages
					fi
					double_check_kernel 'apt'
					;;
				continue-manual|continue-automatic)
					set_metapackage_prefs
					set_metapackage_selections $defaultAction
					echo "${S}Ok, continuing on using ${C}$defaultAction${S} settings.${N}"
					if [ "$defaultAction" == 'automatic' ]
					then
						echo "${S}Remember, if you want to run this section prior to a ${C}$DU_UPGRADE${S},"
						echo "just start ${C}$SCRIPT_NAME${S} like this: ${C}$SCRIPT_NAME -N"${N}
						print_hec
					fi
					;;
				*)
					print_error opt
					repeat='true'
					;;
			esac
			break
		done
		eval $LOGPE
		if [ "$repeat" == 'true' ]
		then
			kernel_meta_package_handler $1
		fi
	else
		eval $LOGPE
		echo $MLINE
		echo "${M}This feature is currently only available for systems using ${C}sidux${M} sources and kernels.${N}"
		print_hec
	fi
}

remove_kernel_metapackages()
{
	eval $LOGUS
	local metaPackageList=$( package_tester '2.6-sidux-' 'wild-full' )
	
	if [ -n "$metaPackageList" ]
	then
		package_remover "$metaPackageList" 'purge -y'
	else
		echo $ELINE
		echo "${E}There are no kernel meta packages installed, so none were removed.${N}"
		print_hec
	fi
	eval $LOGUE
}

set_metapackage_prefs()
{
	eval $LOGUS
	local prefId='kernel-metapackage-1' 
	local smPref=$( sm_pref_tester $prefId )

	if [ "$smPref" -eq 0 ]
	then
		set_sticky_prefs $prefId
	fi
	eval $LOGUE
}

# args: $1 manual/automatic
set_metapackage_selections()
{
	eval $LOGUS
	set_sm_pref_values 'meta-package-selection' "$1"
	eval $LOGUE
}

###---------------------------------------------------------------------
### kernel install using apt 
###---------------------------------------------------------------------

# master apt kernel installer function
# args: $1 debian/sidux
install_apt_kernel()
{
	eval $LOGPS
	local currentAptKernel=''
	
	case "$1" in
		debian)
			currentAptKernel=$CURRENT_DEBIAN_KERNEL
			;;
		mepis)
			currentAptKernel=$CURRENT_MEPIS_KERNEL
			;;
		sidux)
			currentAptKernel=$CURRENT_SIDUX_KERNEL
			sidux_devicemap_fix_1
			;;
	esac

	libc6_fix_1 'kernel'
	backup_grub
	install_the_apt_kernel $currentAptKernel
	update_kernel_links $currentAptKernel # must run prior to update_grub
	update_grub
	install_apt_kernel_modules 'standard' $currentAptKernel
	extra_module_installer $currentAptKernel 'madwifi'
	case "$1" in
		debian)
			extra_module_installer $currentAptKernel 'ndiswrapper'
			;;
	esac
	create_kernel_install_directory $currentAptKernel
	download_remaining_module_debs $currentAptKernel
	copy_debs_to_install_directory $currentAptKernel
	post_install_messages
	reboot_now_question $currentAptKernel
	eval $LOGPE
}

# the actual first step install
# args: $1 - kernel version to install
install_the_apt_kernel()
{
	eval $LOGUS
	local kernelImage="linux-image-$1"
	local kernelHeaders="linux-headers-$1"
	
	echo $LINE
	echo "${S}Installing your new ${C}$1${S} kernel now...${N}"
	package_installer "$kernelHeaders $kernelImage" 'install-user'
	eval $LOGUE
}

# now loop through and install all running modules for new kernel
# args: $1 - type standard/meta; $2 - kernel version to install, only for standard
# add: tp-smapi- r5u870- eeepc-acpi- qc-usb- sfc- rfswitch-
install_apt_kernel_modules()
{
	eval $LOGUS
	local supportedModules='acer_acpi acerhk acx atl2 aufs av5100 btrfs eeepc_acpi et131x fsam7400 gspca kqemu ndiswrapper omnibook qc_usb quickcam r5u870 rfswitch sfc sqlzma squashfs tp_smapi vboxadd vboxdrv'
	local module='' modulePath='' modulePackage='' moduleType='' kernelArch='686'
	local extraModuleText=''
	if [ "$BITS" == '64' ]
	then
		kernelArch='amd64'
	fi
	
	case $1 in
		standard)
			moduleType=$2
			;;
		meta-sidux)
			moduleType="2.6-sidux-$kernelArch"
			extraModuleText=' meta package'
			;;
		meta-debian)
			moduleType="2.6-$kernelArch"
			extraModuleText=' meta package'
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$1"
			;;
	esac
	
	echo $LINE
	echo "${S}Checking for ${C}$moduleType$extraModuleText${S} kernel modules in apt now....${N}"
	# try to install external dfsg-free module packages
	for module in $supportedModules
	do
		modulePath="$(/sbin/modinfo -k $(uname -r) -F filename "${module}" 2>/dev/null)"
		
		if [ -n "${modulePath}" ]
		then
			log_function_data "module: $module"
			log_function_data "modulePath: $modulePath"
			#echo "${SPACER}${S}module path: ${C}$modulePath${N}"
			modulePackage="$(dpkg -S ${modulePath} 2>/dev/null)"
			log_function_data "modulePackage: $modulePackage"
			# if the module has been merged into the kernel, we need to not try to install
			# or the installer will try to install linux-image...
			if [ -n "$modulePackage" -a -z "$( grep 'linux-image-' <<< $modulePackage )" ]
			then
				#echo "${SPACER}${S}module package a: ${C}$modulePackage${N}"
				# now we pull out the actual module name we will test for in the installer
				modulePackage="$(echo ${modulePackage} | sed s/$(uname -r).*/${moduleType}/g)"
				install_the_apt_kernel_module "$modulePackage" 'auto'
			fi
		fi
	done
	eval $LOGUE
}

# args: $1 - module package name; $2 - triggered from auto/manual mode
install_the_apt_kernel_module()
{
	eval $LOGUS
	local modulePackage=$1 noModuleText=''
	local moduleExists=$( grep-aptavail -PX "$modulePackage" )
	local moduleOutputName=$( egrep -o '.*-modules' <<< $modulePackage )
	
	case $2 in
		manual)
			noModuleText='The module you are attempting to install'
			;;
		auto)
			noModuleText='Your previously installed module'
			;;
	esac
	
	# if grep-aptavail -PX "$modulePackage" >/dev/null 2>&1
	if [ -n "$moduleExists" ]
	then
		#echo "${SPACER}${S}Checkinging kernel module: ${C}$modulePackage${N}"
		package_installer "$modulePackage" 'install-missing'
		if [ "$?" -ne 0 ]
		then
			$APT_TYPE -f install
		else
			# ignore error cases for now, apt will do the "right" thing to get 
			# into a consistent state and worst that could happen is some external
			# module not getting installed
			:
		fi
	else
		echo
		echo "$SPACER${M}$noModuleText: ${C}$moduleOutputName${M} is  not in apt currently.${N}"
	fi
	eval $LOGUE
}

# this will sync the kernel download directory module debs with the sidux ones.
# to come: using the user set mirror?
# args: $1 - kernel name
download_remaining_module_debs()
{
	eval $LOGUS
	# not current: acx100- redhat-cluster-modules- loop-aes-modules-
	local module='' missingModules='' missingModule=''
	local availableModules="$( print_module_list )"
		
	echo $LINE
	echo "${S}Downloading missing modules from sidux repos to kernel install directory (can take a few seconds)...${N}"
	
	for module in $availableModules
	do
		echo -n "${SPACER}${S}Checking for ${C}$module$1${S} now...${N}"
		moduleError=''
		# note: $APT_TYPE using apt-get to avoid aptitude deciding to install these during du
		apt-get install -d -y $module$1 &> /dev/null || moduleError='true'
		if [ "$moduleError" == 'true' ]
		then
			missingModules="$missingModules $module$1"
			echo "${SPACER}${SPACER}${M}Module not available${N}"
		else
			echo "${SPACER}${SPACER}${S}Download successful${N}"
		fi
	done
	echo
	if [ -z "$missingModules" ]
	then
		echo "${S}Kernel/module debs downloaded successfully.${N}"
	else
		echo "${M}Not all module deb files downloaded/synced successfully.${N}"
# 		for missingModule in $missingModules
# 		do
# 			echo ${C}$missingModule${N}
# 		done
		echo "${S}This is not that important, not all modules are available always.${N}"
	fi
	eval $LOGUE
}

# copy over all installed kernel debs to kernel download directory
# args: $1 - kernel version
copy_debs_to_install_directory()
{
	eval $LOGUS
	# this handles both 2.6.24-2.6.24-3 and 2.6.25-3 syntax
	local kernelBase=$( echo $1 | cut -d '-' -f 1-2 )
	local installDirectory="$KERNEL_DIRECTORY/$KERNEL_INSTALL_DIRECTORY"
	
	echo $LINE
	echo "${S}Transfering kernel/module debs to kernel install directory: ${C}$installDirectory${N}"
	cp /var/cache/apt/archives/*${kernelBase}*.deb $installDirectory
	echo "${S}Kernel/module debs transferred.${N}"
	eval $LOGUE
}

###---------------------------------------------------------------------
### kernel install using zip files
###---------------------------------------------------------------------

update_kernel()
{
	eval $LOGPS
	local FullFileName='' skipWget='' proceedNormally=0 # default: true
	local installSidux='install-kernel-sidux.sh' kernelFailed='' download3Failed='' 
	
	# the kernel file string is normalized in the directory function
	create_kernel_install_directory $KERNEL_FILE
	proceedNormally="$?" # 0 for mv/rm, 1 for use, 2 for use no unzip
	if [ "$proceedNormally" -gt 0 ]
	then
		skipWget='true'
	fi
	
	# build the name of the kernel file to download and test for
	FullFileName=$KERNEL_PREFIX$KERNEL_FILE$KZ
	
	if [ "$skipWget" != 'true' ]
	then
		# download the kernel, and see if any error occured as well
		download_kernel $FullFileName
		# this is an awkward way to get the test back into true/false form
		download3Failed="$?"
		# return of 1 triggers failed true flag
		if [ "$download3Failed" -gt 0 ]
		then
			download3Failed='true'
		fi
	fi
	
	if [ ! -f $FullFileName ]
	then
		error_handler 'kernel-download-failed' $FUNCNAME
	else 
		# careful with the logic here, it's only in the case where the final download failed
		# flag is not set that we will count the download as a success
		# run a cyclic redundancy check on the zip file first
		echo "${S}Testing integrity of downloaded kernel zip installer file ${C}$FullFileName${S}...${N}"
		unzip -t $FullFileName &> /dev/null || error_handler 'kernel-zip-corrupted' $FUNCNAME $FullFileName
		echo "${S}Kernel zip installer file is fine, continuing...${N}"
		backup_grub
		# this is the slh fix for future kernel stuff
		grep -q '  */sbin/update-grub$' /etc/kernel-img.conf 2> /dev/null && sed -i 's%=.*sbin/update-grub%= update-grub%' /etc/kernel-img.conf

		if [ "$proceedNormally" -lt 2 ]
		then
			unzip -q $FullFileName
		fi
		
		if [ -f $installSidux ]
		then
			
			# kernels in 2.6.24 are dependent on this
			if [ -n "$( echo $KERNEL_FILE | grep '2\.6\.24' )" ]
			then
				package_installer 'linux-kbuild-2.6.24' 'install-missing'
			fi
			# then we force the libc6 stuff to get installed
			libc6_fix_1 'kernel'
			echo $LINE
			echo "${S}Starting your kernel install now...${N}"
			if [ ! -x $installSidux ]
			then
				chmod +x $installSidux
			fi
			sidux_devicemap_fix_1 # run this right before in case something borked above
			./$installSidux || kernelFailed="$?"
			if [ -n "$kernelFailed" ]
			then
				error_handler 'kernel-zip-install-failed' $FUNCNAME "$kernelFailed"
			else
				post_kernel_install_steps
			fi
		else
			error_handler 'kernel-zip-installer-missing' $FUNCNAME
		fi
	fi
	eval $LOGPE
}

# args: $1 - full Kernel file Name
download_kernel()
{
	eval $LOGUS
	local FullFileName=$1 kernelDownloadPath=''
	local downloadFailed='' download2Failed='' download3Failed='' 
	local isAlt='' altString='heanet.ie' isTech='' isTechString='techpatterns.com'
	# slice out the firsts advanced kernel
	local experimental=''
	local advancedKernel=$( echo $KERNEL_ADVANCED_LIST | cut -d ' ' -f 1 )
	# set the experimental directory if kernel is advanced
	if [ "$advancedKernel" == "$KERNEL_FILE" ]
	then
		experimental='experimental/'
	fi
	# now we'll grab the kernel zip file from home base
	wget -T$TIME_OUT -t2 -Nc $TECH_PATTERNS_KERNELS$BITS'/'$FullFileName || download3Failed='true'

	if [ "$download3Failed" == 'true' ]
	then
		echo "${E}The default kernel download location: ${C}$TECH_PATTERNS_KERNELS"
		echo "${E}could not be accessed, or it doesn't have the kernel you requested."
		echo
		echo "${S}If kernel has not been previously downloaded here, the script will exit.${N}"
		eval $LOGUE
		# create return values
		return 1 # 1 on error, that is
	else
		eval $LOGUE
		return 0 # and 0 for success, as normal for bash
	fi
}

post_kernel_install_steps()
{
	eval $LOGPS
	local realKernelVersion=$( get_real_kernel_version )
	
	echo $LINE
	echo "${S}Your kernel installation appears to have been successful!"
	echo "Running some post install steps now for you...${N}"
	# run through the link and initrd.img checks to make sure
	update_kernel_links $realKernelVersion
	# let's update grub to make sure it's all good
	update_grub
	# not running this yet
	# extra_module_installer  $realKernelVersion 'madwifi'
	# extra_module_installer  $realKernelVersion 'ndiswrapper'
	post_install_messages
	# then we're ready to reboot
	reboot_now_question $realKernelVersion
	eval $LOGPE
}

get_real_kernel_version()
{
	eval $LOGUS
	# we need to first extract the new naming schema:
	local installSidux='install-kernel-sidux.sh'
	local installFile="$KERNEL_DIRECTORY/$KERNEL_INSTALL_DIRECTORY/$installSidux"
	local kTest1=$( grep 'K_UPSTREAM=' $installFile | cut -d '"' -f 2 )
	local kTest2=$( grep 'K_ABINAME=' $installFile | cut -d '"' -f 2 )
	# we don't always know when the VER has "" in it
	local kTest3=$( grep 'VER=' $installFile | cut -d '=' -f 2 | cut -d '"' -f 2 | grep '2.6' )
	local kTestError='' kernelString=''
	
	if [ -n "$kTest1" -a -n "$kTest2" ]
	then
		kernelString="$kTest1-$kTest2"
	elif [ -n "$kTest3" ]
	then
		kernelString=$kTest3
	else
		kernelString='kernel-version-test-error-true'
	fi
	# return the string value
	echo $kernelString
	log_function_data "kernelString: $kernelString"
	eval $LOGUE
}

###---------------------------------------------------------------------
### kernel utilities
###---------------------------------------------------------------------

# this is a temp fix to handle the break in sidux kernel install as of 2.6.25.11
sidux_devicemap_fix_1()
{
	eval $LOGUS
	local dMap='/boot/grub/device.map'
	local isHdx=$( grep '/dev/hd' $dMap )
	
	if [ -n "$isHdx" ]
	then
		echo $LINE
		echo "${S}Updating ${C}$dMap${S} to change all /dev/hdx to /dev/sdx...${N}"
		sed -i 's|/dev/hd|/dev/sd|' $dMap
	fi
	eval $LOGUE
}

# just in case we'll confirm this here
# args: $1 installing kernel
update_kernel_links()
{
	eval $LOGUS
	local uir='' installKernel=$1
	
	if [ -n "$1" ] # protect here to avoid major errors
	then
		echo $LINE
		# we do need an initrd
		if [ ! -f "/boot/initrd.img-${installKernel}" ]
		then
			echo "${S}Creating a missing ${C}initrd.img${S} now...${N}"
			update-initramfs -c -k "${installKernel}"
		else
			echo "${S}Updating ${C}initrd.img${S} to make sure it's all fine...${N}"
			update-initramfs -u -k "${installKernel}"
		fi
		
		echo "${S}Updating kernel ${C}vmlinuz/initrd.img${S} links...${N}"
		#echo "${S}Removing ${C}/boot${S} links...${N}"
		if [ -L /boot/vmlinuz ]
		then
			rm -f /boot/vmlinuz
		fi
		if [ -L /boot/initrd.img ]
		then
			rm -f /boot/initrd.img
		fi
		if [ -L /boot/System.map ]
		then
			rm -f /boot/System.map
		fi
		
		
# 		if [ -L /boot/vmlinuz ]
# 		then
# 			ln -fs "vmlinuz-${installKernel}" /boot/vmlinuz
# 		fi
# 		if [ -L /boot/initrd.img ]
# 		then
# 			ln -fs "initrd.img-${installKernel}" /boot/initrd.img
# 		fi
# 		if [ -L /boot/System.map ]
# 		then
# 			ln -fs "System.map-${installKernel}" /boot/System.map
# 		fi
		
		
		if [ -L /vmlinuz ]
		then
			ln -fs "boot/vmlinuz-${installKernel}" /vmlinuz 
		fi
		# set new kernel as default
		if [ -L /initrd.img ]
		then
			ln -fs "boot/initrd.img-${installKernel}" /initrd.img
		fi
		
		# set symlinks to the kernel headers
		ln -fs "linux-headers-${installKernel}" /usr/src/linux >/dev/null 2>&1
	else
		error_handler 'value-null' $FUNCNAME '$1'
	fi
	eval $LOGUE
}

update_grub()
{
	eval $LOGUS
	if [ -f $GRUB_PATH ] # handles cases where user might have lilo
	then
		echo $LINE
		echo "${S}Running ${C}update-grub${S}...${N}"
		update-grub
		echo "${C}update-grub${S} completed.${N}"
	fi
	eval $LOGUE
}

backup_grub()
{
	eval $LOGUS
	echo $LINE
	echo "${S}Backing up ${C}$GRUB_PATH"
	if [ ! -f $GRUB_BU_PATH ]
	then
		cp $GRUB_PATH $GRUB_BU_PATH
		echo "${S}Your backup file is here: ${C}$GRUB_BU_PATH${S}.${N}"
	else
		echo "${E}You have already created a backup copy of ${C}$GRUB_PATH${E} today."
		echo "${S}The backup copy is found here: ${C}$GRUB_BU_PATH${S}.${N}"
	fi
	eval $LOGUE
}

post_install_messages()
{
	eval $LOGUS
	local driverReinstall=$( nonfree_driver_reinstall 'kernel-install' )
	# note: latino idea: m-a --text-mode --non-inter -l "${VER}" a-i fglrx 
	if [ -n "$driverReinstall" ]
	then
		echo $MLINE
		echo "${W}WARNING:${M} You must reinstall your ${C}$driverReinstall${M} driver after each kernel upgrade."
		echo "X/Kde will not work until you reinstall your ${C}$driverReinstall${M} driver."
		echo
		echo "${S}You can reinstall the driver to your new kernel now using ${C}$SCRIPT_NAME${S} (continue, do not exit script),"
		echo "or you can do it manually, with ${C}sgfxi -K <your new kernel name> <other  options>${S}${N}"
		print_hec
	fi
	eval $LOGUE
}

# args: $1 - which kernel was installed; $2 - non free info
reboot_now_question()
{
	eval $LOGPS
	local driverReinstall=$( nonfree_driver_reinstall 'kernel-install' )
	local continueOpt='continue' nonfreeText='' altText2='' altText1=''
 
	if [ -n "$driverReinstall" ]
	then
		continueOpt='continue-reinstall-graphics-driver'
		nonfreeText='echo -e "\n${M}When you are finished reinstalling your ${C}$driverReinstall${S} graphics driver, the script\nwill give you the option to reboot into your new kernel."'
		altText2='echo -e "${M}NEW!${S} If you continue, you can finish up the $DU_UPGRADE, and install ${C}$driverReinstall${S} graphics\ndrivers to your new kernel ${C}$1${S} without rebooting first.\n"'
		altText1=" / $driverReinstall graphics\n   driver re-install"
	else
		altText2='echo -e "${S}If you continue, you can finish up the $DU_UPGRADE and other options before rebooting.\n${M}NEW: install nvidia/fglrx drivers before you reboot if required${S}\n"'
	fi
	
	local repeat='' options="reboot-now $continueOpt quit"
	
	cd $SCRIPT_HOME # needed to make sure user is back in correct directory
	# sets KERNEL_EQUAL_INSTALL
	test_kernel_strings $1 'set-ke'
	
	echo $MLINE
	echo "${M}KERNEL INSTALL COMPLETE"
	echo $MLINE
	log_function_data "KERNEL_EQUAL_INSTALL: $KERNEL_EQUAL_INSTALL"
	
	if [ "$KERNEL_EQUAL_INSTALL" != 'true' ]
	then
		eval $altText2
		echo "${S}If you're all done, and just want to start your new kernel, then just reboot now."
		eval $nonfreeText
		echo $LINE
		echo "${C}1 - reboot-now${S} Reboot system now to start new kernel, if you are all done"
		echo "    with your $DU_UPGRADE and system maintenance."
		echo -e "${C}2 - $continueOpt${S} Proceed to $DU_UPGRADE$altText1 and other ${C}$SCRIPT_NAME${S} functions."
		echo "${C}3 - quit${S} Exit script now."
		
		echo $LINE
		echo -e $SLE
		echo $LINE
	
		select opt in $options 
		do
			case $opt in
				reboot-now)
					echo $LINE
					echo "${S}Rebooting now into your new ${C}$1${S} kernel...${N}"
					eval $LOGPE
					reboot
					exit 0
					;;
				$continueOpt)
					echo "${S}Continuing on to finish your system maintenance."
					echo "${M}Remember your new kernel will not be active until you reboot.${N}"
					KERNEL_INSTALL_TO=$1
					log_function_data "KERNEL_INSTALL_TO: $KERNEL_INSTALL_TO"
					;;
				quit)
					echo "${M}Ok, but remember your kernel is not active yet until you reboot.${N}"
					print_quit
					;;
				*)
					print_error opt
					repeat='true'
					;;
				esac
			break
		done
		eval $LOGPS
		if [ "$repeat" == 'true' ]
		then
			reboot_now_question "$1"
		fi
	else
		echo "${M}You appear to have reinstalled your running kernel for some reason. That's fine, "
		echo "although you may want to reboot anyway to make sure it's all working right."
		echo $LINE
		echo "${S}Feel free to continue on doing things in ${C}$SCRIPT_NAME${S} if you want.${N}"
		print_hec
		eval $LOGPS
	fi
}

# args: $1 - $KERNEL_FILE/installed kernel
create_kernel_install_directory()
{
	eval $LOGUS
	local directoryAction=0
	
	KERNEL_INSTALL_DIRECTORY=$( normalize_kernel_string $1 )
	log_function_data "KERNEL_INSTALL_DIRECTORY: $KERNEL_INSTALL_DIRECTORY"
	echo $LINE
	echo "${S}Please note!! The kernel install directory will be located here:" 
	echo "${C}$KERNEL_DIRECTORY/$KERNEL_INSTALL_DIRECTORY${N}"
	# create and move to the primary storage directory for kernel downloads
	if [ ! -d $KERNEL_DIRECTORY ]
	then
		mkdir $KERNEL_DIRECTORY
	fi
	cd $KERNEL_DIRECTORY
	# here the script wil create a directory named with the current kernel name
	if [ ! -d $KERNEL_INSTALL_DIRECTORY ]
	then
		mkdir $KERNEL_INSTALL_DIRECTORY
	else
		# set whether to wget file or not, only happens if already downloaded
		handle_preexisting_install_directory $KERNEL_INSTALL_DIRECTORY
		directoryAction="$?" # 0 for mv/rm, 1 for use, 2 for use no unzip
	fi
	cd $KERNEL_DIRECTORY/$KERNEL_INSTALL_DIRECTORY
	eval $LOGUE
	return $directoryAction
}

# args: $1 which directory
handle_preexisting_install_directory()
{
	eval $LOGUS
	local opt=''
	local olddirectory=$KERNEL_DIRECTORY/$1
	local newdirectory="$olddirectory-$(date +%y-%m-%d)"
	local options='delete-directory rename-directory use-directory use-directory-no-unzip quit'
	echo $ELINE
	echo "${E}There is already a ${C}$KERNEL_INSTALL_DIRECTORY${S} directory present in your system!"
	echo $ELINE
	echo "${S}Either you are trying to install a kernel you already have on your system,"
	echo "or you created this directory yourself. You have the following options:"
	echo $LINE
	echo "${C}1 - delete-directory${S} - Script deletes directory: ${C}$olddirectory"
	echo "${C}2 - rename-directory${S} - Script renames existing directory to: ${C}$newdirectory"
	echo "${C}3 - use-directory${S} - Uses this directory, and assumes it has the kernel"
	echo "    zip file in it already, but not yet unzipped."
	echo "${C}4 - use-directory-no-unzip${S} - Uses this directory, and assumes the kernel"
	echo "    downloaded kernel zip file has already been unzipped."
	echo 
	echo "${C}5 - exit${S} - Quit now, I'll check this myself then start the script again."
	echo $LINE
	echo $SLE
	echo $LINE
	
	select opt in $options
	do
		case $opt in
			delete-directory)
				echo "${S}Deleting this directory: ${C}$olddirectory"
				rm -f -r $olddirectory
				echo "${C}$olddirectory${S} has been removed. Continuing with kernel install.${N}"
				mkdir $olddirectory
				echo "${S}Created new empty directory: ${C}$olddirectory${N}"
				eval $LOGUE
				return 0
				;;
			rename-directory)
				echo "${S}Renaming this directory: ${C}$olddirectory"
				echo "To this backup name: ${C}$newdirectory${N}"
				mv $olddirectory $newdirectory
				echo "${S}Directory renamed"${N}
				mkdir $olddirectory
				echo "${S}Created new empty directory: ${C}$olddirectory${N}"
				eval $LOGUE
				return 0
				;;
			use-directory)
				echo "${M}Ok, using the current install directory: ${C}$olddirectory"
				echo "${S}Hopefully it contains the kernel download zip file.${N}"
				eval $LOGUE
				return 1
				;;
			use-directory-no-unzip)
				echo "${M}Ok, using the current install directory:  ${C}$olddirectory"
				echo "without unzipping kernel file.${N}"
				eval $LOGUE
				return 2
				;;
			quit)
				print_quit
				;;
			*)
				print_error yn
				handle_preexisting_install_directory $1
				;;
		esac
	done
}

# small utility just so we have the list in one place for all
# functions that will use it, this will be used for looping type
# stuff re module installer options.
print_module_list()
{
	eval $LOGUS
	local availableModules="
	acer-acpi-modules-
	acerhk-modules-
	atl2-modules-
	aufs-modules-
	btrfs-modules-
	drbd8-modules-
	eeepc-acpi-modules-
	et131x-modules-
	fsam7400-modules-
	gspca-modules-
	kqemu-modules-
	lzma-modules-
	ndiswrapper-modules-
	omnibook-modules-
	qc-usb-modules-
	r5u870-modules-
	rfswitch-modules-
	sfc-modules-
	squashfs-modules-
	tp-smapi-modules-
	virtualbox-ose-guest-modules-
	virtualbox-ose-modules-
	"
	
	echo "$availableModules"
	eval $LOGUE
}
# args: $1 kernel install version; $2 - which module madwifi/ndiswrapper
extra_module_installer()
{
	eval $LOGUS
	local kernelVersion=$1 moduleName=$2 argMissing=''
	local filename='' tarball='' module='' message='' extra='' buildFailed=0
	
	case $moduleName in
		madwifi)
			filename='ath_pci'	
			tarball='madwifi.tar.bz2'
			module='madwifi'
			message="Atheros Wireless Network Adaptor will not work until\nthe non-free madwifi driver is reinstalled."
			extra='Atheros '
			;;
		ndiswrapper)
			filename='ndiswrapper'	
			tarball='ndiswrapper.tar.bz2'
			module='ndiswrapper'
			message="Wireless Network Adaptor using ndiswrapper will not work\nuntil the ndiswrapper module is reinstalled."
			;;
		*)
			error_handler 'value-bad' $FUNCNAME "$moduleName"
			;;
	esac
	
	# hints for module to be built
	if [ -n "$1" -a -n "$2" ]
	then
		if /sbin/modinfo -k $CURRENT_KERNEL -F filename $filename >/dev/null 2>&1
		then
			echo $LINE
# 			echo "${S}Checking to see if ${C}$extra$module${S} can be built for your wifi card...${N}"
# 			if [ -f /usr/src/${tarball} ] && which m-a >/dev/null
# 			then
				echo "${S}Starting build of your ${C}$module${S} module now...${N}"
				# user setup madwifi with module-assistant already
				# we may as well do that for him again now
				if [ -d /usr/src/modules/${module}/ ]
				then
					rm -rf /usr/src/modules/${module}/
				fi
				# this will pull in the source if required etc...
				m-a --text-mode --non-inter -l $kernelVersion a-i $module || buildFailed=$?
# 			else
			if  [ "$buildFailed" -eq 249 ] # this is pre-exisisting module error
			then
				echo $MLINE
				echo "${C}error 249${M} just means ${C}$module${M} was already installed on your new kernel. "
				echo "Sometimes ${C}$SCRIPT_NAME${M} and the current sidux apt kernel installers"
				echo "might be slightly out of sync, that's ok though.${N}"
			elif [ "$buildFailed" -gt 0 ]
			then
				echo $WLINE
				echo "${E}The ${C}m-a${E} build of your module exited with error code ${C}$buildFailed${S}"
				echo -e "$message"
				echo
				echo "Please report any critical errors you might get on sidux.com forums,"
				echo "especially the exit error number.${S}"
				echo $WLINE
				print_hec
			fi
		fi
	else
		if [ -z "$1" ]
		then
			argMissing='$1 '
		fi
		if [ -z "$2" ]
		then
			argMissing=$argMissing'$2'
		fi
		error_handler 'value-null' $FUNCNAME "$argMissing"
	fi
	eval $LOGUE
}


###**EOF**###