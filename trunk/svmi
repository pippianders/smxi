#!/bin/bash
########################################################################
####  Script Name: system virtual machine installer: svmi
####  Only use for Debian Sid, Testing and sidux, no support for any other distro
####  version: 1.8.6
####  Date: September 12 2008
########################################################################
####  Copyright (C) Harald Hope 2007-2008
####  This program is free software; you can redistribute it and/or modify it under 
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT 
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here:
####  http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
########################################################################
####  Script URL: http://techpatterns.com/downloads/distro/svmi
####  Script Home page: none
########################################################################
########################################################################
#### DEFINE:
#### TRUE: -eq 0; == 'true'; function return 0
#### FALSE: -gt 0; == ''; function return > 0
########################################################################
#### VARIABLES
########################################################################

# options and global data
APT_TYPE='apt-get'
AUTO_RUN=''
AUTORUN_ANYANY=''
AUTORUN_QEMU_IMAGE=''
AUTORUN_VBOX=''
AUTORUN_VBOX_MODULE=''
AUTORUN_VMPLAYER=''
AUTORUN_VMSERVER=''
FORCE_UPDATE=''
SCRIPT_COLORS=1
PACKAGE_MANAGER=''
SKIP_CONNECT=''
SKIP_FUNCTION=''
SKIP_RESTART=''
SM_INSTALL=''
START_OPTIONS=''
SYSTEM_BASE=''
TESTING=''
UPDATED=''
USER_NAME=''
VBOX_ALT_VERSION=''
WITHOUT_RECOMMENDS=''

# system paths etc
EAS='/etc/apt/sources.list'
EDV='/etc/debian_version'
EMOD='/etc/modules'
TPD='http://techpatterns.com/downloads/distro/'
VMWARE_INSTALL_PATH='/usr/src/vmware-downloads/'
VMWARE_CONFIG='/usr/bin/vmware-config.pl'

# kernel info
CURRENT_KERNEL=$(uname -r)
KERNEL_VERSION=$( uname -r | grep -o -G "2.6.[0-9]*" )
KERNEL_BASE=$( uname -r | cut -d '.' -f 1-2 ) # like: 2.6
KERNEL_THREE=$( uname -r | cut -d '-' -f 1 | cut -d '.' -f 1-3 ) # like: 2.6.19
KERNEL_THIRD=$( uname -r | cut -d '-' -f 1 | cut -d '.' -f 3 ) # like: 19, for math use

# check for 64 bit first
if [ -n "$( uname -m | grep -o 'x86_64' )" ]
then
	BITS="64"
else
	BITS="32"
fi

# set some core count dependent data
CORE_COUNT=$( cat /proc/cpuinfo | egrep -c '^processor' )

INSTALL_TYPE=''
VMP='vmplayer'
AA='anyany'

DIR_NAME=''
FILE_NAME=''
FILE_URL=''
## extra url data.. for vmware tools:
# http://download3.vmware.com/software/wkst/VMware-workstation-5.5.0-18463.tar.gz
# http://download3.vmware.com/software/vmplayer/VMware-player-2.0.2-59824.i386.tar.gz
# http://download3.vmware.com/software/vmplayer/VMware-player-2.0.2-59824.x86_64.tar.gz
# VMware-player-2.0.2-59824 VMware-workstation-5.5.0-18463 2.0.4-93057
VMPLAYER_PREFIX='http://download3.vmware.com/software/vmplayer/'
VMPLAYER_NUMBER='2.0.5'
VMPLAYER_VERSION="VMware-player-$VMPLAYER_NUMBER-109488"
VMWARE_Z='.tar.gz'
if [ "$BITS" -eq 32 ]
then
	VMWARE_32_64='.i386'
else
	VMWARE_32_64='.x86_64'
fi
VMPLAYER_RUN='vmware-install.pl'
VMPLAYER_DIR='vmware-player-distrib'

# ANYANY_ALT='http://rtr.ca/vmware-2.6.24/vmware-any-any-update115a.tgz'
# http://linuxtoy.org/files/vmware-any-any-update-116.tgz
# http://groups.google.com/group/vmkernelnewbies/web/vmware-any-any-update-116.tgz
ANYANY_PREFIX='http://knihovny.cvut.cz/ftp/pub/vmware/'
# ANYANY_PREFIX='http://groups.google.com/group/vmkernelnewbies/web/'
ANYANY_VERSION='vmware-any-any-update'
ANYANY_NUMBER=115 # we'll be doing some math on this maybe
# ANYANY_Z='.tar.gz'
ANYANY_Z='.tar.gz'
ANYANY_RUN='runme.pl'
ANYANY_ALT=''
ANYANY_DIR_DASH=''
ANYANY_FILE_DASH=''

# # # use alternate name and location for 2.6.24
case $KERNEL_THIRD in
	26)
		# source url:
		# http://groups.google.com/group/vmkernelnewbies/web/vmware-any-any-update117c.tar.gz
		# author blog:
		# http://opensuse-linux-blog.blogspot.com/2008/07/how-to-install-vmware-in-2626-linux.html#links
		ANYANY_PREFIX='http://techpatterns.com/downloads/distro/patches/'
		#ANYANY_Z='.tgz'
		ANYANY_ALT='c'
		ANYANY_NUMBER=117
		#ANYANY_FILE_DASH=''
		;;
	25)
		# http://download.rsbac.org/tmp/vmware-any-any-update117.tar.gz
		# vmware-any-any-update-116.tgz
		ANYANY_PREFIX='http://download.rsbac.org/tmp/'
		#ANYANY_Z='.tgz'
		#ANYANY_ALT=''
		ANYANY_NUMBER=117
		#ANYANY_FILE_DASH=''
		;;
	24)
		# http://blog.creonfx.com/temp/vmware-any-any-update-116.tgz
		ANYANY_PREFIX='http://techpatterns.com/downloads/distro/patches/'
		ANYANY_Z='.tgz'
		ANYANY_ALT='a'
		ANYANY_NUMBER=115
		;;
esac

APT_VBOX_VERSION=''
APT_VBOX_VERSION_FULL=''
VBOX_VERSION='2.0.2'
VBOX_INSTALL_PATH='/usr/src/vbox-downloads/'
VBOX_PACKAGE_NO='36488'
VBOX_V='-2.0' # vbox 2 and greater have this extra string
# 1.5.0:24069 1.5.2:25433 1.5.4:27034 1.5.6:28266 
VBOX_PREVIOUS="1.6.0:30421 1.6.2:31466 1.6.4:33808 1.6.6:35336 2.0.0:36011 $VBOX_VERSION:$VBOX_PACKAGE_NO"
# this is just for cosmetic output of supported versions
VBOX_VERSIONS=$( echo $VBOX_PREVIOUS | egrep -o '[0-9]\.[0-9]\.[0-9]' )
VBOX_VERSIONS=$( echo $VBOX_VERSIONS ) # dump the line breaks
VBOX_INSTALLED_VERSION='' # will be set dynamically
VBOX_DOWNLOAD_SERVER='http://download.virtualbox.org/virtualbox/'

# script paths
EAS='/etc/apt/sources.list'
SCRIPT_HOME='/usr/local/bin'
SCRIPT_NAME=$( basename $0 )
SM_VALUES='/usr/local/bin/svmi-values'

CONFIG_FILE='/etc/svmi.conf'
LOG_FILE='/var/log/svmi.log'
LOGPS='log_function_data ps $FUNCNAME "$( echo $@ )"'
LOGPE='log_function_data pe $FUNCNAME'
LOGUS='log_function_data us $FUNCNAME "$( echo $@ )"'
LOGUE='log_function_data ue $FUNCNAME'
LOGGING_STARTED='' # this will flag to avoid logging for pre log errors like no root
SCRIPT_ROTATE="/etc/logrotate.d/$SCRIPT_NAME"

# miscellaneous settings
TIME_OUT=25
DOWNLOAD_COUNTER=0

# allow user set globals to override script globals
if [ -f $SM_VALUES ]
then
	source $SM_VALUES
fi

########################################################################
####  FUNCTIONS 
########################################################################

# set global color variables
# options: 0 - turns off all colors; 1 - defaults
set_script_colors()
{
	# set colors
	case $SCRIPT_COLORS in
		0)
			W='' # red: Warning message
			E='' # yellow: script Error
			S='' # green: Standard message
			Q='' # CYAN: Questions
			M='' # CYAN: Message
			B='' # BLUE: Message
			C='' # MAGENTA: Command or Path
			N='' # default system console color: Normal :: make last in colors
			;;
		1)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[1;32m" # green: Standard message
			Q="[1;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			B="[1;34m" # BLUE: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		2)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[0;37m" # Standard message
			Q="[0;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			B="[0;37m" # BLUE: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		3)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[0;33m" # Standard message
			Q="[1;34m" # CYAN: Questions
			M="[0;36m" # CYAN: Message
			B="[0;33m" # BLUE: Message
			C="[0;32m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
	esac

	CALLER_DEF=${S} # will switch default output color to the calling script's
	S=${B} # this is slightly tricky, making standard blue AFTER the caller def is set.

	# script layout stuff
	BA='=================================================================='
	LI='------------------------------------------------------------------'
	BAR=${S}$BA${N}
	EBAR=${E}$BA${N}
	WBAR=${W}$BA${N}
	MBAR=${M}$BA${N}
	LINE=${S}$LI${N}
	ELINE=${E}$LI${N}
	MLINE=${M}$LI${N}
	WLINE=${W}$LI${N}
	
	# repeated text
	YNE="\n${S}[ type lower case ${C}y${S} or ${C}n${S} and hit ${C}enter${S} ]${N}"
	SLE="${Q}Please type the appropriate number and hit ${C}enter${N}"
	HEC="${Q}Please hit ${C}enter${Q} to continue${N}"
}

# only for debugging purposes
set_test_data()
{
	local username=''
	if [ "$TESTING" == 'true' ] # set testing directories etc
	then
# 		# this is required for testing to make sure we always are starting with true
# 		# latest script versions
# 		username=$( getent passwd 1000|cut -d \: -f1 )
# 		SCRIPT_HOME="/home/$username/bin/scripts/sidux/"
# 		LOG_FILE="$SCRIPT_HOME"svmi.log
# 		cd $SCRIPT_HOME
# 		rm -f svmi.log
# 		VMWARE_INSTALL_PATH="$SCRIPT_HOME"src/
# 		VBOX_INSTALL_PATH="$SCRIPT_HOME"src/
# 		SYSTEM_BASE='testing' 
# 		KERNEL_THIRD=25
		:
	fi
}

# this will trigger the non interactive installs
run_non_interactive()
{
	if [ "$AUTORUN_ANYANY" == 'true' -o "$AUTORUN_QEMU_IMAGE" == 'true' -o "$AUTORUN_VBOX" == 'true' -o "$AUTORUN_VBOX_MODULE" == 'true' -o "$AUTORUN_VMPLAYER" == 'true' -o "$AUTORUN_VMSERVER" == 'true' ]
	then
		AUTORUN='true'
	fi
	
	if [ "$AUTORUN_ANYANY" == 'true' ]
	then
		install_vmware $AA
	fi
	if [ "$AUTORUN_QEMU_IMAGE" == 'true' ]
	then
		create_qemu_image
	fi
	if [ "$AUTORUN_VBOX" == 'true' ]
	then
		install_vbox
	fi
	if [ "$AUTORUN_VBOX_MODULE" == 'true' ]
	then
		install_vbox_module
	fi
	if [ "$AUTORUN_VMPLAYER" == 'true' ]
	then
		install_vmware $VMP
	fi
	if [ "$AUTORUN_VMSERVER" == 'true' ]
	then
		echo 'not currently working'
	fi
}
########################################################################
#### Error handling and detections
#### -------------------------------------------------------------------
error_handler()
{
	local errorCode=$1 # error number 
	local errorExtra=$2 # this is secondary info, like failed package name
	local errorData=''
	local ErrorMessage=''
	
	case $errorCode in
		255) 
			errorData="This does not appear to be a Debian apt based system!"
			;;
		254) 
			errorData="Sorry, Ubuntu isn't supported by this script"
			;;
		253) 
			errorData="Your kernel type $KERNEL_BASE is not supported for these drivers."
			;;
		252) 
			errorData="You must be logged in as root to run this script."
			;;
		251) 
			errorData="There does not appear to be a live connection, or $SCRIPT_NAME script server is down.\nIf you are sure you have a connection, restart script with -Z option to cancel connection test."
			;;
		250)
			errorData="Could not detect gcc version: $errorExtra, or it is not installed.\nPlease let the script maintainer know, this may be a bug in the script."
			;;
		249) 
			errorData="The option you selected: $errorExtra is not supported."
			;;
		# specific install issues
		200) 
			errorData="The package: $errorExtra failed to install, please check apt for any problems."
			;;
		199) 
			errorData="The file: $errorExtra failed to download - wget reports success."
			;;
		198) 
			errorData="The file: $errorExtra failed to download - wget error."
			;;
		197)
			errorData="The module: $errorExtra failed to build."
			;;
		196) 
			errorData="Removing package $errorExtra failed."
			;;
		195) 
			errorData="The package $errorExtra failed to download."
			;;
		194) 
			errorData="The package $errorExtra failed to download and exceeded tries."
			;;
		193) 
			errorData="tar xzf of $errorExtra failed."
			;;
		192) 
			errorData="No vmware installation was detected for any-any install."
			;;
		191) 
			errorData="The deb package $errorExtra failed to install correctly."
			;;
		*) 
			errorData="Unexpected Error !"
			;;
	esac
	ErrorMessage="ERROR: ($errorCode) $errorData"
	echo -e ${E}$ErrorMessage${N}
	if [ -f $LOG_FILE -a "$LOGGING_STARTED" == 'true' ]
	then
		log_function_data "$ErrorMessage"
		echo
		echo "${S}Log file is located here: $LOG_FILE"
	fi
	echo "${M}Exiting script now.${N}"
	
	exit $errorCode
}

########################################################################
#### script utilities
#### -------------------------------------------------------------------

#print_information
basic_startup_tests() 
{
	local nonDebianPattern='(sidux|opera|debian-multimedia|skype|swiftfox|virtualbox)'
	# these tests will be improved over time, but are ok for now
	local isEtch=$( grep -is '^4.' $EDV )
	local isStable=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(stable|etch)' )
	local isTesting=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(testing|lenny)' )
	local isUnstable=$( egrep -siw '^[[:space:]]*deb' $EAS $EAS.d/*.list | egrep -iv "$nonDebianPattern" | egrep -icw '(sid|unstable)' )
	
	### basic system requirements for this script to run, first so user doesn't 
	### have to be root or out of x to get basic failure information
	# make sure that it's a debian based system
	if [ ! -f "$EDV" ]
	then
		error_handler 255
	fi
	# no ubuntu support
	if [ "$( cat /etc/issue | grep -i -c 'buntu' )" -gt 0 ]
	then
		error_handler 254
	fi
	# double check only 2.6 series kernels
	if [ "$KERNEL_BASE" != '2.6' ]
	then
		error_handler 253
	fi
	
	### basic execute requirements
	cd $SCRIPT_HOME
	if [ "$(whoami)" != 'root' ]
	then
		error_handler 252
	fi
	
	# this allows users to update in x, for example, to see latest drivers
	if [ "$FORCE_UPDATE" == 'true' ]
	then
		check_update_script $SCRIPT_NAME
	fi
	
	# set system type. This test will never be perfect, but it's a good approximation
	if [ -n "$isEtch" ]
	then
		SYSTEM_BASE='etch'
	elif [ "$isStable" -gt 0 -a "$isUnstable" -eq 0  -a "$isTesting" -eq 0 ]
	then
		SYSTEM_BASE='stable'
	elif [ "$isTesting" -gt 0 -a "$isUnstable" -eq 0 ]
	then
		SYSTEM_BASE='testing'
	else
		SYSTEM_BASE='sid'
	fi
}

# handles bug in stub installer that leaves tempfiles uncleaned
cleanup_temp_files()
{
	eval $LOGUS
	local all_files=""

	# Note: if  * is in "" the wildcard does not work
	# /dev/null handles case where no temp or original file exists
	all_files=$( ls "${SCRIPT_NAME}."* 2> /dev/null ) 
	# make sure stuff exists, rm files
	if [ -n "$all_files" ]
	then
		rm -f $all_files
	fi
	eval $LOGUE
}

check_install_tools()
{
	eval $LOGPS
	local gccVersion=$( egrep -io 'gcc[[:space:]]*version[[:space:]]*[4-6]\.[0-9]{1,2}' /proc/version | egrep -o '[4-6]\.[0-9]{1,2}' )
	local ubgv="/usr/bin/gcc-$gccVersion"
	
	if [ ! -x /usr/bin/module-assistant ]
	then
		install_package module-assistant
	fi
	if [ ! -d /usr/share/build-essential ]
	then
		install_package build-essential
	fi

	if [ -x "$ubgv" ]
	then
		# the correct g++ version is required for the gcc version to build module
		if [ ! -x "/usr/bin/g++-$gccVersion" ]
		then
			install_package g++-$gccVersion
		fi
		export CC=$ubgv
	else
		error_handler 250 "$ubgv"
	fi
	eval $LOGPE
}

check_apt_aptitude()
{
	eval $LOGUS
	local opt='' managers='apt-get aptitude quit'
	local aptPref=$( get_set_prefs 'get' 'apt-type' | cut -d '=' -f 2 | egrep '^(apt-get|aptitude)$' )
	
	if [ -f /var/log/aptitude ]
	then
		if [ -z "$aptPref" ]
		then
			echo $LINE
			echo "${S}It appears you are using aptitude. It is not good to mix apt-get and aptitude."
			echo "Please pick your preferred package manager before you continue, or exit now."
			echo
			echo "Your selection (for example: ${C}apt-type=apt-get${S}) will be stored in ${C}/etc/smxi.conf${S}"
			echo "${C}smxi${S} will also use this choice for its default package manager, so make sure it's correct."
			echo $LINE
			
			select opt in $managers 
			do
				case $opt in
					apt-get|aptitude)
						APT_TYPE=$opt
						log_function_data "Selected package manager: $opt"
						get_set_prefs 'set' "apt-type=$opt"
						;;
					quit)
						echo "${S}Ok, figure it out and try again later...${N}"
						exit 0
						;;
					*)
						echo "${E}You have to pick one before you can continue!${N}"
						ask_apt_aptitude
						;;
				esac
				break
			done
		else # set apt type
			APT_TYPE=$aptPref
		fi
		if [ "$APT_TYPE" == 'aptitude' ]
		then
			WITHOUT_RECOMMENDS='--without-recommends'
		fi
	fi
	eval $LOGUE
}

# args: $1 - get/set; $2 - prefname
get_set_prefs()
{
	eval $LOGUS
	local etcsm='/etc/smxi.conf' retValue='' name='' value=''
	
	case $1 in
		get)
			retValue=$( grep -s $2 $etcsm )
			echo $retValue
			log_function_data "Return value: $retValue"
			;;
		set)
			touch $etcsm
			# test = first, this will handle the base name and anything else
			name=$( cut -d '=' -f 1 <<< $2 )
			# check to see if it's there, if it is, it must be a = type thing
			if [ -z "$( grep -s $name $etcsm )" ]
			then
				echo $2 >> $etcsm
				log_function_data "Added $2 to $etcsm"
			else
				sed -i "s/$name.*/$2/" $etcsm
				log_function_data "Updated $name to $2 in $etcsm"
			fi
			;;
	esac
	eval $LOGUE
}

# arg: $1 - package names
install_package()
{
	eval $LOGUS
	local useUntrusted='--allow-unauthenticated' install='install' doYes='-y'
	if [ "$UPDATED" != 'true' ]
	then
		echo "${S}Running $APT_TYPE update now...${N}"
		$APT_TYPE update && UPDATED='true' 
	fi
	if [ "$APT_TYPE" == 'aptitude' ]
	then
		if [ "$SYSTEM_BASE" == 'etch' ]
		then
			useUntrusted='' # etch aptitude doesn't support this
		else
			useUntrusted='--allow-untrusted'
		fi
		doYes=''
	fi
	if  [ -n "$1" ]
	then
		echo "${S}Installing required package ${C}$1${S} now...${N}"
		$APT_TYPE install $WITHOUT_RECOMMENDS $useUntrusted $doYes $1 || error_handler 200 $1
	fi
	eval $LOGUE
}

remove_package()
{
	eval $LOGUS
	local response='' package=''
	
	if [ -n "$1" ]
	then
		echo $MLINE
		echo "${M}You will need to remove the following package(s): ${C}$1"
		echo "${M}in order to proceed with your ${C}$2${M} driver install${N}"
		echo $MLINE
		for package in $1 
		do
			if [ -n "$( dpkg -l | grep $package )" ]
			then
				echo "${S}Removing ${C}$package${S}...${N}"
				$APT_TYPE purge $package || error_handler 196 "$package"
			else
				echo "${S}The package ${C}$package${S} is not installed, continuing...${N}"
			fi
		done
		echo "${S}Package(s) removed successfully, continuing with driver install.${N}"
	fi
	eval $LOGUE
}

test_package_available()
{
	eval $LOGUS
	local packageAvailable=''
	
	LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageAvailable=$( apt-cache policy $1 2>/dev/null | grep -i 'Candidate:' | cut -d ':' -f 2-4 | cut -d ' ' -f2 | grep -iv '\(none\)' )
	
	log_function_data "packageAvailable: $packageAvailable"
	echo $packageAvailable
	eval $LOGUE
}

# args: $1 script to get/check; $2 - repeat, to only retest download failure once
check_update_script()
{
	local fileNameTemp="$( mktemp -p $SCRIPT_HOME/ $1.XXXXXXXXXX )"
	local isGood='' uArgs=''
	
	cd $SCRIPT_HOME # make sure we're in the right place
	
	if [ -f "$fileNameTemp" ]
	then
		rm -f $fileNameTemp # remove the temp file, should never fire, but why not?
	fi
	
	# if newer version, download / replace lib file
	if [ "$1" == "$SCRIPT_NAME" ]
	then
		if [ "$FORCE_UPDATE" != 'true' -a "$2" != 'repeat' ]
		then
			uArgs='?u'
		fi
		wget -q -O$fileNameTemp $TPD$1$uArgs || error_handler 198 $1
		# all smxi files have this string as last line, so if it's there, the file should usually
		# run fine, except for weird fringe cases where the ascii file is corrupted partially
		isGood=$( grep '##\*\*EOF\*\*##' $fileNameTemp )
		
		if [ -n "$isGood" ]
		then
			mv -f $fileNameTemp $1
			chmod 705 $1
			if [ "$FORCE_UPDATE" != 'true' ]
			then
				./$1 -R$START_OPTIONS
			else
				print_information
				echo "${C}$SCRIPT_NAME${B} was successfully updated. Please start the script again"
				echo "to access the latest features and drivers. Exiting now.${N}"
			fi
			exit 0
		else
			# dump the bad file
			rm -f $fileNameTemp
			
			if [ "$2" != 'repeat' ]
			then
				# let's try this once again to make sure it wasn't just a temp problem
				echo "${E}The file ${C}$1${E} did not download correctly, retrying download now...${N}"
				check_update_script "$1" 'repeat'
			else
				error_handler 231 $1
			fi
		fi
	# I'm only going to load this stuff one time per file so I won't
	# have to worry about rechecking and multi downloads etc
	fi
}
# args: $1 string to be normalized. All internal script functions will use this syntax:
# 2.6.24.2.slh.2-sidux-686 / 2.6.24.2.slh.2-sidux-amd64
normalize_kernel_string()
{
	eval $LOGUS
	local kernelString=$1 processSlh='' oldSlh='' processedString='' kernelArch=''
	# first test for the new default .slh. syntax:
	if [ -n "$( echo $kernelString | egrep '(-slh(64)?-)' )" ]
	then
		oldSlh='true'
	fi
	if [ -n "$( echo $kernelString | egrep '(2\.6\.[0-9]{2}-2\.6\.[0-9]{2}.*\.slh\.)' )" ]
	then
		processSlh='true'
	fi
	
	if [ "$oldSlh" == 'true' -o "$processSlh" == 'true' ]
	then
		if [ "$processSlh" == 'true' ]
		then
			# this syntax is handled here
			# 2.6.24-2.6.24.1.slh.3-sidux-amd64 2.6.24-2.6.24.1.slh.3-sidux-686
			# slice out the part after 2.6.24-
			processedString=$( echo $kernelString | cut -d '-' -f 2-4 )
		elif [ "$oldSlh" == 'true' ]
		then
			kernelArch=$( echo $kernelString | grep 'slh64'  )
			# set the kernel arch here
			if [ -n "$kernelArch" ]
			then
				kernelArch='amd64'
			else
				kernelArch='686'
			fi
			# this syntax is handled here
			# 2.6.23.15-slh-smp-3 2.6.23.15-slh64-smp-3
			processedString=$( echo $kernelString | sed -r 's/(-slh(64)?-(smp|up)-)/.slh./g' )
			processedString=$processedString'-sidux-'$kernelArch
		fi
	# do not process user custom or already processed strings at all
	else
		processedString=$kernelString
	fi

	echo $processedString
	eval $LOGUE
}

print_information()
{
	eval $LOGPS
	local scriptVersion=$( egrep -o -m 1 "(version:).*" $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2 )
	#echo 'sv:' $scriptVersion
	local scriptDate=$( egrep -o -m 1 '(Date:).*' $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2-4 )
	local vmPlayer=''
	if [ -e /usr/bin/vmplayer ]
	then
		# vmPV=$( vmplayer -v )
		vmPlayer='echo "VM installed: '$vmPV'"'
	fi
	#local cardInfo=$( lspci | gawk -F': ' '/VGA compatible controller.*: / { print $NF }' | sed -r 's%(ATI\sTechnologies\sInc\s|nVidia\sCorporation\s)(.*)%\2%'  )
	local vmInfo=''
	
	echo $MLINE
	echo " ${M}$SCRIPT_NAME${S} :: version: ${C}$scriptVersion${S} :: last updated: ${C}$scriptDate${N}"
	#eval $vmPlayer
	eval $LOGPE
}

# this is the hit enter to continue blurb...
print_hec()
{
	local response=''
	
	if [ "$AUTORUN" != 'true' ]
	then
		echo $LINE
		# halt the script so people can read the advice
		echo $HEC
		echo $LINE
		read response
	fi
}

# this handles typos for y/n questions, or wrong case
print_error()
{
	echo $EBAR
	if [ "$1" == "yn" ]
	then
		echo "${E}You must enter ${C}y${E} to run this option, or ${C}n${E} to reject it."
		echo "Please make sure that you enter either ${C}y${E} or ${C}n${E}, lower case, thanks.${N}"
	elif [ "$1" == "opt" ]
	then
		echo "${E}======= Error: please enter one of the numbers in the list =======${N}"
	fi
	echo $EBAR
}

create_log() 
{
	local svmiVersion=$( grep 'version:' $SCRIPT_NAME | grep -o "[0-9]*\.[0-9]*\.[0-9]*" )
	
	if [ ! -f $SCRIPT_ROTATE ]
	then
		echo "$LOG_FILE {
	rotate 1
	size 100k
	create
}	
" > $SCRIPT_ROTATE
	fi
	touch $LOG_FILE # make sure there's one there for rotate to look at
	if [ -n "$( which logrotate )" ]
	then
		logrotate $SCRIPT_ROTATE
	fi
	touch $LOG_FILE # and if rotated, need a new one
	echo "=========================================================" >> $LOG_FILE
	echo "START $SCRIPT_NAME LOGGING:" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE
	echo "Script started: $( date +%Y-%m-%d-%H:%M:%S )" >> $LOG_FILE
	echo "Installed Kernel: $CURRENT_KERNEL" >> $LOG_FILE
	echo "$SCRIPT_NAME script version: $svmiVersion" >> $LOG_FILE
	echo "$SCRIPT_NAME start options: $START_OPTIONS" >> $LOG_FILE
	echo "SYSTEM_BASE: $SYSTEM_BASE" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE
	# it's important to log these in case there's some issue or bug in the values
	if [ -f $SM_VALUES ]
	then
		log_function_data "Begin User Set $SM_VALUES:\n$( cat $SM_VALUES)\nEnd User Set Values"
	fi
	
	LOGGING_STARTED='true'
}

# $1 type or data; $2 is function; $3 - function args, optional
log_function_data()
{
	local funcInfo='' logSpacer='  '
	
	case $1 in
		ps)
			funcInfo="Function: $2 - Primary: Start"
			;;
		pe)
			funcInfo="Function: $2 - Primary: End"
			;;
		us)
			funcInfo="Function: $2 - Utility: Start"
			;;
		ue)
			funcInfo="Function: $2 - Utility: End"
			;;
	esac
	
	if [ -n "$funcInfo" ]
	then
		log_writer "$funcInfo"
	else
		log_writer "${logSpacer}$1"
	fi
	
	if [ -n "$3" ]
	then
		log_writer "${logSpacer}Args: $3"
	fi
}

# args: $1 - data to write to logfile. Note that the function is always logged
# via function_logging first, and other relevant globals are set there as well
log_writer()
{
	# this handles first line indents, all other indents must be set in message data
	# like so: message="some problem... \n${LOG_INDENT}more problem stuff..."
	if [ "$LOGGING_STARTED" == 'true' ]
	then
		# strip out escape color code, if any. Method by dzz of sidux, thanks ;-)
		echo -e "$1" | sed 's/\x1b\[[0-9]\{1,2\}\(;[0-9]\{1,2\}\)\{0,2\}m//g' >> $LOG_FILE
	fi
}

########################################################################
#### Core virtual machine installer functions
#### -------------------------------------------------------------------

# startup questions, users choose vm and action
vm_main_selector()
{
	eval $LOGPS
	local repeat='' options='' opt='' quitContinue='quit'
	# testing for both ose and non ose versions, then installing the requested version
	set_installed_vbox_version
	if [ "$SM_INSTALL" == 'true' ]
	then
		quitContinue='continue'
	fi

	echo $MLINE
	echo "${M} Virtual Machine Options"
	
	echo $MLINE
	echo "${S}For most new or average users, I recommend running vbox, it's a simple, clean install,"
	echo "and you'll have your vbox up and running almost immediately."
	echo $LINE
	echo "${M}vmware tools are currently quite rough. I do not recommend trying them"
	echo "unless you already know how to do vmware stuff. The any-any updater is solid, and will"
	echo "get your current vmware modules built for new kernels fine. The vmware installer is"
	echo "still quite basic, and will just download and run the installer, with any-any. You"
	echo "have to do the vmx file creation and the image file creation manually currently."
	echo
	echo "${S}vmware player install version: ${C}${C}$VMPLAYER_NUMBER${S}${S}"
	echo "any-any patch version: ${C}$ANYANY_NUMBER"
	echo "${C}1${S} - ${C}install-vmware${S} Downloads, installs, and runs vmware player, and any-any patch."
	echo "${C}2${S} - ${C}run-anyany${S} Runs any-any, downloads and installs if required."
	echo "${C}3${S} - ${C}install-qemu${S} Installs qemu if required. ${M}NEW: great site to make your"
	echo "   vmdk/vmx files, super easy, make a note of it. Highly recommended: ${C}www.easyvmx.com"
	echo $LINE
	echo "${M}Please NOTE: ose means open source edition. Ose and non-ose components are NOT compatible."

	echo "${C}4${S} - ${C}install-vbox-ose${S} Installs virtualbox-ose. If you need to update modules after installing,"
	echo "    please run ${C}build-vbox-module-ose${S} as well."
	echo "${C}5${S} - ${C}build-vbox-module-ose${S} Installs vbox OSE module, updates modules,"
	echo "    adds module to $EMOD if required."
	echo "    ${M}NOTE: System must be fully dist-upgraded for this to work right before you run this!"

	echo $LINE
	echo "${M}For other vbox non-ose versions, use the ${C}svmi -V <vbox version>${M} option"
	echo "${S}vbox non-ose default install version: ${C}$VBOX_VERSION${S}"
	echo "Available vbox non-ose versions: ${C}$VBOX_VERSIONS"
	echo "${C}6${S} - ${C}install-vbox-non-ose-etch${S} Installs the ${C}Debian Etch${S} vbox deb."
	echo "    Module is built automatically."
	echo "${C}7${S} - ${C}install-vbox-non-ose-lenny${S} Installs the ${C}Debian Lenny${S} vbox deb."
	echo "    Module is built automatically (${M}vbox-non-ose 1.6.6 or higher only${S})."
	echo "${C}8${S} - ${C}build-vbox-module-non-ose${S} Will reconfigure existing virtualbox to rebuild module."
	echo $LINE
	echo "${C}9${S} - ${C}install-vbox-addons${S} Downloads vbox guest additions iso. Helps with driver installation,"
	echo "    For both ose and non-ose. Highly recommended. Will download the version (${C}>1.6.0${S})"
	echo "    for your currently installed virtualbox-ose: ${C}$VBOX_INSTALLED_VERSION"

	echo $LINE
	echo "${C}10${S} - ${C}$quitContinue${S}"
	
	echo $LINE
	echo -e $SLE
	echo $LINE
	
	options="install-vmware run-anyany make-qemu-image install-vbox-ose build-vbox-module-ose install-vbox-non-ose-etch install-vbox-non-ose-lenny build-vbox-module-non-ose install-vbox-addons $quitContinue"
	select opt in $options
	do
		case $opt in
			install-vmware)
				install_vmware $VMP
				repeat='true'
				;;
			run-anyany)
				install_vmware $AA
				repeat='true'
				;;
			make-qemu-image)
				create_qemu_image
				repeat='true'
				;;
			install-vbox-ose)
				install_vbox ose
				repeat='true'
				;;
			build-vbox-module-ose)
				install_vbox_module ose
				repeat='true'
				;;
			install-vbox-non-ose-etch)
				install_vbox 'non-ose' 'etch'
				repeat='true'
				;;
			install-vbox-non-ose-lenny)
				install_vbox 'non-ose' 'lenny'
				repeat='true'
				;;
			build-vbox-module-non-ose)
				install_vbox_module non-ose
				repeat='true'
				;;
			install-vbox-addons)
				install_vbox_addons
				repeat='true'
				;;
			$quitContinue)
				echo "${S}Thanks for checking out the Virtual Machine Installer.${N}"
				exit 0
				;;
			*)
				print_error opt
				repeat='true'
				;;
		esac
		break
	done
	
	if [ "$repeat" == 'true' ]
	then
		vm_main_selector
	fi
	eval $LOGPE
}

### -------------------------------------------------------------------
### vmware functions
### -------------------------------------------------------------------

construct_file_name()
{
	eval $LOGUS
	
	if [ "$INSTALL_TYPE" == "$AA" ]
	then
		# this will try the next sequence of number in case he updates it
		if [ "$1" == 'failed' ]
		then
			ANYANY_NUMBER=$(( $ANYANY_NUMBER + 1 ))
		fi

		DIR_NAME=$ANYANY_VERSION$ANYANY_NUMBER$ANYANY_ALT # handles 'a' for 2.6.24
		FILE_NAME=$ANYANY_VERSION$ANYANY_FILE_DASH$ANYANY_NUMBER$ANYANY_ALT$ANYANY_Z
		FILE_URL=$ANYANY_PREFIX$FILE_NAME
	elif  [ "$INSTALL_TYPE" == "$VMP" ]
	then
		DIR_NAME=$VMPLAYER_VERSION$VMWARE_32_64
		FILE_NAME=$DIR_NAME$VMWARE_Z
		FILE_URL=$VMPLAYER_PREFIX$FILE_NAME
	fi
	
	log_function_data "DIR_NAME: $DIR_NAME"
	log_function_data "FILE_NAME: $FILE_NAME"
	log_function_data "FILE_URL: $FILE_URL"
	eval $LOGUE
}
# construct_file_name anyany failed; exit

# test, download, run app
download_file()
{
	eval $LOGUS
	local noGood='' fileURL='' testExtract=''
	
	if [ ! -d "$VMWARE_INSTALL_PATH" ]
	then
		mkdir $VMWARE_INSTALL_PATH
	fi
	
	cd $VMWARE_INSTALL_PATH
	#echo 'pwd is: ' $(pwd);exit
	if [ ! -d "$DIR_NAME" ]
	then
		if [ "$DOWNLOAD_COUNTER" -le 1 ]
		then
			wget -Nc -T $TIME_OUT $FILE_URL || noGood='true'
		
			if [ "$noGood" == 'true' ]
			then
				if [ "$INSTALL_TYPE" == "$AA" ]
				then
					DOWNLOAD_COUNTER=$(( $DOWNLOAD_COUNTER + 1 ))
					construct_file_name failed
					download_file
				else
					error_handler 195 $FILE_URL
				fi
			else
				log_function_data "Send FILE_URL to test_extract_file: $FILE_URL"
				testExtract='true'
			fi
		else
			error_handler 194 $FILE_URL
		fi
	else
		echo "${M}You have already downloaded the package, proceeding with install now...${N}"
		testExtract='true'
	fi
	
	if [ "$testExtract" == 'true' ]
	then
		test_extract_file
	fi
	eval $LOGUE
}

test_extract_file()
{
	eval $LOGUS
	local extractFailed=''
	
	if [ ! -d "$DIR_NAME" ]
	then
		tar xzf $FILE_NAME || error_handler 193 $FILE_NAME
	fi
	
	if [ -d "$VMPLAYER_DIR" -a "$INSTALL_TYPE" == "$VMP" ]
	then
		mv $VMPLAYER_DIR $DIR_NAME
	fi
	
	eval $LOGUE
	run_file
}

run_file()
{
	eval $LOGUS
	local runFile=''
	
	cd $DIR_NAME
	
	case $INSTALL_TYPE in
		$AA)
			runFile=$ANYANY_RUN
			;;
		$VMP)
			runFile=$VMPLAYER_RUN
			;;
	esac
	
	./$runFile
	eval $LOGUE
}

# $1 which install type to use
install_vmware()
{
	eval $LOGPS
	INSTALL_TYPE=$1
	
	echo $LINE
	
	if [ "$1" == "$AA" ]
	then
		install_anyany
	elif [ "$1" == "$VMP" ]
	then
		echo "${S}Starting $VMP install and setup. When vmware setup asks you this question:"
		echo "${M}Before running VMware Player for the first time, you need to configure it"
		echo "by invoking the following command: /usr/bin/vmware-config.pl...."
		echo
		echo "${S}Answer 'n' to this question, and then $AA setup and install will begin automatically.${N}"
		print_hec
		construct_file_name
		download_file
		# for vmp, we want to also run any any
		INSTALL_TYPE=$AA
		install_anyany
	fi
	
	eval $LOGPE
	print_hec
}

install_anyany()
{
	eval $LOGUS
	if [ -x "$VMWARE_CONFIG" ]
	then
		echo "${S}Starting $AA install and setup. When any any asks if you want to run"
		echo "/usr/bin/vmware-config.pl answer 'y' and your vmware install will complete.${N}"
		print_hec
		construct_file_name
		download_file
	else
		error_handler 192
	fi
	eval $LOGUE
}

create_qemu_image()
{
	eval $LOGUS	
	local qemuExists=$( dpkg -l | grep 'qemu'  )
	
	echo $LINE
	if [ -z "$qemuExists" ]
	then
		install_package qemu
	else
		echo "${C}qemu${M} is already installed on your system.${N}"
	fi
	
	eval $LOGUE
	print_hec
}

### -------------------------------------------------------------------
### vbox functions
### -------------------------------------------------------------------

# this will set the global installed vbox version to handle mismatches
set_installed_vbox_version()
{
	eval $LOGUS

	APT_VBOX_VERSION=$( apt-cache search ^virtualbox-[2-9] | cut -d ' ' -f 1 | cut -d '-' -f 2 )
	if [ -n "$APT_VBOX_VERSION" ]
	then
		APT_VBOX_VERSION_FULL="-$APT_VBOX_VERSION"
	fi
	# this is a hack made necessary by new naming method in debian for -2.0
	LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= VBOX_INSTALLED_VERSION=$( apt-cache policy virtualbox$APT_VBOX_VERSION_FULL-ose virtualbox$APT_VBOX_VERSION_FULL 2>/dev/null | grep 'Installed:' | cut -d ':' -f 2-4 | cut -d ' ' -f2 | cut -d '-' -f 1 | egrep -o '[0-9].[0-9].[0-9]')
	
	log_function_data "APT_VBOX_VERSION: $APT_VBOX_VERSION\nVBOX_INSTALLED_VERSION: $VBOX_INSTALLED_VERSION"

	eval $LOGUE
}
# create and install vbox module:
# $1 is ose/non-ose; $2 - lenny/etch
install_vbox()
{
	eval $LOGPS
	local vboxOSE="virtualbox-ose virtualbox-ose-source"
	local vboxGeneral=$( dpkg -l | cut -d ' ' -f 3 | grep 'virtualbox' )
	local vboxBad='virtualbox virtualbox-source'
	# default to ose install
	local toInstall=$vboxOSE toRemove=$vboxBad' '$vboxGeneral
	if [ -n "$( test_package_available 'virtualbox-2.0-ose' )" ]
	then
		vboxOSE='virtualbox-2.0-ose virtualbox-2.0-ose-source'
	fi
	
	if [ "$1" == 'non-ose' ]
	then
		toRemove=$vboxGeneral
		# old dependencies: 
		#toInstall='libicu38 libxalan110'
		# libqtcore4 libqtgui4
		if [ "$APT_TYPE" == 'apt-get' ]
		then
			toInstall='libidl0 adduser'
			if [ -n "$( egrep '^[2-6]\.' <<< $VBOX_VERSION )" ]
			then
				toInstall="$toInstall libqtcore4 libqtgui4"
			fi
		else
			toInstall=''
		fi
	fi
	
	remove_package "$toRemove"
	install_package "$toInstall"
	
	if [ "$1" == 'non-ose' ]
	then
		install_vbox_non_ose "$2"
	fi
	
	add_vbox_user
	
	eval $LOGPE
	print_hec
}

# args: $1 - etch/lenny
install_vbox_non_ose()
{
	eval $LOGPS
	local arch='i386' installError=0
	if [ "$BITS" == '64' ]
	then
		arch='amd64'
	fi
	# set to null for 1.x.x versions
	if [ -z "$( egrep '^[2-6]\.' <<< $VBOX_VERSION )" ]
	then
		VBOX_V=''
	fi
	local vboxName='virtualbox'$VBOX_V
	local debName=$vboxName'_'$VBOX_VERSION'-'$VBOX_PACKAGE_NO'_Debian_'$1'_'$arch'.deb'
	local vboxNonOseURL=$VBOX_DOWNLOAD_SERVER$VBOX_VERSION'/'$debName
	
	if [ ! -d $VBOX_INSTALL_PATH ]
	then
		mkdir $VBOX_INSTALL_PATH
	fi
	cd $VBOX_INSTALL_PATH
	
	if [ ! -f $debName ]
	then
		echo "${S}Downloading package ${C}$debName${S}...${N}"
		wget -O $debName $vboxNonOseURL || echo -e "${E}The vbox $debName download failed, the file name probably changed.\nPlease let the svmi script maintainer know this.${N}"
	else
		echo "${S}Using previously downloaded package: ${C}$debName${N}"
	fi
	
	if [ -s $debName ]
	then
		echo "${S}Installing non free debian virtual box deb now...${N}"
		# dpkg -i $debName 2>> $LOG_FILE || error_handler 191 $debName 
		dpkg -i $debName 2>> $LOG_FILE 2>&1 || installError=1
		if [ "$APT_TYPE" == 'apt-get' ]
		then
			echo "${S}Running ${C}$APT_TYPE install -f${S} to update any missing packages...${N}"
			$APT_TYPE install -f  2>> $LOG_FILE 2>&1 && installError=0 || installError=2 
		elif [ "$APT_TYPE" == 'aptitude' ]
		then
			echo "${S}Running ${C}$APT_TYPE install $vboxName${S} to update any missing packages...${N}"
			$APT_TYPE install $WITHOUT_RECOMMENDS $vboxName  2>> $LOG_FILE 2>&1 && installError=0 || installError=2 
		fi
		# note that this only runs if the above worked, otherwise shows error
		case $installError in
			0)
				echo "${S}Please note: ${C}virtualbox non-ose${S} version is started with the command: ${C}VirtualBox${S}"
				echo "(Note uppercase ${C}V${S} and ${C}B${S})"
				echo "${C}virtualbox${S} (lowercase ${C}v${S} and ${C}b${S}) is the ${C}virtualbox-ose${S} start command.${N}"
				;;
			2)
				echo "${E}Sorry, the install failed for some reason, let's find out why.${N}"
				;;
		esac
	else
		echo "${E}Sorry, the download failed for some reason, let's find out why.${N}"
		if [ -f $debName ]
		then
			rm -f $debName
		fi
	fi
	eval $LOGPE
	print_hec
}
#install_vbox_non_ose;exit

# note: this will need to check kernel version vbox module / current vbox version
# $1 is ose or non-ose
install_vbox_module()
{
	eval $LOGPS 
	local vbdv='vboxdrv'
	local isEMod=$( cat $EMOD | grep -i $vbdv )
	local vbModLoaded=$( lsmod | grep $vbdv )
	local kernelPath='/usr/src/kernel-downloads/'
	# need to grab all of them, not just the main stuff
	local success=''
	
	echo $LINE
	if [ "$1" == 'ose' ]
	then
		preinstall_cleanup # get rid of previous modules
		# then reset version information
		set_installed_vbox_version
		local vbs="virtualbox$APT_VBOX_VERSION_FULL-ose-source"
		local vbo="virtualbox$APT_VBOX_VERSION_FULL-ose"
		local modDebName="virtualbox-ose$APT_VBOX_VERSION_FULL-" 
		local vboxSource=$( dpkg -l | grep -i $vbs )
		local normalizedCurrentKernel=$( normalize_kernel_string $CURRENT_KERNEL )
		local modDebPath=$kernelPath$normalizedCurrentKernel'/'$modDebName'*.deb'
		local modDeb=$( ls $modDebPath 2> /dev/null )
		
		# we'll only get the source if we need to build the module
		# I'm going to try to force the update as well, since otherwise users
		# will have an unmatched vbox versioning
	# 	if [ -z "$vboxSource" -o -z "$vboxSlhMod" ]
	# 	then
			echo "${S}Updating ${C}$vbo $vbs${S} now to make sure versions match...${N}"
			install_package "$vbo $vbs"
	# 	fi
		# set it again in case the stuff changed
		set_installed_vbox_version
		
		# we need to check that the kernel module version matches the installed version:
		# that means it must have the right vbox version number in the deb string
		local vboxSlhMod=$( echo $modDeb | grep $VBOX_INSTALLED_VERSION )
		
		# note: here we have to make sure that the installed stuff is the same version
		# as the slh prebuilt modules. If not, we'll simply make the modules manually
		
		# since we have to be able to update modules actively, I'm removing the test for
		# loaded, that triggers a condition that requires running module install two times
		# if the old module isn't working right, or is for wrong vbox version
# 		if [ -z "$vbModLoaded" ]
# 		then
			if [ -z "$modDeb" -o -z "$vboxSlhMod" ]
			then
				echo "${S}Building ${C}$vbdv${S} module now and running modprobe...${N}"
				log_function_data "Building $vbdv module now and running modprobe..."
				m-a a-i $vbs || error_handler 197 $vbdv
			else
				echo "${S}Installing prebuilt vbox kernel module from kernel download directory: ${C}$kernelPath$normalizedCurrentKernel${N}"
				log_function_data "Installing prebuilt slh vbox kernel modules: $modDeb"
				dpkg -i $modDeb 2>> $LOG_FILE 2>&1 || error_handler 191 $modDeb
			fi
# 			echo "${S}Ignore this error message if you see it, it's meaningless: ${C}FATAL: Module vboxdrv not found.${N}"
			modprobe $vbdv
# 		else
# 			echo "${M}Kernel Module ${C}$vbdv${M} is already installed...${N}"
# 			log_function_data "Kernel Module $vbdv is already installed..."
# 		fi
		success='true'
	elif [ "$1" == 'non-ose' ]
	then
		local nonOse="virtualbox$APT_VBOX_VERSION_FULL" 
		# make sure vbox non ose is installed
		local nonOseInstalled=$( dpkg -l | grep 'ii' | cut -d ' ' -f 3 | egrep "^$nonOse$" )
		
		if [ -n "$nonOseInstalled" ]
		then
			echo "${S}Running ${C}dpkg-reconfigure${S} on ${C}$nonOse${S}...${N}"
			dpkg-reconfigure $nonOse
			success='true'
		else
			echo "${C}$nonOse${E} does not appear to be installed, please install it using the menu options."
			echo "${S}You cannot build the module without having first installed the non-ose vbox!${N}"
		fi
	fi
	if [ "$success" == 'true' ]
	then
		# we're going to run this stuff for ose and non-ose now to make sure all users
		# get this, that might help some fringe cases
		if [ -z "$isEMod" ]
		then
			echo $vbdv >> $EMOD
		fi
		modprobe $vbdv
		echo "${C}$vbdv${S} module should now be up and running.${N}"
	fi
	eval $LOGPE
	print_hec
}
#install_vbox_module

preinstall_cleanup()
{
	eval $LOGUS
	local previousVbox='' oldVbSource="virtualbox-source"
	local previousVbm='' vbdv='vboxdrv'
	local vbModLoaded=$( lsmod | grep $vbdv )
		
	echo $LINE
	echo "${S}Doing some basic pre module install preparations and cleanup...${N}"
	if [ -n "$vbModLoaded" ]
	then
		rmmod vboxdrv 1>> $LOG_FILE 2>> $LOG_FILE
	fi
	
	previousVbm=$( COLUMNS=200 dpkg -l | cut -d ' ' -f 3 | egrep '(virtualbox-modules|virtualbox-[2-9]..-modules)' )
	if [ -n "$previousVbm" ]
	then
		dpkg --purge $previousVbm  1>> $LOG_FILE 2>> $LOG_FILE
	fi

	oldVbSource=$( COLUMNS=200 dpkg -l | cut -d ' ' -f 3 | grep $oldVbSource )
	if [ -n "$oldVbSource" ]
	then
		dpkg --purge $oldVbSource 1>> $LOG_FILE 2>> $LOG_FILE
	fi
	
	previousVbox=$( COLUMNS=200 dpkg -l | cut -d ' ' -f 3 | egrep '(virtualbox-ose-modules|virtualbox-[2-9]..-modules)' )
	if [ -n "$previousVbox" ]
	then
		dpkg --purge $previousVbox  1>> $LOG_FILE 2>> $LOG_FILE
	fi
	eval $LOGUE
}
# getent passwd 1000|cut -d\: -f1 
# your first user is ${1st_user}. Press ENTER to use that, or type the username'
add_vbox_user()
{
	eval $LOGPS
	local userExists=''
	
	echo $LINE
	echo "${S}In order for vbox to run, you need to add your normal user name to the ${C}vboxusers${S} group."
	echo
	if [ -z "$USER_NAME" ]
	then
		echo "This script can do that for you now. If you would like to have that done, please"
		echo "enter your normal login user name now, then hit enter."
		echo "(If you have already created this user/group, or want to skip this step, just hit enter)${N}"
	
		read USER_NAME
	else
		echo "${S}Using the user name you provided: ${C}$USER_NAME${N}"
	fi
	
	# check to see user actually exists, use passwd because someone reported a looping
	# error here using the test on /home. Tightened test to include : to close name
	# old test: [ -n "$( ls /home | grep $USER_NAME )" ]
	userExists=$( egrep -o "^$USER_NAME:" /etc/passwd )
	
	if [ "$USER_NAME" != '' ]
	then
		log_function_data "Using USER_NAME: $USER_NAME"
		if [ -n "$userExists" ]
		then
			echo "${M}NOTE: the new group will not be available to ${C}$USER_NAME${M} until they logout and log back in.${N}"
			adduser $USER_NAME vboxusers
		else
			echo "${E}The user name ${C}$USER_NAME${E} does not appear to exist, please try again...${N}"
			log_function_data "Error: USER_NAME: $USER_NAME does not exist in /etc/passwd"
			USER_NAME='' # must be reset here to null or loops endlessly
			add_vbox_user
		fi
	fi
	eval $LOGPE
}

install_vbox_addons()
{
	eval $LOGPS
	
	local vboxLib='/usr/lib/virtualbox/'  vboxAddDir='additions'
	local vboxAddonFile='VBoxGuestAdditions_'$VBOX_INSTALLED_VERSION'.iso'
	local vboxAddonName='VBoxGuestAdditions.iso'
	local vboxAddonURL=$VBOX_DOWNLOAD_SERVER$VBOX_INSTALLED_VERSION'/'$vboxAddonFile

	echo $LINE
	if [ -d $vboxLib ]
	then
		cd $vboxLib
		# for some reason debian/vbox devs changed the default download
		# path for the addons, and it doesn't match, so here the old
		# original one, if present, gets removed, and the new one gets a new
		# directory created, and it's put in that one. 
		if [ -f $vboxAddonName ]
		then
			rm -f $vboxAddonName
		fi
		if [ ! -d $vboxAddDir ]
		then
			mkdir $vboxAddDir
		fi
		cd $vboxAddDir
		wget -O $vboxAddonFile $vboxAddonURL || echo -e "${E}The vbox addons download failed, the file name probably changed.\nPlease let the svmi script maintainer know this.${N}"
		
		if [ -s $vboxAddonFile ]
		then
			mv $vboxAddonFile $vboxAddonName
			echo "${S}Please note: to use the ${C}$VBOX_INSTALLED_VERSION${S} iso, simply run vbox, then start your virtual machine."
			echo "When it is running, you will see a ${C}Devices${S} menu item. Select ${C}Install Guest Additions${S}"
			echo "vbox will discover the iso you just downloaded and use it for drivers and other tools.${N}"
		else
			echo "${E}Sorry, the download failed for some reason, let's find out why.${N}"
		fi
	else
		echo "${E}Virtualbox does not appear to be installed! Please install it first!${N}"
	fi
	echo
	print_hec
	eval $LOGPE
}
# install_vbox_addons
########################################################################
#### OPTIONS 
########################################################################
# keep this above getopts to keep it readable
# args: $1 if err or not, $2 extra data

show_options()
{
	if [ "$1" == 'err' ]
	then
		echo "${W}Sorry, one of your arguments is not a supported option.${N}"
		echo "Please check the following options and try again."
		echo $LINE
	fi
	echo "These are your supported options:"
	echo "-A Run the any any install non-interactively."
# 	echo "-g Lets you use a specific gcc version to compile module. Example: -g 4.1"
	echo "-h View this help menu."
	echo "-j Alternate text/output script colors. Requires this syntax: -j 0 (sets to monochrome )"
	echo "   -j 1 (script default); -j 2 (alternate color scheme); -j 3 (nice earthy scheme)"
	echo "-M Run the vbox module install non-interactively."
	echo "-R Skips self updating feature. No restart."
	echo "-u Enter the username that will be used for vbox group membership and other functions."
	echo "   Best used with non-interactive mode, but is fine for normal mode too. Example: svmi -u jeff"
	echo "-U Forces $SCRIPT_NAME to update itself, must be root, but can be in x. Exits after."
	echo "-v Prints $SCRIPT_NAME current version information. Exits after."
	echo "-V Allows you try a specific Version of vbox. Only applies to non-ose version."
	echo "   Supported versions: $VBOX_VERSIONS"
	echo "   Example: svmi -V 1.5.2"
	echo "-Z Skips connection test. Use this if $SCRIPT_NAME gives you connection failed error but"
	echo "   you are sure your connection is fine."
	echo 
	
	if [ "$1" == 'err' ]
	then
		exit 1
	else
		exit 0
	fi
}

# this must be set before anything else runs in script, -j will reset to no colors
set_script_colors 
while getopts ABDFhj:MpP:RSTuUvV:Z opt
do
	case $opt in
		A) AUTORUN_ANYANY='true'
			START_OPTIONS=$START_OPTIONS'A'
			;;
		B) AUTORUN_VBOX='true'
			START_OPTIONS=$START_OPTIONS'B'
			;;
		D) SM_INSTALL='true'
			S=${CALLER_DEF} # change standard text color to caller standard text
			BAR=${S}$BA${N}
			LINE=${S}$LI${N}
			START_OPTIONS=$START_OPTIONS'D'
			;;
		F) # for debugging purposes only
			SKIP_FUNCTION='true'
			START_OPTIONS=$START_OPTIONS'F'
			;;
		j)	if [ -n "$( egrep '^[0-3]$' <<< $OPTARG )" ]
			then
				SCRIPT_COLORS=$OPTARG
				set_script_colors
			else
				error_handler 249 $OPTARG
			fi
			;;
		M) AUTORUN_VBOX_MODULE='true'
			START_OPTIONS=$START_OPTIONS'M'
			;;
		p) AUTORUN_VMPLAYER='true'
			START_OPTIONS=$START_OPTIONS'p'
			;;
		P)	if [ -n $( egrep '^(apt-get|aptitude)$' <<< $OPTARG ) ]
			then
				PACKAGE_MANAGER=$OPTARG
				APT_TYPE=$OPTARG
			else
				error_handler 249 $OPTARG
			fi
			;;
		R) SKIP_RESTART='true'
			;;
		S) AUTORUN_VMSERVER='true'
			START_OPTIONS=$START_OPTIONS'S'
			;;
		T) TESTING='true'
			START_OPTIONS=$START_OPTIONS'T'
			;;
		u) USER_NAME="$OPTARG"
			;;
		U) FORCE_UPDATE='true' 
			;;
		v) print_information
			exit 0
			;;
		V) if [ -z "$( echo "$VBOX_PREVIOUS" | grep "$OPTARG:" )" ]
			then
				echo "${E}The -V option only supports non-ose vbox versions: $VBOX_VERSIONS${N}"
				exit 1
			else
				VBOX_VERSION="$OPTARG" # assign to main version global
				VBOX_ALT_VERSION="$OPTARG" # and set the alt as well
				VBOX_PACKAGE_NO=$( echo $VBOX_PREVIOUS | egrep -o "$VBOX_VERSION:[0-9]{5,6}" | cut -d ':' -f 2 )
				#echo vb pn $VBOX_PACKAGE_NO
			fi
			;;
		Z) SKIP_CONNECT='true'
			;;
		h) show_options
			;;
		*) show_options err
			;;
	esac
done
if [ -n "$USER_NAME" ]
then
	START_OPTIONS=$START_OPTIONS" -u $USER_NAME"
fi
if [ -n "$VBOX_ALT_VERSION" ]
then
	START_OPTIONS=$START_OPTIONS" -V $VBOX_ALT_VERSION"
fi
if [ -n "$PACKAGE_MANAGER" ]
then
	START_OPTIONS=$START_OPTIONS" -P $PACKAGE_MANAGER"
fi
if [ "$SCRIPT_COLORS" != 1 ]
then
	START_OPTIONS=$START_OPTIONS" -j $SCRIPT_COLORS"
fi

########################################################################
####  EXECUTE
########################################################################

# run all script checks etc

### if this exits with error, no lib files will be downloaded
if [ "$SKIP_FUNCTION" != 'true' ]
then
	basic_startup_tests
fi
cleanup_temp_files 
### update everything, restart if not run from smxi
if [ "$SKIP_RESTART" != 'true' -a "$SM_INSTALL" != 'true' -a "$SKIP_FUNCTION" != 'true' ]
then
	check_update_script $SCRIPT_NAME
fi
set_test_data # this will set other test data for debugging

create_log
# will run non interactive and set the AUTO_UPDATE flag
run_non_interactive
if [ -z "$PACKAGE_MANAGER" -a "$SM_INSTALL" != 'true' -a "$AUTO_UPDATE" != 'true' ]
then
	check_apt_aptitude
fi

print_information
check_install_tools

if [ "$AUTO_UPDATE" != 'true' ]
then
	vm_main_selector
fi

exit 0
###**EOF**###